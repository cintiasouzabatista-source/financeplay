<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FinancePlay 2.0</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<style>
        :root {
            --primary-color: #9aa3b2;
            --primary-dark: #7f8897;
            --secondary-color: #2ecc71;
            --secondary-dark: #27ae60;
            --danger-color: #e74c3c;
            --danger-dark: #c0392b;
            --warning-color: #f1c40f;
            --warning-dark: #d4ac0d;
            --bg-color: #0f1115;
            --card-bg: #171a21;
            --text-color: #e6e8ec;
            --text-light: #9aa3b2;
            --border-color: #2a2f3a;
            --shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
            --border-radius: 10px;
            --transition: all 0.25s ease;
        }

        [data-theme="dark"] {
            --primary-color: #9aa3b2;
            --primary-dark: #7f8897;
            --secondary-color: #2ecc71;
            --secondary-dark: #27ae60;
            --danger-color: #e74c3c;
            --danger-dark: #c0392b;
            --warning-color: #f1c40f;
            --warning-dark: #d4ac0d;
            --bg-color: #0f1115;
            --card-bg: #171a21;
            --text-color: #e6e8ec;
            --text-light: #9aa3b2;
            --border-color: #2a2f3a;
            --shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: var(--transition);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
        }

        .app-container {
            display: flex;
            flex: 1;
        }

        .sidebar {
            width: 250px;
            background-color: var(--card-bg);
            box-shadow: var(--shadow);
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            transition: var(--transition);
            z-index: 1000;
            overflow-y: auto;
        }

        .sidebar-header {
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid var(--border-color);
        }

        .sidebar-title {
            font-size: 1.5rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo-icon {
            color: var(--primary-color);
            font-size: 1.8rem;
        }

        .menu-toggle {
            display: none;
            background: none;
            border: none;
            color: var(--text-color);
            font-size: 1.5rem;
            cursor: pointer;
        }

        .nav-menu {
            list-style: none;
            padding: 20px 0;
        }

        .nav-item {
            margin-bottom: 5px;
        }

        .nav-link {
            display: flex;
            align-items: center;
            padding: 12px 20px;
            color: var(--text-color);
            text-decoration: none;
            border-radius: 6px;
            margin: 0 10px;
            transition: var(--transition);
        }

        .nav-link:hover {
            background-color: rgba(99, 102, 241, 0.1);
            color: var(--primary-color);
        }

        .nav-link.active {
            background-color: var(--primary-color);
            color: white;
        }

        .nav-icon {
            margin-right: 10px;
            width: 20px;
            text-align: center;
        }

        .main-content {
            flex: 1;
            margin-left: 250px;
            padding: 20px;
            transition: margin-left 0.3s ease;
            position: relative;
        }
        
        .main-content.sidebar-active-overlay::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .main-content.sidebar-active-overlay.sidebar-open::before {
            opacity: 1;
            visibility: visible;
        }


        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .page-title {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .header-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: var(--primary-color);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }

        .toggle-label {
            margin-left: 10px;
            font-size: 0.9rem;
            color: var(--text-light);
        }

        .card {
            background-color: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            padding: 20px;
            margin-bottom: 20px;
            transition: var(--transition);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .card-title {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .header-buttons {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
        }

        .stat-card {
            padding: 15px;
        }

        .stat-title {
            font-size: 0.9rem;
            color: var(--text-light);
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .stat-positive {
            color: var(--secondary-color);
        }

        .stat-negative {
            color: var(--danger-color);
        }

        .month-navigation {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .month-nav-btn {
            background: none;
            border: none;
            color: var(--text-color);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: var(--transition);
        }

        .month-nav-btn:hover {
            background-color: rgba(99, 102, 241, 0.1);
            color: var(--primary-color);
        }

        .current-month {
            font-size: 1.1rem;
            font-weight: 500;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: var(--border-radius);
            transition: var(--transition);
        }

        .current-month:hover {
            background-color: rgba(99, 102, 241, 0.1);
            color: var(--primary-color);
        }

        .btn {
            padding: 8px 16px;
            border-radius: var(--border-radius);
            border: none;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--primary-dark);
        }

        .btn-secondary {
            background-color: var(--secondary-color);
            color: white;
        }

        .btn-secondary:hover {
            background-color: var(--secondary-dark);
        }

        .btn-danger {
            background-color: var(--danger-color);
            color: white;
        }

        .btn-danger:hover {
            background-color: var(--danger-dark);
        }

        .btn-warning {
            background-color: var(--warning-color);
            color: white;
        }

        .btn-warning:hover {
            background-color: var(--warning-dark);
        }

        .btn-outlined {
            background-color: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-color);
        }

        .btn-outlined:hover {
            border-color: var(--primary-color);
            color: var(--primary-color);
        }

        .btn-sm {
            padding: 4px 10px;
            font-size: 0.85rem;
        }

        .btn-icon {
            width: 36px;
            height: 36px;
            padding: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }

        .transaction-list {
            margin-top: 20px;
        }

        .transaction-day {
            margin-bottom: 15px;
        }

        .day-header {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 10px;
            font-weight: 500;
        }

        .day-date {
            color: var(--text-light);
        }

        .day-balance {
            color: var(--secondary-color);
        }

        .day-balance.negative {
            color: var(--danger-color);
        }

        .transaction-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            border-radius: var(--border-radius);
            margin-bottom: 8px;
            transition: var(--transition);
            border: 1px solid var(--border-color);
        }

        .transaction-item:hover {
            background-color: rgba(99, 102, 241, 0.05);
        }
        .transaction-item.card-item-pending-preview {
            opacity: 0.6;
        }


        .transaction-info {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-grow: 1;
            min-width: 0;
        }

        .transaction-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            flex-shrink: 0;
        }

        .income-icon {
            background-color: rgba(16, 185, 129, 0.1);
            color: var(--secondary-color);
        }

        .expense-icon {
            background-color: rgba(239, 68, 68, 0.1);
            color: var(--danger-color);
        }

        .transfer-icon {
            background-color: rgba(99, 102, 241, 0.1);
            color: var(--primary-color);
        }

        .card-expense-icon {
            background-color: rgba(245, 158, 11, 0.1);
            color: var(--warning-color);
        }

        .card-invoice-group-icon {
            background-color: rgba(139, 92, 246, 0.1);
            color: var(--primary-color);
        }


        .transaction-details {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            min-width: 0;
        }

        .transaction-name {
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .transaction-category {
            font-size: 0.85rem;
            color: var(--text-light);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .transaction-amount {
            font-weight: 600;
            white-space: nowrap;
            margin-left: 10px;
        }

        .income-amount {
            color: var(--secondary-color);
        }

        .expense-amount {
            color: var(--danger-color);
        }

        .transaction-actions {
            display: flex;
            gap: 5px;
            opacity: 0;
            transition: var(--transition);
            flex-shrink: 0;
        }

        .transaction-item:hover .transaction-actions,
        .card-bill-group:hover .transaction-actions {
            opacity: 1;
        }


        .action-btn {
            background: none;
            border: none;
            color: var(--text-light);
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: var(--transition);
        }

        .action-btn:hover {
            color: var(--primary-color);
            background-color: rgba(99, 102, 241, 0.1);
        }

        .delete-btn:hover {
            color: var(--danger-color);
            background-color: rgba(239, 68, 68, 0.1);
        }

        .progress-container {
            margin: 15px 0;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .progress-title {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .progress-icon {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
        }

        .progress-values {
            color: var(--text-light);
        }

        
        .progress-bar {
            height: 16px;
            background-color: var(--border-color);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            border-radius: 4px;
            transition: var(--transition);
            position: relative;
            min-width: 26px;
        }

        .progress-percent {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 600;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0,0,0,0.35);
            pointer-events: none;
        }

        .progress-bar.clickable { cursor: pointer; }


        .drilldown-modal { max-width: 820px; }
        .drilldown-header-meta{ font-size: 0.85rem; color: var(--text-light); margin-top: 4px; }
        .drilldown-toolbar{ display:flex; gap:10px; align-items:center; justify-content: space-between; margin-bottom: 12px; flex-wrap: wrap; }
        .drilldown-search{ flex:1; min-width: 220px; }
        .drilldown-table{ width:100%; border-collapse: collapse; }
        .drilldown-table th, .drilldown-table td{ padding:10px 8px; border-bottom: 1px solid var(--border-color); font-size: 0.92rem; }
        .drilldown-table th{ text-align:left; color: var(--text-light); font-weight: 600; font-size: 0.8rem; letter-spacing: .02em; text-transform: uppercase; }
        .drilldown-table td.amount{ text-align:right; font-weight: 600; white-space: nowrap; }
        .drilldown-pill{ display:inline-flex; gap:6px; align-items:center; padding:4px 10px; border-radius: 999px; border: 1px solid var(--border-color); font-size: 0.8rem; color: var(--text-color); background: rgba(99, 102, 241, 0.06); }


        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: var(--transition);
            padding: 10px;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background-color: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            transform: translateY(-20px) scale(0.95);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .modal-overlay.active .modal {
            transform: translateY(0) scale(1);
            opacity: 1;
        }

        .modal-header {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-light);
            transition: var(--transition);
        }

        .modal-close:hover {
            color: var(--danger-color);
        }

        .modal-body {
            padding: 20px;
        }

        .form-row {
            margin-bottom: 15px;
        }

        .form-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .form-input,
        .form-select  {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background-color: var(--card-bg);
            color: var(--text-color);
            font-family: 'Poppins', sans-serif;
            font-size: 1rem;
            transition: var(--transition);
        }
        .form-input:focus,
        .form-select:focus {
            border-color: var(--primary-color);
            outline: none;
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2);
        }

        .form-select {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="%236b7280" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>');
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 20px;
            padding-right: 40px;
        }
        [data-theme="dark"] .form-select {
             background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="%23d1d5db" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>');
        }


        .form-row-inline {
            display: flex;
            gap: 15px;
        }

        .form-row-inline > * {
            flex: 1;
        }

        .form-check {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
        }

        .form-check input[type="checkbox"],
        .form-check input[type="radio"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary-color);
            cursor: pointer;
        }

        .form-check label {
            cursor: pointer;
            font-weight: normal;
        }

        .form-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            padding: 15px 20px;
            border-top: 1px solid var(--border-color);
        }

        .emoji-picker {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(36px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .emoji-item {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            border-radius: 6px;
            cursor: pointer;
            transition: var(--transition);
        }

        .emoji-item:hover {
            background-color: rgba(99, 102, 241, 0.1);
        }

        .emoji-item.selected {
            background-color: var(--primary-color);
            color: white;
        }

        .color-picker {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .color-item {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            transition: var(--transition);
            border: 2px solid transparent;
        }

        .color-item.selected {
            border-color: var(--text-color);
            transform: scale(1.2);
        }
         [data-theme="dark"] .color-item.selected {
            border-color: var(--primary-color);
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            background-color: var(--card-bg);
            color: var(--text-color);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            z-index: 2000;
            display: flex;
            align-items: center;
            gap: 10px;
            opacity: 0;
            transform: translateX(30px);
            transition: var(--transition);
            width: calc(100% - 40px);
            max-width: 350px;

        }

        .notification.active {
            opacity: 1;
            transform: translateX(0);
        }

        .notification-success {
            border-left: 4px solid var(--secondary-color);
        }

        .notification-error {
            border-left: 4px solid var(--danger-color);
        }

        .notification-warning {
            border-left: 4px solid var(--warning-color);
        }

        .notification-info {
            border-left: 4px solid var(--primary-color);
        }

        .notification-icon {
            font-size: 1.2rem;
        }

        .notification-success .notification-icon {
            color: var(--secondary-color);
        }

        .notification-error .notification-icon {
            color: var(--danger-color);
        }

        .notification-warning .notification-icon {
            color: var(--warning-color);
        }

        .notification-info .notification-icon {
            color: var(--primary-color);
        }

        .notification-content {
            flex: 1;
        }

        .notification-title {
            font-weight: 600;
            margin-bottom: 2px;
        }

        .notification-message {
            font-size: 0.85rem;
            color: var(--text-light);
        }

        .notification-close {
            background: none;
            border: none;
            color: var(--text-light);
            cursor: pointer;
            padding: 2px;
            font-size: 1rem;
            transition: var(--transition);
        }

        .notification-close:hover {
            color: var(--text-color);
        }

        .user-profile {
            position: relative;
        }

        .profile-button {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: var(--transition);
        }

        .profile-button:hover {
            background-color: rgba(99, 102, 241, 0.1);
        }

        .profile-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: var(--primary-color);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            font-weight: 600;
        }

        .profile-info {
            max-width: 140px;
            text-align: left;
        }

        .profile-name {
            font-weight: 500;
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .profile-email {
            font-size: 0.75rem;
            color: var(--text-light);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .profile-dropdown {
            position: absolute;
            top: calc(100% + 5px);
            right: 0;
            width: 200px;
            background-color: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            z-index: 1050;
            overflow: hidden;
            transform-origin: top right;
            transform: scale(0.95) translateY(-10px);
            opacity: 0;
            visibility: hidden;
            transition: transform 0.2s ease, opacity 0.2s ease, visibility 0.2s ease;
        }

        .profile-dropdown.active {
            transform: scale(1) translateY(0);
            opacity: 1;
            visibility: visible;
        }

        .dropdown-list {
            list-style: none;
        }

        .dropdown-item {
            padding: 10px 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: var(--transition);
            cursor: pointer;
            font-size: 0.9rem;
        }

        .dropdown-item:hover {
            background-color: rgba(99, 102, 241, 0.1);
            color: var(--primary-color);
        }
         [data-theme="dark"] .dropdown-item:hover {
            color: var(--primary-color);
        }


        .dropdown-item i {
            width: 20px;
            text-align: center;
        }

        .dropdown-divider {
            height: 1px;
            background-color: var(--border-color);
            margin: 5px 0;
        }

        .no-data {
            text-align: center;
            padding: 30px;
            color: var(--text-light);
        }

        .no-data i {
            font-size: 3rem;
            margin-bottom: 15px;
            opacity: 0.3;
        }

        .chart-container {
            position: relative;
            height: 250px;
            margin: 20px 0;
            padding: 15px;
            border-radius: 12px;
            background: linear-gradient(145deg, 
                var(--card-bg) 0%, 
                rgba(99, 102, 241, 0.02) 100%);
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            border: 1px solid rgba(99, 102, 241, 0.08);
        }

        .chart-container canvas {
            filter: drop-shadow(0 4px 12px rgba(0,0,0,0.08));
            border-radius: 8px;
        }

        .chart-container:has(#categoryChart) {
            height: 350px;
        }

        .chart-container:has(#incomeCategoryChart) {
            height: 350px;
        }

        .chart-container:has(#categoryChart) canvas,
        .chart-container:has(#incomeCategoryChart) canvas {
            max-width: 100%;
            max-height: 100%;
            width: 100% !important;
            height: 100% !important;
        }

        /* Garantir que ambos os donut charts tenham o mesmo tamanho */
        .chart-container:has(#categoryChart),
        .chart-container:has(#incomeCategoryChart) {
            min-height: 350px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .chart-container:has(#incomeExpenseChart) {
            height: 320px;
        }

        .chart-container:has(#futureIncomeExpenseChart) {
            height: 320px;
        }

        .chart-container:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }

        [data-theme="dark"] .chart-container {
            background: linear-gradient(145deg, 
                var(--card-bg) 0%, 
                rgba(99, 102, 241, 0.05) 100%);
            border: 1px solid rgba(99, 102, 241, 0.12);
            box-shadow: 0 2px 10px rgba(0,0,0,0.15);
        }

        [data-theme="dark"] .chart-container:hover {
            box-shadow: 0 8px 25px rgba(0,0,0,0.25);
        }

        @media (max-width: 768px) {
            .chart-container:has(#categoryChart) {
                height: 320px;
                padding: 10px;
            }
            
            .chart-container:has(#incomeCategoryChart) {
                height: 320px;
                padding: 10px;
            }

            .chart-container:has(#categoryChart),
            .chart-container:has(#incomeCategoryChart) {
                min-height: 320px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .chart-container:has(#incomeExpenseChart) {
                height: 280px;
                padding: 10px;
            }
            
            .chart-container:has(#futureIncomeExpenseChart) {
                height: 280px;
                padding: 10px;
            }
            
            .chart-container {
                margin: 15px 0;
                padding: 10px;
            }
            
            .chart-container:hover {
                transform: none;
            }
        }

        .login-container {
            display: flex;
            min-height: 100vh;
            width: 100%;
        }

        .login-image {
            flex: 1;
            background: #1F2937;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
        }

        .login-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 40px;
            min-width: 320px;
        }

        .login-header {
            margin-bottom: 30px;
            text-align: center;
        }

        .login-logo {
            font-size: 2.5rem;
            color: var(--primary-color);
            margin-bottom: 10px;
        }

        .login-title {
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .login-subtitle {
            color: var(--text-light);
        }

        .login-form {
            max-width: 400px;
            margin: 0 auto;
            width: 100%;
        }

        .login-footer {
            margin-top: 30px;
            text-align: center;
            color: var(--text-light);
            font-size: 0.85rem;
        }

        .settings-section {
            margin-bottom: 30px;
        }

        .settings-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .settings-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
        }
        .settings-section > .settings-option:not(:last-child) {
            border-bottom: 1px solid var(--border-color);
        }


        .settings-label {
            font-weight: 500;
        }

        .settings-description {
            font-size: 0.85rem;
            color: var(--text-light);
            margin-top: 2px;
        }

        @media (max-width: 992px) {
            .sidebar {
                width: 280px;
                transform: translateX(-100%);
                box-shadow: 0 0 20px rgba(0,0,0,0.15);
            }
            
            .sidebar.active {
                transform: translateX(0);
            }
            
            .menu-toggle {
                display: block; 
            }
            
            .main-content {
                margin-left: 0;
                width: 100%;
            }
            
            .header {
                position: sticky;
                top: 0;
                background-color: var(--bg-color);
                z-index: 900;
                padding: 10px 15px;
                margin-top:0;
                box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            }
            .page-title {
                margin-left: 10px;
                flex-grow: 1;
                text-align: left;
                font-size: 1.2rem;
            }
            .header-actions .user-profile {
                margin-left: auto;
            }
             .profile-name {
                max-width: 100px;
            }
            .profile-email {
                display: none;
            }
            
            .login-container {
                flex-direction: column;
            }
            
            .login-image {
                display: none;
            }
            .login-content {
                padding: 30px 20px;
                justify-content: flex-start;
                min-height: 100vh;
            }
            .notification {
                top: 10px;
                right: 10px;
                width: calc(100% - 20px);
            }
        }

        @media (max-width: 768px) {
            body {
                font-size: 14px;
                -webkit-text-size-adjust: 100%;
            }

            .main-content {
                padding: 10px;
            }

            .card {
                padding: 15px;
                margin-bottom: 15px;
            }

            .card-title {
                font-size: 1.1rem;
            }

            .btn {
                padding: 10px 14px;
                font-size: 0.9rem;
            }
            .btn i {
                font-size: 0.9em;
            }

            .btn-sm {
                padding: 6px 10px;
                font-size: 0.8rem;
            }

            .form-input,
            .form-select {
                padding: 12px 10px;
                font-size: 1rem;
            }

            .modal {
                width: calc(100% - 20px);
                margin: 10px;
                max-height: calc(100vh - 20px);
            }
            .modal-header {
                padding: 12px 15px;
            }
             .modal-title {
                font-size: 1.1rem;
            }
            .modal-body {
                padding: 15px;
            }

            .grid-container {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(183px, 1fr));
                gap: 5px;
            }

            .stat-card {
                padding: 12px;
                text-align: center;
            }
            .stat-card .stat-title {
                font-size: 0.85rem;
            }
            .stat-value {
                font-size: 1.4rem;
            }

            .month-navigation {
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
                width: 100%;
                margin-bottom: 15px;
                gap: 5px;
            }
            .month-nav-btn {
                font-size: 1.2rem;
                padding: 6px;
            }
            .current-month {
                font-size: 1rem;
                padding: 6px 10px;
                text-align: center;
                flex-grow: 1;
            }
            .header-actions {
                flex-wrap: wrap;
                justify-content: flex-end;
            }

            .header-actions .toggle-switch-container {
                width: 100%;
                display: flex;
                justify-content: center;
                margin-bottom: 10px;
                order: -1; /* Alterado para manter o toggle no topo em mobile */
            }

            .chart-container {
                height: 220px;
            }
            
            .form-row-inline {
                flex-direction: column;
                gap: 0;
            }
             .form-row-inline > .form-row {
                margin-bottom: 15px;
            }
            .form-row-inline > .form-row:last-child {
                margin-bottom: 0;
            }
            
            .transaction-item, .card-bill-group {
                flex-direction: row;
                align-items: flex-start;
                padding: 10px;
            }

            .transaction-item .transaction-info,
            .card-bill-group .transaction-info {
                margin-bottom: 10px;
                width: 100%;
            }
            .transaction-item .transaction-icon,
            .card-bill-group .transaction-icon {
                width: 32px;
                height: 32px;
                font-size: 1rem;
            }
             .transaction-item .transaction-details,
             .card-bill-group .transaction-details {
                gap: 2px;
            }
            .transaction-item .transaction-name,
            .card-bill-group .transaction-name {
                font-size: 0.9rem;
            }
             .transaction-item .transaction-category,
             .card-bill-group .transaction-category {
                font-size: 0.75rem;
            }

            .transaction-item > div:last-child:not(.transaction-info),
            .card-bill-header > div:last-child:not(.transaction-info) { /* Ajustado para card-bill-header também */
                 display: flex;
                justify-content: flex-end;
                align-items: center;
                margin-top: 5px;
				flex-wrap: wrap;
            }
            
            .transaction-item .transaction-amount,
            .card-bill-header .transaction-amount {
                font-size: 0.95rem;
            }

            .transaction-item .transaction-actions,
            .card-bill-group .transaction-actions {
                opacity: 1;
                gap: 10px;
            }
            .transaction-item .action-btn,
            .card-bill-group .action-btn {
                padding: 7px;
                font-size: 0.9rem;
            }

             .toggle-completed {
                width: 36px;
                height: 18px;
                margin-right: 5px;
            }
            .toggle-completed-slider:before {
                height: 12px;
                width: 12px;
                left: 3px;
                bottom: 3px;
            }
            input:checked + .toggle-completed-slider:before {
                transform: translateX(18px);
            }

            .day-header {
                padding: 8px 0;
                font-size: 0.85rem;
            }
            .day-date, .day-balance {
                white-space: nowrap;
            }
            
            .card-bill-body {
                padding-left: 0; /* Removido padding desnecessário */
                width: 100%;
            }
            .card-bill-body .transaction-item {
                padding: 8px;
                border: none;
                border-bottom: 1px dashed var(--border-color);
                margin-bottom: 5px;
            }
             .card-bill-body .transaction-item:last-child {
                border-bottom: none;
                margin-bottom: 0;
            }
            .card-bill-body .transaction-item:hover {
                background-color: transparent;
            }


            .card-bill-header {
                padding: 10px 12px;
                flex-wrap: wrap; 
            }
             .card-bill-title { /* Renomeado de .card-bill-header .transaction-name para consistência */
                font-size: 0.9rem;
                width: 100%;
                margin-bottom: 5px;
            }
            .card-bill-header .transaction-amount { /* Ajuste para valor da fatura */
                font-size: 0.9rem;
                width: auto; /* Para não ocupar toda a largura */
                text-align: right;
                margin-top:0; /* Reset margin-top */
            }
            .card-bill-body.active {
                max-height: none; /* Para evitar problemas de cálculo de altura em mobile */
            }
            .card-bill-content, .card-bill-footer {
                padding: 10px 12px;
            }
             .card-bill-footer .btn { /* Botões no rodapé do grupo de fatura */
                width: 100%;
                margin-top: 5px;
            }
            .card-bill-footer .btn:first-child {
                 margin-top: 0;
            }


            .emoji-picker {
                grid-template-columns: repeat(auto-fill, minmax(32px, 1fr));
                gap: 8px;
            }
            .emoji-item {
                width: 32px;
                height: 32px;
                font-size: 1.1rem;
            }

            .color-picker {
                gap: 8px;
            }
            .color-item {
                width: 28px;
                height: 28px;
            }

            .form-footer {
                padding: 12px 15px;
                gap: 8px;
                flex-direction: column; /* Empilhar botões em mobile */
            }
            .form-footer .btn {
                width: 100%;
                padding: 10px 12px;
                font-size: 0.9rem;
            }

            .settings-option {
                flex-direction: column;
                align-items: flex-start;
                padding: 15px 0;
            }
            .settings-option > div:first-child { /* Label e descrição */
                margin-bottom: 10px;
                width: 100%;
            }
            .settings-option > div:last-child { /* Input, select, botão, toggle */
                width: 100%;
            }
            .settings-option .form-input,
            .settings-option .form-select,
            .settings-option .btn {
                width: 100%;
                max-width: none; /* Reset max-width */
            }
            .settings-option .toggle-switch {
                align-self: flex-start; /* Alinhar toggle à esquerda */
                margin-top: 5px;
            }
            .filter-box {
                flex-direction: column;
                gap: 15px;
            }
            .filter-item {
                width: 100%;
                min-width: unset;
            }
            .filter-actions {
                width: 100%;
                justify-content: flex-end;
            }
        }


        .simulator-card {
            max-width: 700px;
            margin: 0 auto;
        }

        .simulator-result {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
        }

        .result-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 15px;
        }

        .result-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
        }
        @media (max-width: 768px) {
             .result-grid {
                grid-template-columns: 1fr;
            }
        }


        .result-item {
            text-align: center;
            padding: 15px;
            background-color: rgba(99, 102, 241, 0.05);
            border-radius: var(--border-radius);
        }

        .result-value {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 5px;
        }
         @media (max-width: 768px) {
            .result-value {
                font-size: 1.3rem;
            }
        }


        .result-label {
            font-size: 0.85rem;
            color: var(--text-light);
        }

        .upgrade-banner {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            border-radius: var(--border-radius);
            padding: 20px;
            margin-bottom: 20px;
            color: white;
            position: relative;
            overflow: hidden;
        }

        .upgrade-content {
            position: relative;
            z-index: 1;
        }

        .upgrade-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .upgrade-features {
            margin: 15px 0;
            font-size: 0.9rem;
        }

        .feature-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .feature-icon {
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
        }

        .upgrade-banner::before {
            content: "";
            position: absolute;
            top: 0;
            right: 0;
            width: 200px;
            height: 200px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            transform: translate(30%, -30%);
            z-index: 0;
        }

        .upgrade-banner::after {
            content: "";
            position: absolute;
            bottom: 0;
            left: 0;
            width: 150px;
            height: 150px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            transform: translate(-30%, 30%);
            z-index: 0;
        }
        @media (max-width: 768px) {
            .upgrade-title {
                font-size: 1.1rem;
            }
            .upgrade-banner {
                padding: 15px;
            }
            .upgrade-banner .btn {
                width: 100%;
                padding: 10px;
            }
        }


        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 0.8s linear infinite;
            margin-right: 10px; /* Ajustado para margin-right para botões com texto */
        }
        .btn .loading-spinner {
             border: 2px solid rgba(255, 255, 255, 0.3); /* Garantir consistência */
             border-top-color: white; /* Garantir consistência */
        }
        .btn-outlined .loading-spinner {
             border: 2px solid var(--text-light); /* Cor para modo outlined */
             border-top-color: var(--primary-color); /* Cor para modo outlined */
        }


        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
        
        /* Estilos adaptativos para modal de upgrade */
        .upgrade-plan-card {
            border-radius: 16px;
            padding: 24px;
            text-align: center;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .upgrade-plan-basic {
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            border: 2px solid transparent;
        }
        
        .upgrade-plan-essential {
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            border: 2px solid transparent;
        }
        
        .upgrade-plan-complete {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            border: 2px solid #60a5fa;
            box-shadow: 0 8px 32px rgba(59, 130, 246, 0.3);
        }
        
        /* Tema claro - adaptações */
        [data-theme="light"] .upgrade-plan-basic,
        :not([data-theme="dark"]) .upgrade-plan-basic {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            border: 2px solid #e2e8f0;
        }
        
        [data-theme="light"] .upgrade-plan-essential,
        :not([data-theme="dark"]) .upgrade-plan-essential {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            border: 2px solid #e2e8f0;
        }
        
        [data-theme="light"] .upgrade-plan-complete,
        :not([data-theme="dark"]) .upgrade-plan-complete {
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
            border: 2px solid #3b82f6;
            box-shadow: 0 8px 32px rgba(59, 130, 246, 0.2);
        }
        
        .upgrade-plan-text {
            color: white;
        }
        
        .upgrade-plan-text-muted {
            color: #94a3b8;
        }
        
        .upgrade-plan-text-complete {
            color: white;
        }
        
        .upgrade-plan-text-complete-muted {
            color: #bfdbfe;
        }
        
        /* Tema claro - cores de texto */
        [data-theme="light"] .upgrade-plan-text,
        :not([data-theme="dark"]) .upgrade-plan-text {
            color: #1e293b;
        }
        
        [data-theme="light"] .upgrade-plan-text-muted,
        :not([data-theme="dark"]) .upgrade-plan-text-muted {
            color: #64748b;
        }
        
        [data-theme="light"] .upgrade-plan-text-complete,
        :not([data-theme="dark"]) .upgrade-plan-text-complete {
            color: #1e40af;
        }
        
        [data-theme="light"] .upgrade-plan-text-complete-muted,
        :not([data-theme="dark"]) .upgrade-plan-text-complete-muted {
            color: #3b82f6;
        }
        
        .upgrade-plan-divider {
            border-bottom: 1px solid #475569;
        }
        
        .upgrade-plan-divider-complete {
            border-bottom: 1px solid #60a5fa;
        }
        
        [data-theme="light"] .upgrade-plan-divider,
        :not([data-theme="dark"]) .upgrade-plan-divider {
            border-bottom: 1px solid #cbd5e1;
        }
        
        [data-theme="light"] .upgrade-plan-divider-complete,
        :not([data-theme="dark"]) .upgrade-plan-divider-complete {
            border-bottom: 1px solid #93c5fd;
        }
        
        .card-bill-group {
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            margin-bottom: 15px;
        }
        .card-bill-group.invoice-group-pending-preview {
            opacity: 0.6;
        }


        .card-bill-header {
            padding: 12px 15px;
            background-color: rgba(99, 102, 241, 0.05); /* Leve destaque */
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative; /* Para posicionamento de elementos filhos se necessário */
        }
        .card-bill-header .transaction-info {
             margin-bottom: 0; /* Reset margin-bottom */
        }


        .card-bill-title { /* Nome da fatura */
            font-weight: 500;
            display: flex; /* Para alinhar ícone e texto se houver */
            align-items: center;
            gap: 10px;
        }
        
        .card-bill-icon-toggle { /* Ícone de expandir/recolher */
            font-size: 0.8rem;
            transition: var(--transition);
            margin-left: auto; /* Empurrar para a direita */
            padding: 5px; /* Área de clique maior */
        }
        
        .card-bill-header.active .card-bill-icon-toggle {
            transform: rotate(180deg);
        }
        
        .card-bill-body {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        
        .card-bill-body.active {
            max-height: 1000px; /* Um valor alto para acomodar o conteúdo */
        }
        
        .card-bill-content {
            padding: 0px 15px 10px 15px; /* Ajustado padding */
        }
         .card-bill-content .transaction-item {
            border-left: 3px solid var(--warning-color); /* Destaque visual para itens da fatura */
            margin-left: 10px; /* Leve indentação */
            padding: 8px 10px;
            font-size: 0.9em; /* Ligeiramente menor */
        }
        .card-bill-content .transaction-item .transaction-icon {
            width: 28px;
            height: 28px;
            font-size: 0.9rem;
        }
        
        .card-bill-footer {
            padding: 12px 15px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between; /* Padrão para desktop */
            align-items: center;
            flex-wrap: wrap; /* Permitir quebra em mobile */
            gap: 10px; /* Espaçamento entre botões/status */
        }
        
        .status-tag {
            display: inline-flex;
            align-items: center;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
            margin-left: 10px; /* Espaçamento se estiver ao lado do nome */
            vertical-align: middle; /* Alinhamento vertical */
        }
        
        .status-paid {
            background-color: var(--secondary-color);
            color: white;
        }
        .status-paid i { /* Ícone dentro da tag */
            margin-right: 4px;
        }
        
        .filter-box {
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }
        
        .filter-item {
            flex: 1;
            min-width: 150px; /* Largura mínima para cada filtro */
        }
        
        .filter-label {
            font-size: 0.85rem;
            font-weight: 500;
            margin-bottom: 5px;
            display: block; /* Para ocupar a linha inteira */
        }
        
        .filter-actions {
            display: flex;
            gap: 10px;
            align-items: center; /* Alinhar botões de ordenação */
        }
        
        .sort-buttons {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .opacity-50 {
            opacity: 0.5;
        }
        
        .filter-toggle-icon {
            margin-left: 8px;
            cursor: pointer;
            color: var(--text-light);
            transition: var(--transition);
            font-size: 0.9rem;
        }

        .filter-toggle-icon:hover {
            color: var(--primary-color);
        }

        .toggle-completed {
            position: relative;
            display: inline-block;
            width: 40px; 
            height: 20px;
            margin-right: 8px; /* Espaçamento do toggle */
        }

        .toggle-completed input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-completed-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .toggle-completed-slider:before {
            position: absolute;
            content: "";
            height: 14px; 
            width: 14px;
            left: 3px;  
            bottom: 3px; 
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-completed-slider {
            background-color: var(--secondary-color); /* Cor quando checado */
        }

        input:checked + .toggle-completed-slider:before {
            transform: translateX(20px); /* Deslocamento do círculo */
        }

    </style>

    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#6366f1">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="financasgo-completo-7a3240bf">
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="apple-touch-icon" href="./assets/icon-512x512.png">
    <link rel="icon" type="image/png" sizes="192x192" href="./assets/icon-512x512.png">
<script>
if ("serviceWorker" in navigator) {
    window.addEventListener("load", function() {
        navigator.serviceWorker.register("./service-worker.js")
            .then(function(registration) {
                console.log("SW registered: ", registration);
            }, function(registrationError) {
                console.log("SW registration failed: ", registrationError);
            });
    });
}
</script></head>
<body>
    <div id="app">
        </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script>
        
        class FinanceApp {
            constructor() {
                this.dbManager = new IndexedDBManager('FinancasGO_Universal');
                this.currentView = null;
                
                this.PLAN_CONFIG = 'completo';
                
                this.CHECKOUT_LINKS = {
                    essencial: 'https://pay.metodogo.com/1/checkout-financasgo-plano-master',
                    completo: 'https://pay.metodogo.com/1/checkout-financasgo-plano-master-up'
                };
                
                this.user = null;
                this.licenseInfo = null;
                this.isPreviewMode = this.isFeatureAvailable('preview_mode'); 
                this.darkMode = false;
                this.currentMonth = new Date().getMonth();
                this.currentYear = new Date().getFullYear();
                this.transactionsSortOrder = 'asc'; 
                this.selectedFilterAccount = 'all';
                this.customDateFilterEnabled = false;
                this.customDateStart = null;
                this.customDateEnd = null; 
                this.data = { transactions: [], categories: { income: [], expense: [] }, accounts: [], cards: [] };
                this.timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                this.timezoneOffset = new Date().getTimezoneOffset(); 
                this.usePreviousMonthBalance = true; 
                this.paidCardInvoices = [];
                this.transactionFilters = { type: 'all', category: 'all', account: 'all' };
                this.defaultData = {
    categories: { 
        income: [], 
        expense: []
    },
    accounts: [],
    cards: []
};
                this.licenseKeys = { 
    completo: { 'lifetime': '6ba7b814-9dad-11d1-80b4-00c04fd430c8' }
};
this.planType = 'completo';
                this.upgradePlanURL = "https://www.seusite.com/checkout?plan=complete"; // URL PLANO UPGRADE
                this.emojiList = [  '💰', '💵', '💳', '📈', '📉', '💹', '💸', '🏦', '🏠', '🏢', '🔧', '🧹', '🛋️', '⚡', '💧', '🔥', '📶', '📱', '🚗', '🚕', '🚌', '⛽', '🚲', '✈️',  '🛒', '👕', '👞', '🧴', '🛍️',  '🍔', '🍝', '☕', '🍲', '🍺',  '🎬', '🎮', '📚', '🎭', '🎵', '🏖️', '💊', '🏥', '🦷', '👓', '🧠',  '🏋️', '🧘', '🏃', '💆', '🥗', '💼', '📊', '🖥️', '👔', '🚕', '🎓', '📚', '📝', '💻', '🔬',  '👤', '👨', '👩', '👨‍👩‍👧', '🐱', '🤖', '👑',  '📆', '🔄', '🕒', '🎁', '💫', '🎯', '💰', '🏠', '🚗', '💍', '🌴' ];
                this.colorList = ['#ef4444', '#f97316', '#f59e0b', '#eab308', '#84cc16', '#10b981', '#06b6d4', '#0ea5e9', '#3b82f6', '#6366f1', '#8b5cf6', '#a855f7', '#d946ef', '#ec4899', '#f43f5e'];
                this.timezoneList = [ { value: -12, label: '(UTC-12:00) International Date Line West' }, { value: -11, label: '(UTC-11:00) Coordinated Universal Time-11' }, { value: -10, label: '(UTC-10:00) Hawaii' }, { value: -9, label: '(UTC-09:00) Alaska' }, { value: -8, label: '(UTC-08:00) Pacific Time (US & Canada)' }, { value: -7, label: '(UTC-07:00) Mountain Time (US & Canada)' }, { value: -6, label: '(UTC-06:00) Central Time (US & Canada)' }, { value: -5, label: '(UTC-05:00) Eastern Time (US & Canada)' }, { value: -4, label: '(UTC-04:00) Atlantic Time (Canada)' }, { value: -3, label: '(UTC-03:00) Brasilia' }, { value: -2, label: '(UTC-02:00) Mid-Atlantic' }, { value: -1, label: '(UTC-01:00) Azores' }, { value: 0, label: '(UTC+00:00) London, Dublin, Edinburgh' }, { value: 1, label: '(UTC+01:00) Berlin, Paris, Madrid' }, { value: 2, label: '(UTC+02:00) Athens, Istanbul, Helsinki' }, { value: 3, label: '(UTC+03:00) Moscow, St. Petersburg' }, { value: 4, label: '(UTC+04:00) Dubai, Abu Dhabi' }, { value: 5, label: '(UTC+05:00) Islamabad, Karachi' }, { value: 5.5, label: '(UTC+05:30) New Delhi, Mumbai' }, { value: 6, label: '(UTC+06:00) Dhaka' }, { value: 7, label: '(UTC+07:00) Bangkok, Jakarta' }, { value: 8, label: '(UTC+08:00) Beijing, Hong Kong, Singapore' }, { value: 9, label: '(UTC+09:00) Tokyo, Seoul' }, { value: 9.5, label: '(UTC+09:30) Adelaide' }, { value: 10, label: '(UTC+10:00) Sydney, Melbourne' }, { value: 11, label: '(UTC+11:00) Vladivostok' }, { value: 12, label: '(UTC+12:00) Auckland, Wellington' } ];
                this.app = document.getElementById('app');
                this.init();
            }
            
async init() {
    try {
        this.notificationSystem = new NotificationSystem();
        
        if (!window.indexedDB) {
            console.warn("Seu navegador não suporta IndexedDB. Usando localStorage como fallback.");
            this.notificationSystem.show(
                'Compatibilidade do Navegador', 
                'Seu navegador não suporta armazenamento avançado. A aplicação funcionará com limitações de armazenamento.', 
                'warning', 
                8000
            );
            await this.initWithLocalStorage();
            return;
        }
        
        await this.dbManager.ready();
        await this.migrateOldDatabases();
        const dataFromIDB = await this.dbManager.loadData('finance_data');
        
        if (!dataFromIDB) {
            await this.migrateDataFromLocalStorage();
        }
        
        await this.loadData();
        
        this.user = await this.loadFromStorage('finance_user');
        this.licenseInfo = await this.loadFromStorage('finance_license');
        
        if (!this.user || !this.licenseInfo) {
            await this.initializeTrial();
        }
        
        if (!await this.checkTrialAndLicenseStatus()) {
            this.showTrialExpiredModal();
            return;
        }
        
        const savedDarkMode = await this.loadFromStorage('finance_darkmode');
        this.darkMode = (savedDarkMode === null || savedDarkMode === undefined) ? true : savedDarkMode;
        
        if (this.darkMode) {
            document.documentElement.setAttribute('data-theme', 'dark');
        }
        
        const savedTimezoneOffsetInMinutes = await this.loadFromStorage('finance_timezone_offset');
        if (savedTimezoneOffsetInMinutes !== null) {
            this.timezoneOffset = savedTimezoneOffsetInMinutes;
        } else {
            this.timezoneOffset = new Date().getTimezoneOffset();
            await this.saveToStorage('finance_timezone_offset', this.timezoneOffset);
        }
        
        const usePrevMonth = await this.loadFromStorage('finance_use_prev_month');
        if (usePrevMonth === true || usePrevMonth === false) {
            this.usePreviousMonthBalance = usePrevMonth;
            console.log(`Configuração carregada: usePreviousMonthBalance = ${usePrevMonth}`);
        } else {
            console.log(`Nenhuma configuração encontrada, usando padrão: usePreviousMonthBalance = ${this.usePreviousMonthBalance}`);
            await this.saveToStorage('finance_use_prev_month', this.usePreviousMonthBalance);
        }
        
        const paidInvoices = await this.loadFromStorage('finance_paid_invoices');
        if (paidInvoices) {
            this.paidCardInvoices = paidInvoices;
        }
        
        const savedSortOrder = await this.loadFromStorage('finance_sort_order');
        if (savedSortOrder) {
            this.transactionsSortOrder = savedSortOrder;
        }
        
        this.renderMainApp();
        this.navigate('dashboard');
        this.setupBackupReminder();
        
    } catch (error) {
        console.error("Erro ao inicializar a aplicação:", error);
        this.notificationSystem.show(
            'Erro ao Inicializar', 
            'Ocorreu um erro ao carregar seus dados. Tente recarregar a página.', 
            'error', 
            10000
        );
        
        await this.initWithLocalStorage();
    }
}

async initWithLocalStorage() {
    if (!this.notificationSystem) {
        this.notificationSystem = new NotificationSystem();
    }
    
    const savedData = this.loadFromStorageSync('finance_data');
    if (savedData) {
        this.data = savedData;
        if (!this.data.transactions) this.data.transactions = [];
        if (!this.data.categories) this.data.categories = { income: [], expense: [] };
        if (!this.data.categories.income) this.data.categories.income = [];
        if (!this.data.categories.expense) this.data.categories.expense = [];
        if (!this.data.accounts) this.data.accounts = [];
        if (!this.data.cards) this.data.cards = [];
        
        let needsUpdate = false;
        
        if (this.data.cards && Array.isArray(this.data.cards)) {
            this.data.cards.forEach(card => {
                if (!card.account && this.data.accounts && this.data.accounts.length > 0) {
                    card.account = this.data.accounts[0].id;
                    needsUpdate = true;
                } else if (!card.account && (!this.data.accounts || this.data.accounts.length === 0)) {
                    card.account = null;
                    needsUpdate = true;
                }
            });
        }
        
        if (needsUpdate) {
            localStorage.setItem('finance_data', JSON.stringify(this.data));
        }
    } else {
        this.data = {
            categories: JSON.parse(JSON.stringify(this.defaultData.categories)),
            accounts: JSON.parse(JSON.stringify(this.defaultData.accounts)),
            cards: JSON.parse(JSON.stringify(this.defaultData.cards)),
            transactions: []
        };
        localStorage.setItem('finance_data', JSON.stringify(this.data));
    }
    
    this.user = this.loadFromStorageSync('finance_user');
    this.licenseInfo = this.loadFromStorageSync('finance_license');
    
    if (!this.user || !this.licenseInfo) {
        this.initializeTrialSync();
    }
    
    // Verificar trial status
    if (!this.checkTrialAndLicenseStatusSync()) {
        this.showTrialExpiredModal();
        return;
    }
    
    this.darkMode = this.loadFromStorageSync('finance_darkmode') || false;
    
    if (this.darkMode) {
        document.documentElement.setAttribute('data-theme', 'dark');
    }
    
    const savedTimezoneOffsetInMinutes = this.loadFromStorageSync('finance_timezone_offset');
    if (savedTimezoneOffsetInMinutes !== null) {
        this.timezoneOffset = savedTimezoneOffsetInMinutes;
    } else {
        this.timezoneOffset = new Date().getTimezoneOffset();
        localStorage.setItem('finance_timezone_offset', JSON.stringify(this.timezoneOffset));
    }
    
    const usePrevMonth = this.loadFromStorageSync('finance_use_prev_month');
    if (usePrevMonth === true || usePrevMonth === false) {
        this.usePreviousMonthBalance = usePrevMonth;
        console.log(`Configuração carregada (sync): usePreviousMonthBalance = ${usePrevMonth}`);
    } else {
        console.log(`Nenhuma configuração encontrada (sync), usando padrão: usePreviousMonthBalance = ${this.usePreviousMonthBalance}`);
        localStorage.setItem('finance_use_prev_month', JSON.stringify(this.usePreviousMonthBalance));
    }
    
    const paidInvoices = this.loadFromStorageSync('finance_paid_invoices');
    if (paidInvoices) {
        this.paidCardInvoices = paidInvoices;
    }
    
    this.renderMainApp();
    this.navigate('dashboard');
    this.setupBackupReminder();
}

async initializeTrial() {
    const currentDate = new Date();
    const trialData = {
        startDate: currentDate.toISOString(),
        endDate: new Date(currentDate.getTime() + (7 * 24 * 60 * 60 * 1000)).toISOString(),
        browserFingerprint: this.generateBrowserFingerprint(),
        installId: this.generateId(),
        accessCount: 1
    };
    
    // Criar usuário automático
    this.user = { 
        name: '', 
        email: '', 
        emoji: '👤' 
    };
    
    // Criar licença de trial
    this.licenseInfo = { 
        key: 'TRIAL', 
        type: 'trial', 
        validity: '7days', 
        activationDate: currentDate.toISOString(),
        isTrialActive: true,
        trialData: trialData
    };
    
    // Salvar dados de controle em múltiplas chaves para dificultar bypass
    await this.saveToStorage('finance_user', this.user);
    await this.saveToStorage('finance_license', this.licenseInfo);
    await this.saveToStorage('finance_trial_control', trialData);
    await this.saveToStorage('finance_install_id', trialData.installId);
    await this.saveToStorage('finance_trial_start', trialData.startDate);
    
    this.notificationSystem.show(
        'Bem-vindo ao FinancePlay', 
        'Parabéns pela sua compra! Você tem acesso completo!', 
        'success', 
        10000
    );
}

generateBrowserFingerprint() {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    ctx.textBaseline = 'top';
    ctx.font = '14px Arial';
    ctx.fillText('FinancePlay Fingerprint', 2, 2);
    
    const fingerprint = {
        canvas: canvas.toDataURL(),
        userAgent: navigator.userAgent,
        language: navigator.language,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        screen: `${screen.width}x${screen.height}x${screen.colorDepth}`,
        timestamp: Date.now()
    };
    
    return btoa(JSON.stringify(fingerprint));
}

async checkTrialAndLicenseStatus() {
    if (!this.licenseInfo) return false;
    
    // Se não for trial, verificar chave de licença
    if (this.licenseInfo.key !== 'TRIAL') {
        return this.validateLicense(this.licenseInfo.key);
    }
    
    // Verificar trial
    const currentDate = new Date();
    const trialControl = await this.loadFromStorage('finance_trial_control');
    const installId = await this.loadFromStorage('finance_install_id');
    const trialStart = await this.loadFromStorage('finance_trial_start');
    
    // Verificações de integridade
    if (!trialControl || !installId || !trialStart) {
        return false;
    }
    
    if (trialControl.installId !== installId) {
        return false;
    }
    
    if (trialControl.startDate !== trialStart) {
        return false;
    }
    
    const endDate = new Date(trialControl.endDate);
    
    // Verificar se o trial expirou
    if (currentDate > endDate) {
        this.licenseInfo.isTrialActive = false;
        await this.saveToStorage('finance_license', this.licenseInfo);
        return false;
    }
    
    // Atualizar contador de acesso
    trialControl.accessCount = (trialControl.accessCount || 0) + 1;
    await this.saveToStorage('finance_trial_control', trialControl);
    
    return true;
}

initializeTrialSync() {
    const currentDate = new Date();
    const trialData = {
        startDate: currentDate.toISOString(),
        endDate: new Date(currentDate.getTime() + (7 * 24 * 60 * 60 * 1000)).toISOString(),
        browserFingerprint: this.generateBrowserFingerprint(),
        installId: this.generateId(),
        accessCount: 1
    };
    
    // Criar usuário automático
    this.user = { 
        name: '', 
        email: '', 
        emoji: '👤' 
    };
    
    // Criar licença de trial
    this.licenseInfo = { 
        key: 'TRIAL', 
        type: 'trial', 
        validity: '7days', 
        activationDate: currentDate.toISOString(),
        isTrialActive: true,
        trialData: trialData
    };
    
    // Salvar dados de controle em múltiplas chaves para dificultar bypass
    localStorage.setItem('finance_user', JSON.stringify(this.user));
    localStorage.setItem('finance_license', JSON.stringify(this.licenseInfo));
    localStorage.setItem('finance_trial_control', JSON.stringify(trialData));
    localStorage.setItem('finance_install_id', JSON.stringify(trialData.installId));
    localStorage.setItem('finance_trial_start', JSON.stringify(trialData.startDate));
    
    this.notificationSystem.show(
        'Bem-vindo ao FinancePlay', 
        'Parabéns pela sua compra! Você terá acesso completo por 7 dias, após este período receberá sua chave vitalícia na área de membros.', 
        'success', 
        10000
    );
}

checkTrialAndLicenseStatusSync() {
    if (!this.licenseInfo) return false;
    
    // Se não for trial, verificar chave de licença
    if (this.licenseInfo.key !== 'TRIAL') {
        return this.validateLicense(this.licenseInfo.key);
    }
    
    // Verificar trial
    const currentDate = new Date();
    const trialControl = this.loadFromStorageSync('finance_trial_control');
    const installId = this.loadFromStorageSync('finance_install_id');
    const trialStart = this.loadFromStorageSync('finance_trial_start');
    
    // Verificações de integridade
    if (!trialControl || !installId || !trialStart) {
        return false;
    }
    
    if (trialControl.installId !== installId) {
        return false;
    }
    
    if (trialControl.startDate !== trialStart) {
        return false;
    }
    
    const endDate = new Date(trialControl.endDate);
    
    // Verificar se o trial expirou
    if (currentDate > endDate) {
        this.licenseInfo.isTrialActive = false;
        localStorage.setItem('finance_license', JSON.stringify(this.licenseInfo));
        return false;
    }
    
    // Atualizar contador de acesso
    trialControl.accessCount = (trialControl.accessCount || 0) + 1;
    localStorage.setItem('finance_trial_control', JSON.stringify(trialControl));
    
    return true;
}
            
           async loadData() {
    try {
        const savedData = await this.loadFromStorage('finance_data');
        if (savedData) {
            this.data = savedData;
            let needsUpdate = false;
            
            // Garantir que todos os arrays e objetos necessários existam
            if (!this.data.transactions) this.data.transactions = [];
            if (!this.data.categories) this.data.categories = { income: [], expense: [] };
            if (!this.data.categories.income) this.data.categories.income = [];
            if (!this.data.categories.expense) this.data.categories.expense = [];
            if (!this.data.accounts) this.data.accounts = [];
            if (!this.data.cards) this.data.cards = [];
            
            // Verificar cartões e associá-los a contas se necessário
            if (this.data.cards && Array.isArray(this.data.cards)) {
                this.data.cards.forEach(card => {
                    if (!card.account && this.data.accounts && this.data.accounts.length > 0) {
                        card.account = this.data.accounts[0].id; 
                        needsUpdate = true;
                    } else if (!card.account && (!this.data.accounts || this.data.accounts.length === 0)) {
                        card.account = null; 
                        needsUpdate = true;
                    }
                });
            }
            
            if (needsUpdate) {
                await this.saveData(false); 
            }
        } else {
            // Inicializar com dados padrão
            this.data = {
                categories: JSON.parse(JSON.stringify(this.defaultData.categories)),
                accounts: JSON.parse(JSON.stringify(this.defaultData.accounts)),
                cards: JSON.parse(JSON.stringify(this.defaultData.cards)),
                transactions: []
            };
            await this.saveToStorage('finance_data', this.data);
        }
    } catch (error) {
        console.error("Erro ao carregar dados:", error);
        
        // Em caso de erro, inicializar com dados vazios
        this.data = {
            transactions: [],
            categories: { income: [], expense: [] },
            accounts: [],
            cards: []
        };
    }
}
            
           async saveData(showNotification = true) {
    try {
        await this.saveToStorage('finance_data', this.data);
        return true;
    } catch (error) {
        console.error("Erro ao salvar dados:", error);
        if (this.notificationSystem && showNotification) {
            this.notificationSystem.show('Erro ao Salvar', 'Ocorreu um problema ao salvar seus dados.', 'error');
        }
        return false;
    }
}
            
           /**
            * Calcula o saldo realizado de uma conta até uma data limite.
            * Saldo realizado considera apenas transações marcadas como 'completed'.
            * Usado para verificar se há saldo suficiente para marcar uma transação como 'completed'.
            */
            calculateAccountRealizedBalance(accountId, dateLimit = null, excludeTransactionId = null) {
                const account = this.data.accounts.find(acc => acc.id === accountId);
                if (!account) return 0;
            
                let realizedBalance = account.initialBalance;
            
                const transactionsToConsider = this.data.transactions.filter(t => {
                    if (t.id === excludeTransactionId) return false; 
                    if (!t.completed) return false; 
            
                    const transactionDate = this.parseDate(t.date);
                    if (dateLimit && transactionDate > this.parseDate(dateLimit)) { 
                        return false;
                    }
            
                    if (t.type === 'income' && t.account === accountId) return true;
                    if (t.type === 'expense' && t.account === accountId) return true;
                    if (t.type === 'transfer') {
                        return t.sourceAccount === accountId || t.destAccount === accountId;
                    }
                    return false;
                }).sort((a,b) => this.parseDate(a.date) - this.parseDate(b.date)); 
            
                for (const t of transactionsToConsider) {
                    if (t.type === 'income' && t.account === accountId) {
                        realizedBalance += t.amount;
                    } else if (t.type === 'expense' && t.account === accountId) {
                        realizedBalance -= t.amount;
                    } else if (t.type === 'transfer') {
                        if (t.sourceAccount === accountId) {
                            realizedBalance -= t.amount;
                        }
                        if (t.destAccount === accountId) {
                            realizedBalance += t.amount;
                        }
                    }
                }
                return realizedBalance;
            }
			async saveToStorage(key, value) {
    try {
        // Verifica se IndexedDB está disponível através do dbManager
        if (window.indexedDB && this.dbManager && this.dbManager.isReady) {
            // Tenta salvar no IndexedDB primeiro
            await this.dbManager.saveData(key, value);
            
            // Também salva no localStorage para redundância e compatibilidade
            try {
                localStorage.setItem(key, JSON.stringify(value));
            } catch (lsError) {
                console.warn(`Não foi possível salvar ${key} no localStorage, mas foi salvo no IndexedDB`, lsError);
            }
        } else {
            // Fallback para localStorage se IndexedDB não estiver disponível
            localStorage.setItem(key, JSON.stringify(value));
            console.warn(`IndexedDB não disponível, usando localStorage para ${key}`);
        }
        
        // Se estamos salvando a configuração de usar saldo do mês anterior, vamos registrar isso
        if (key === 'finance_use_prev_month') {
            console.log(`Configuração 'finance_use_prev_month' salva com o valor: ${value}`);
        }
        
        return true;
    } catch (error) {
        console.error(`Erro ao salvar ${key}:`, error);
        try {
            // Tenta como último recurso salvar no localStorage
            localStorage.setItem(key, JSON.stringify(value));
            console.warn(`Fallback: ${key} salvo apenas no localStorage devido a erro no IndexedDB`);
            
            return true;
        } catch (lsError) {
            console.error(`Erro ao salvar ${key} no localStorage:`, lsError);
            if (this.notificationSystem) {
                this.notificationSystem.show('Erro de Armazenamento', 'Não foi possível salvar os dados. Verifique se o seu navegador suporta armazenamento local.', 'error');
            }
            return false;
        }
    }
}
async migrateOldDatabases() {
    try {
        console.log('Verificando bancos de dados antigos...');
        
        const oldDbNames = ['financasGoDB', 'FinancasGO', 'finançasGO'];
        
        for (const oldDbName of oldDbNames) {
            try {
                const request = indexedDB.open(oldDbName);
                
                await new Promise((resolve, reject) => {
                    request.onsuccess = async (event) => {
                        const oldDb = event.target.result;
                        
                        if (oldDb.objectStoreNames.contains('appData')) {
                            console.log(`Migrando dados de ${oldDbName}...`);
                            
                            const transaction = oldDb.transaction(['appData'], 'readonly');
                            const store = transaction.objectStore('appData');
                            const getAllRequest = store.getAll();
                            
                            getAllRequest.onsuccess = async () => {
                                const oldData = getAllRequest.result;
                                
                                for (const item of oldData) {
                                    // Verificar se item.key existe e não é undefined
                                    if (item && item.key && item.key !== undefined) {
                                        await this.dbManager.saveData(item.key, item.value);
                                    }
                                }
                                
                                console.log(`Migração de ${oldDbName} concluída!`);
                                oldDb.close();
                                
                                const deleteRequest = indexedDB.deleteDatabase(oldDbName);
                                deleteRequest.onsuccess = () => {
                                    console.log(`Banco antigo ${oldDbName} removido.`);
                                };
                            };
                        }
                        
                        oldDb.close();
                        resolve();
                    };
                    
                    request.onerror = () => resolve(); // Ignora erros (banco não existe)
                });
                
            } catch (error) {
                console.log(`Banco ${oldDbName} não encontrado ou erro ao migrar:`, error);
            }
        }
        
    } catch (error) {
        console.error('Erro durante migração:', error);
    }
}
            async loadFromStorage(key) {
    try {
        // Verifica se IndexedDB está disponível e inicializado
        if (window.indexedDB && this.dbManager && this.dbManager.isReady) {
            // Tenta carregar do IndexedDB primeiro
            const data = await this.dbManager.loadData(key);
            
            // Se o valor existir no IndexedDB, retorna-o
            if (data !== undefined) {
                // Verifica se existe um valor diferente no localStorage que precisa ser sincronizado
                try {
                    const lsItem = localStorage.getItem(key);
                    if (lsItem !== null) {
                        const parsedLsItem = JSON.parse(lsItem);
                        // Se os valores forem diferentes, atualiza o localStorage
                        if (JSON.stringify(data) !== JSON.stringify(parsedLsItem)) {
                            localStorage.setItem(key, JSON.stringify(data));
                            console.log(`LocalStorage sincronizado com IndexedDB para ${key}`);
                        }
                    }
                } catch (syncError) {
                    console.warn(`Não foi possível sincronizar ${key} ao localStorage`, syncError);
                }
                
                return data;
            }
            
            // Se não existir no IndexedDB, tenta buscar do localStorage
            const lsItem = localStorage.getItem(key);
            if (lsItem !== null) {
                const parsedItem = JSON.parse(lsItem);
                // Salva no IndexedDB para sincronizar
                await this.dbManager.saveData(key, parsedItem);
                console.log(`Migrado ${key} do localStorage para IndexedDB`);
                return parsedItem;
            }
            
            return null;
        } else {
            // Fallback para localStorage se IndexedDB não estiver disponível
            console.warn(`IndexedDB não disponível, usando localStorage para carregar ${key}`);
            const item = localStorage.getItem(key);
            return item ? JSON.parse(item) : null;
        }
    } catch (error) {
        console.error(`Erro ao carregar ${key} do IndexedDB:`, error);
        
        try {
            console.warn(`Tentando fallback para localStorage para ${key}`);
            const item = localStorage.getItem(key);
            return item ? JSON.parse(item) : null;
        } catch (lsError) {
            console.error(`Erro ao carregar ${key} do localStorage:`, lsError);
            return null;
        }
    }
}


loadFromStorageSync(key) {
    // Este método só pode carregar do localStorage de forma síncrona
    // IndexedDB é sempre assíncrono, então não podemos usá-lo aqui
    try {
        const item = localStorage.getItem(key);
        return item ? JSON.parse(item) : null;
    } catch (error) {
        console.error(`Erro ao carregar ${key} do localStorage de forma síncrona:`, error);
        return null;
    }
}


async migrateDataFromLocalStorage() {
    try {
        // Mostrar uma mensagem informando que a migração está em andamento
        this.notificationSystem.show(
            'Migração de Dados', 
            'Migrando seus dados para o novo sistema de armazenamento. Isso pode levar alguns instantes...', 
            'info',
            3000
        );
        
        const migratedData = await this.dbManager.migrateFromLocalStorage();
        console.log('Dados migrados com sucesso:', Object.keys(migratedData));
        
        if (Object.keys(migratedData).length > 0) {
            // Verificação adicional de dados migrados
            let migratedItemsCount = 0;
            for (const key in migratedData) {
                if (migratedData[key] !== null && migratedData[key] !== undefined) {
                    migratedItemsCount++;
                }
            }
            
            if (migratedItemsCount > 0) {
                this.notificationSystem.show(
                    'Dados Migrados', 
                    `${migratedItemsCount} itens foram migrados com sucesso para o novo sistema de banco de dados.`, 
                    'success',
                    5000
                );
            }
        }
        return true;
    } catch (error) {
        console.error('Erro durante a migração de dados:', error);
        this.notificationSystem.show(
            'Erro na Migração', 
            'Ocorreu um erro ao migrar seus dados. Alguns dados podem não estar disponíveis. A aplicação continuará usando localStorage como fallback.', 
            'error',
            10000
        );
        return false;
    }
}

setupBackupReminder() {
    const exibirNotificacao = () => {
        if (this.notificationSystem && typeof this.notificationSystem.show === 'function' && this.user && this.isFeatureAvailable('import_export')) { 
            this.notificationSystem.show(
                'Lembrete de backup',
                'Faça um backup dos seus dados para evitar perdas! (Configurações > Exportar)',
                'warning',
                15000 
            );
        }
    };
    
    setTimeout(exibirNotificacao, 30 * 1000); 
    setInterval(exibirNotificacao, 30 * 60 * 1000); 
}
            validateLicense(key) {
    // Verificar se é trial
    if (key === 'TRIAL') {
        if (this.licenseInfo && this.licenseInfo.activationDate) {
            const activationDate = new Date(this.licenseInfo.activationDate);
            const currentDate = new Date();
            const expirationDate = new Date(activationDate);
            expirationDate.setDate(expirationDate.getDate() + 7);
            
            if (currentDate > expirationDate) {
                this.licenseInfo.isTrialActive = false;
                this.saveToStorage('finance_license', this.licenseInfo);
                return false;
            }
            return true;
        }
        return false;
    }
    
    // Verificar chaves de licença normais
    let isValid = false;
    let licenseType = '';
    let licenseValidity = '';
    
    for (const type in this.licenseKeys) {
        for (const validity in this.licenseKeys[type]) {
            if (this.licenseKeys[type][validity] === key) {
                isValid = true;
                licenseType = type;
                licenseValidity = validity;
                break;
            }
        }
        if (isValid) break;
    }
    
    return isValid;
}

            isFeatureAvailable(feature) {
    const activePlan = this.PLAN_CONFIG;
    
    // Baseado EXATAMENTE na imagem dos planos
    switch(feature) {
        case 'cards':
            // Básico: Sem cartão | Essencial: 3 cartões | Completo: Ilimitado
            return activePlan === 'essencial' || activePlan === 'completo';
            
        case 'preview_mode':
            // Básico: ❌ | Essencial: ✅ | Completo: ✅
            return activePlan === 'essencial' || activePlan === 'completo';
            
        case 'transfers':
            // Básico: ❌ | Essencial: ❌ | Completo: ✅
            return activePlan === 'completo';
            
        case 'auto_installments':
            // Básico: ❌ | Essencial: ✅ | Completo: ✅
            return activePlan === 'essencial' || activePlan === 'completo';
            
        case 'dashboard_advanced':
            // Básico: ❌ | Essencial: ✅ | Completo: ✅
            return activePlan === 'essencial' || activePlan === 'completo';
            
        case 'simulator':
            // Básico: ❌ | Essencial: ❌ | Completo: ✅
            return activePlan === 'completo';
            
        case 'import_export':
            // Não está na imagem, então disponível para todos
            return true;
            
        default:
            // Funcionalidades não listadas estão disponíveis para todos
            return true;
    }
}
checkTrialStatus() {
    if (this.licenseInfo && this.licenseInfo.type === 'trial') {
        if (!this.validateLicense('TRIAL')) {
            // Período inicial finalizado, solicitar chave vitalícia
            this.showTrialExpiredModal();
            return false;
        }
    }
    return true;
}

showTrialExpiredModal() {
    const modalContentEl = document.getElementById('modalContent');
    if (!modalContentEl) {
        const modalHTML = `<div class="modal-overlay" id="modalOverlay"><div class="modal" id="modalContent"></div></div>`;
        document.body.insertAdjacentHTML('beforeend', modalHTML);
    }
    
    const modalContent = document.getElementById('modalContent');
    modalContent.innerHTML = `
        <div class="modal-header">
            <h3 class="modal-title">Acesso Liberado</h3>
        </div>
        <div class="modal-body">
            <div style="text-align: center; margin-bottom: 20px;">
                <i class="fas fa-key" style="font-size: 3rem; color: var(--primary-color); margin-bottom: 15px;"></i>
                <h3 style="margin-bottom: 10px;">Período de acesso inicial finalizado</h3>
                <p>Insira sua chave vitalícia que foi enviada para a área de membros.</p>
            </div>
            <div class="form-row">
                <label class="form-label" for="trialExpiredKey">Chave Vitalícia</label>
                <input class="form-input" type="text" id="trialExpiredKey" placeholder="xxxx-xxxx-xxxx-xxxx">
            </div>
        </div>
        <div class="form-footer">
            <button class="btn btn-primary" id="activateKeyBtn">Ativar Chave</button>
        </div>
    `;
    
    document.getElementById('modalOverlay').classList.add('active');
    
    document.getElementById('activateKeyBtn').addEventListener('click', async () => {
        const licenseKey = document.getElementById('trialExpiredKey').value;
        
        if (!licenseKey) {
            this.notificationSystem.show('Erro', 'Insira uma chave de acesso!', 'error');
            return;
        }
        
        // Validar chave
        let tempLicenseType = '', tempLicenseValidity = '', licenseFound = false;
        for (const type in this.licenseKeys) {
            for (const validity in this.licenseKeys[type]) {
                if (this.licenseKeys[type][validity] === licenseKey) {
                    tempLicenseType = type;
                    tempLicenseValidity = validity;
                    licenseFound = true;
                    break;
                }
            }
            if (licenseFound) break;
        }
        
        if (!licenseFound) {
            this.notificationSystem.show('Erro', 'Chave de licença inválida!', 'error');
            return;
        }
        
        // Atualizar licença
        this.licenseInfo = {
            key: licenseKey,
            type: tempLicenseType,
            validity: tempLicenseValidity,
            activationDate: new Date().toISOString(),
            isTrialActive: false
        };
        
        await this.saveToStorage('finance_license', this.licenseInfo);
        
        // Limpar dados de trial para evitar conflitos
        await this.saveToStorage('finance_trial_control', null);
        await this.saveToStorage('finance_install_id', null);
        await this.saveToStorage('finance_trial_start', null);
        
        this.closeModal();
        this.notificationSystem.show('Sucesso', 'Chave ativada com sucesso!', 'success');
        setTimeout(() => {
            this.init();
        }, 1000);
    });
}
            renderMainApp() {
                // Calcular dias restantes do trial se aplicável
                let trialInfo = '';
                if (this.licenseInfo && this.licenseInfo.type === 'trial' && this.licenseInfo.isTrialActive) {
                    const activationDate = new Date(this.licenseInfo.activationDate);
                    const currentDate = new Date();
                    const expirationDate = new Date(activationDate);
                    expirationDate.setDate(expirationDate.getDate() + 7);
                    const daysLeft = Math.max(0, Math.ceil((expirationDate - currentDate) / (1000 * 60 * 60 * 24)));
                    trialInfo = ''; // Removido o banner do topo
                }
                
                this.app.innerHTML = `
                    <div class="app-container">
                        <aside class="sidebar" id="sidebar">
                            <div class="sidebar-header"> <div class="sidebar-title"><i class="fas fa-wallet logo-icon"></i><span>FinancePlay</span></div> <button class="menu-toggle" id="menuToggleClose"><i class="fas fa-times"></i></button> </div>
                            <ul class="nav-menu">
                                <li class="nav-item"><a href="#" class="nav-link" data-page="dashboard"><i class="fas fa-chart-line nav-icon"></i><span>Dashboard</span></a></li>
                                <li class="nav-item"><a href="#" class="nav-link" data-page="transactions"><i class="fas fa-exchange-alt nav-icon"></i><span>Transações</span></a></li>
                                <li class="nav-item"><a href="#" class="nav-link" data-page="categories"><i class="fas fa-tags nav-icon"></i><span>Categorias</span></a></li>
                                <li class="nav-item"><a href="#" class="nav-link" data-page="accounts"><i class="fas fa-university nav-icon"></i><span>Contas</span></a></li>
                                <li class="nav-item"><a href="#" class="nav-link" data-page="cards"><i class="fas fa-credit-card nav-icon"></i><span>Cartões</span></a></li>
                                <li class="nav-item"><a href="#" class="nav-link" data-page="simulator"><i class="fas fa-calculator nav-icon"></i><span>Simulador</span></a></li>
                                <li class="nav-item"><a href="#" class="nav-link" data-page="settings"><i class="fas fa-cog nav-icon"></i><span>Configurações</span></a></li>
                            </ul>
                        </aside>
                        <main class="main-content sidebar-active-overlay" id="mainContent">
                            <div class="header"> <button class="menu-toggle" id="sidebarToggleOpen"><i class="fas fa-bars"></i></button> <h1 class="page-title" id="pageTitle">Dashboard</h1>
                                <div class="header-actions">
                                    ${trialInfo}
                                    <div class="user-profile" id="userProfile">
                                        <div class="profile-button" id="profileButton"> <div class="profile-avatar">${this.user && this.user.emoji ? this.user.emoji : '👤'}</div> <div class="profile-info"><div class="profile-name">${this.user && this.user.name ? this.user.name : 'Usuário'}</div><div class="profile-email">${this.user && this.user.email ? this.user.email : ''}</div></div> <i class="fas fa-chevron-down" style="font-size: 0.8rem; color: var(--text-light);"></i> </div>
                                        <div class="profile-dropdown" id="profileDropdown"> <ul class="dropdown-list"> <li class="dropdown-item" data-action="profile"><i class="fas fa-user"></i><span>Meu Perfil</span></li> <li class="dropdown-item" data-action="settings"><i class="fas fa-cog"></i><span>Configurações</span></li> </ul> </div>
                                    </div>
                                </div>
                            </div>
                            <div id="pageContent"></div>
                        </main>
                    </div>
                    <div class="modal-overlay" id="modalOverlay"><div class="modal" id="modalContent"></div></div>
                    <div id="notificationContainer"></div>
                `;
                this.setupEventListeners();
                createFilterModal();
            }

            setupEventListeners() {
                const navLinks = document.querySelectorAll('.nav-link'); 
                navLinks.forEach(link => { 
                    link.addEventListener('click', (e) => { 
                        e.preventDefault(); 
                        const page = link.getAttribute('data-page'); 
                        this.navigate(page); 
                        if (window.innerWidth < 992) { 
                            const sidebar = document.getElementById('sidebar'); 
                            const mainContent = document.getElementById('mainContent'); 
                            sidebar.classList.remove('active'); 
                            mainContent.classList.remove('sidebar-open'); 
                        } 
                    }); 
                });

                const sidebarToggleOpen = document.getElementById('sidebarToggleOpen'); 
                const sidebarToggleClose = document.getElementById('menuToggleClose'); 
                const sidebar = document.getElementById('sidebar'); 
                const mainContent = document.getElementById('mainContent');

                if (sidebarToggleOpen && sidebar && mainContent) { 
                    sidebarToggleOpen.addEventListener('click', () => { 
                        sidebar.classList.add('active'); 
                        mainContent.classList.add('sidebar-open'); 
                    }); 
                }
                if (sidebarToggleClose && sidebar && mainContent) { 
                    sidebarToggleClose.addEventListener('click', () => { 
                        sidebar.classList.remove('active'); 
                        mainContent.classList.remove('sidebar-open'); 
                    }); 
                }
                
                if (mainContent && sidebar) { 
                    mainContent.addEventListener('click', (e) => { 
                        if (sidebar.classList.contains('active') && e.target === mainContent && window.getComputedStyle(mainContent, '::before').opacity === '1') {
                             sidebar.classList.remove('active'); 
                             mainContent.classList.remove('sidebar-open'); 
                        } else if (sidebar.classList.contains('active') && !sidebar.contains(e.target) && e.target !== sidebarToggleOpen && !sidebarToggleOpen.contains(e.target)) {
                            if (window.innerWidth < 992) { 
                                sidebar.classList.remove('active');
                                mainContent.classList.remove('sidebar-open');
                            }
                        }
                    }); 
                }

                const profileButton = document.getElementById('profileButton'); 
                const profileDropdown = document.getElementById('profileDropdown'); 
                if (profileButton && profileDropdown) { 
                    profileButton.addEventListener('click', (e) => { 
                        e.stopPropagation(); 
                        profileDropdown.classList.toggle('active'); 
                    }); 
                }
                document.addEventListener('click', (e) => { 
                    if (profileDropdown && profileButton && !profileButton.contains(e.target) && !profileDropdown.contains(e.target) && profileDropdown.classList.contains('active')) { 
                        profileDropdown.classList.remove('active'); 
                    } 
                });

                const dropdownItems = document.querySelectorAll('.dropdown-item[data-action]'); 
                dropdownItems.forEach(item => { 
                    item.addEventListener('click', () => { 
                        const action = item.getAttribute('data-action'); 
                        if (action === 'profile' || action === 'settings') { 
                            this.navigate('settings'); 
                        } 
                        if (profileDropdown) { 
                            profileDropdown.classList.remove('active'); 
                        } 
                    }); 
                });

                const modalOverlay = document.getElementById('modalOverlay'); 
                if (modalOverlay) { 
                    modalOverlay.addEventListener('click', (e) => { 
                        if (e.target === modalOverlay) { 
                            this.closeModal(); 
                        } 
                    }); 
                }

                this.setupFilterToggles();
            }

            setupFilterToggles() {
                const filterToggle = document.getElementById('filterToggleTransactions');
                
                if (filterToggle) {
                    filterToggle.addEventListener('click', () => {
                        this.openFilterModal();
                    });
                }
            }

            openFilterModal() {
                const modal = document.getElementById('filterModal');
                if (modal) {
                    this.populateFilterModal();
                    modal.classList.add('active');
                }
            }

            closeFilterModal() {
                const modal = document.getElementById('filterModal');
                if (modal) {
                    modal.classList.remove('active');
                }
            }

            populateFilters() {
                this.populateFilterModal();
            }

            populateFilterModal() {
                const categoryFilter = document.getElementById('categoryFilterModal');
                if (categoryFilter) {
                    categoryFilter.innerHTML = '<option value="all">Todas</option>';
                    this.data.categories.income.forEach(category => {
                        categoryFilter.innerHTML += `<option value="${category.id}">${category.name}</option>`;
                    });
                    this.data.categories.expense.forEach(category => {
                        categoryFilter.innerHTML += `<option value="${category.id}">${category.name}</option>`;
                    });
                }

                const accountFilter = document.getElementById('accountFilterModal');
                if (accountFilter) {
                    accountFilter.innerHTML = '<option value="all">Todas</option>';
                    this.data.accounts.forEach(account => {
                        accountFilter.innerHTML += `<option value="${account.id}">${account.name}</option>`;
                    });
                }

                const typeFilter = document.getElementById('transactionTypeFilterModal');
                const categoryFilterEl = document.getElementById('categoryFilterModal');
                const accountFilterEl = document.getElementById('accountFilterModal');
                const periodTypeFilter = document.getElementById('periodTypeFilterModal');
                const startDateFilter = document.getElementById('startDateFilterModal');
                const endDateFilter = document.getElementById('endDateFilterModal');
                const sortOrderFilter = document.getElementById('sortOrderFilterModal');

                if (this.transactionFilters) {
                    if (typeFilter) typeFilter.value = this.transactionFilters.type || 'all';
                    if (categoryFilterEl) categoryFilterEl.value = this.transactionFilters.category || 'all';
                    if (accountFilterEl) accountFilterEl.value = this.transactionFilters.account || 'all';
                }

                if (sortOrderFilter) sortOrderFilter.value = this.transactionsSortOrder || 'asc';

                if (periodTypeFilter) {
                    periodTypeFilter.value = this.customDateFilterEnabled ? 'custom' : 'monthly';
                    this.toggleCustomDateFields();
                }

                if (startDateFilter) startDateFilter.value = this.customDateStart || '';
                if (endDateFilter) endDateFilter.value = this.customDateEnd || '';

                this.setupFilterActions();
            }

            toggleCustomDateFields() {
                const periodType = document.getElementById('periodTypeFilterModal')?.value;
                const customFields = document.getElementById('customDateFieldsModal');
                
                if (customFields) {
                    customFields.style.display = periodType === 'custom' ? 'block' : 'none';
                }
            }

            setupFilterActions() {
                const applyBtn = document.getElementById('applyFiltersModal');
                const clearBtn = document.getElementById('clearFiltersModal');
                const closeBtn = document.getElementById('closeFilterModal');
                const periodTypeFilter = document.getElementById('periodTypeFilterModal');
                
                if (applyBtn) {
                    applyBtn.addEventListener('click', () => {
                        this.applyTransactionFilters();
                    });
                }
                
                if (clearBtn) {
                    clearBtn.addEventListener('click', () => {
                        this.clearTransactionFilters();
                    });
                }

                if (closeBtn) {
                    closeBtn.addEventListener('click', () => {
                        this.closeFilterModal();
                    });
                }

                if (periodTypeFilter) {
                    periodTypeFilter.addEventListener('change', () => {
                        this.toggleCustomDateFields();
                    });
                }

                const modal = document.getElementById('filterModal');
                if (modal) {
                    modal.addEventListener('click', (e) => {
                        if (e.target === modal) {
                            this.closeFilterModal();
                        }
                    });
                }
            }

            applyTransactionFilters() {
                const typeFilter = document.getElementById('transactionTypeFilterModal')?.value || 'all';
                const categoryFilter = document.getElementById('categoryFilterModal')?.value || 'all';
                const accountFilter = document.getElementById('accountFilterModal')?.value || 'all';
                const periodType = document.getElementById('periodTypeFilterModal')?.value || 'monthly';
                const startDate = document.getElementById('startDateFilterModal')?.value || '';
                const endDate = document.getElementById('endDateFilterModal')?.value || '';
                const sortOrder = document.getElementById('sortOrderFilterModal')?.value || 'asc';
                
                this.transactionFilters = { type: typeFilter, category: categoryFilter, account: accountFilter };
                this.transactionsSortOrder = sortOrder;
                this.saveToStorage('finance_sort_order', this.transactionsSortOrder);
                
                if (periodType === 'custom' && startDate && endDate) {
                    this.customDateFilterEnabled = true;
                    this.customDateStart = startDate;
                    this.customDateEnd = endDate;
                } else {
                    this.customDateFilterEnabled = false;
                    this.customDateStart = null;
                    this.customDateEnd = null;
                }

                this.selectedFilterAccount = accountFilter;
                this.closeFilterModal();
                this.navigate('transactions');
                this.showNotification('Filtros aplicados com sucesso!', 'success');
            }

            clearTransactionFilters() {
                document.getElementById('transactionTypeFilterModal').value = 'all';
                document.getElementById('categoryFilterModal').value = 'all';
                document.getElementById('accountFilterModal').value = 'all';
                document.getElementById('periodTypeFilterModal').value = 'monthly';
                document.getElementById('startDateFilterModal').value = '';
                document.getElementById('endDateFilterModal').value = '';
                document.getElementById('sortOrderFilterModal').value = 'asc';
                
                this.transactionFilters = { type: 'all', category: 'all', account: 'all' };
                this.transactionsSortOrder = 'asc';
                this.saveToStorage('finance_sort_order', this.transactionsSortOrder);
                this.customDateFilterEnabled = false;
                this.customDateStart = null;
                this.customDateEnd = null;
                this.selectedFilterAccount = 'all';
                
                this.toggleCustomDateFields();
                this.closeFilterModal();
                this.navigate('transactions');
                this.showNotification('Filtros limpos!', 'info');
            }

            showNotification(message, type = 'info') {
                if (this.notificationSystem) {
                    const title = type === 'success' ? 'Sucesso' : 
                                  type === 'error' ? 'Erro' : 
                                  type === 'warning' ? 'Aviso' : 'Informação';
                    this.notificationSystem.show(title, message, type);
                }
            }

            navigate(page) {
                // Verificar se a página requer acesso específico
                if (page === 'cards' && !this.isFeatureAvailable('cards')) {
                    this.showUpgradeModal('cards');
                    return;
                }
                
                if (page === 'simulator' && !this.isFeatureAvailable('simulator')) {
                    this.showUpgradeModal('simulator');
                    return;
                }

                const navLinks = document.querySelectorAll('.nav-link'); 
                navLinks.forEach(link => { 
                    link.classList.toggle('active', link.getAttribute('data-page') === page); 
                });

                const pageTitle = document.getElementById('pageTitle'); 
                if (pageTitle) { 
                    pageTitle.textContent = this.getPageTitle(page); 
                }
                this.currentView = page;
                const pageContent = document.getElementById('pageContent');
                if (pageContent) {
                    pageContent.innerHTML = ''; 
                    switch (page) {
                        case 'dashboard': this.renderDashboard(pageContent); break;
                        case 'transactions': this.renderTransactions(pageContent); break;
                        case 'categories': this.renderCategories(pageContent); break;
                        case 'accounts': this.renderAccounts(pageContent); break;
                        case 'cards': 
                            this.renderCards(pageContent); 
                            break;
                        case 'settings': this.renderSettings(pageContent); break;
                        case 'simulator': 
                            this.renderSimulator(pageContent); 
                            break;
                        default: pageContent.innerHTML = '<div class="card no-data"><i class="fas fa-exclamation-triangle"></i><p>Página não encontrada.</p></div>';
                    }
                    
                    setTimeout(() => {
                        this.setupFilterToggles();
                        this.populateFilters();
                        this.setupGoalCard();
                    }, 100);
                }
                
                const sidebar = document.getElementById('sidebar'); 
                const mainContent = document.getElementById('mainContent'); 
                if (sidebar && window.innerWidth < 992 && sidebar.classList.contains('active')) { 
                    sidebar.classList.remove('active'); 
                    if (mainContent) { 
                        mainContent.classList.remove('sidebar-open'); 
                    } 
                }
            }
            
            getPageTitle(page) {
                switch (page) {
                    case 'dashboard': return 'Dashboard'; 
                    case 'transactions': return 'Transações'; 
                    case 'categories': return 'Categorias'; 
                    case 'accounts': return 'Contas'; 
                    case 'cards': return 'Cartões'; 
                    case 'settings': return 'Configurações'; 
                    case 'simulator': return 'Simulador Financeiro'; 
                    default: return 'FinancePlay';
                }
            }
// Verificar limites do plano atual
getPlanLimits() {
    const activePlan = this.PLAN_CONFIG;
    
    // Baseado EXATAMENTE na imagem dos planos
    if (activePlan === 'basico') {
        return { accounts: 1, cards: 0, categories: 2 };
    } else if (activePlan === 'essencial') {
        return { accounts: 3, cards: 3, categories: 10 };
    } else if (activePlan === 'completo') {
        return { accounts: -1, cards: -1, categories: -1 }; // -1 = ilimitado
    }
    
    return { accounts: 0, cards: 0, categories: 0 };
}

checkPlanLimits(type, currentCount) {
    const limits = this.getPlanLimits();
    
    if (type === 'accounts') {
        return limits.accounts === -1 || currentCount < limits.accounts;
    } else if (type === 'cards') {
        return limits.cards === -1 || currentCount < limits.cards;
    } else if (type === 'categories') {
        return limits.categories === -1 || currentCount < limits.categories;
    }
    
    return false;
}
            
            async setupGoalCard() {
                try {
                    const targetInput = document.getElementById('goalTargetInput');
                    const saveBtn = document.getElementById('saveGoalBtn');
                    const goalTargetEl = document.getElementById('goalTarget');
                    const goalCurrentEl = document.getElementById('goalCurrent');
                    const goalFill = document.getElementById('goalProgressFill');
                    if (!targetInput || !saveBtn || !goalTargetEl || !goalCurrentEl || !goalFill) return;

                    // Load target (default 15000)
                    const savedTarget = await this.loadFromStorage('finance_goal_target');
                    const target = (savedTarget === null || savedTarget === undefined || isNaN(savedTarget)) ? 15000 : Number(savedTarget);
                    targetInput.value = target;

                    // Current = saldo realizado da conta "Investimentos" (se existir)
                    const investAcc = this.data.accounts.find(a => (a.name || '').toLowerCase().includes('invest'));
                    let current = 0;
                    if (investAcc) {
                        current = this.calculateAccountRealizedBalance(investAcc.id);
                    }

                    goalTargetEl.textContent = `R$ ${this.formatCurrency(target)}`;
                    goalCurrentEl.textContent = `R$ ${this.formatCurrency(current)}`;

                    const pct = target > 0 ? Math.min((current / target) * 100, 100) : 0;
                    goalFill.style.width = `${pct}%`;
                    goalFill.textContent = `${Math.round(pct)}%`;
                    goalFill.style.display = 'flex';
                    goalFill.style.alignItems = 'center';
                    goalFill.style.justifyContent = 'center';
                    goalFill.style.fontSize = '10px';
                    goalFill.style.color = '#0f1115';

                    // color by level
                    if (pct < 60) goalFill.style.backgroundColor = 'var(--secondary-color)';
                    else if (pct < 85) goalFill.style.backgroundColor = 'var(--warning-color)';
                    else goalFill.style.backgroundColor = 'var(--danger-color)';

                    saveBtn.onclick = async () => {
                        const v = Number(targetInput.value || 0);
                        if (v <= 0) { alert('Informe um valor de meta maior que zero.'); return; }
                        await this.saveToStorage('finance_goal_target', v);
                        goalTargetEl.textContent = `R$ ${this.formatCurrency(v)}`;
                        const pct2 = Math.min((current / v) * 100, 100);
                        goalFill.style.width = `${pct2}%`;
                        goalFill.textContent = `${Math.round(pct2)}%`;
                    };
                } catch (e) {
                    console.error('setupGoalCard error', e);
                }
            }

            renderDashboard(container) {
                const filterAccountId = this.hasActiveTransactionFilters() ? this.getEffectiveAccountFilter() : this.selectedFilterAccount;
                const monthData = this.customDateFilterEnabled ? 
                    this.getCustomPeriodData(this.customDateStart, this.customDateEnd, filterAccountId) :
                    this.getMonthData(this.currentMonth, this.currentYear, filterAccountId); 
                let upgradeBanner = '';    
                
                // Mostrar informações sobre filtros ativos
                let filterInfo = '';
                if (this.hasActiveTransactionFilters()) {
                    const activeFilters = [];
                    if (this.transactionFilters.type !== 'all') {
                        const typeNames = { income: 'Receitas', expense: 'Despesas', card: 'Cartão', transfer: 'Transferências' };
                        activeFilters.push(`Tipo: ${typeNames[this.transactionFilters.type] || this.transactionFilters.type}`);
                    }
                    if (this.transactionFilters.category !== 'all') {
                        const category = [...this.data.categories.income, ...this.data.categories.expense]
                            .find(c => c.id === this.transactionFilters.category);
                        activeFilters.push(`Categoria: ${category ? category.name : 'Desconhecida'}`);
                    }
                    if (this.transactionFilters.account !== 'all') {
                        const account = this.data.accounts.find(a => a.id === this.transactionFilters.account);
                        activeFilters.push(`Conta: ${account ? account.name : 'Desconhecida'}`);
                    }
                    
                    if (activeFilters.length > 0) {
                        filterInfo = `
                            <div style="background-color: rgba(99, 102, 241, 0.1); border: 1px solid var(--primary-color); border-radius: var(--border-radius); padding: 12px; margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <i class="fas fa-filter" style="color: var(--primary-color);"></i>
                                    <span style="font-weight: 500;">Filtros ativos:</span>
                                    <span style="color: var(--text-light);">${activeFilters.join(' • ')}</span>
                                </div>
                                <button class="btn btn-sm btn-outlined" id="clearAllFiltersDashboard">
                                    <i class="fas fa-times"></i> Limpar Filtros
                                </button>
                            </div>
                        `;
                    }
                }             
                    
                const periodDisplay = this.customDateFilterEnabled ? 
                    `${this.formatDate(this.parseDate(this.customDateStart))} - ${this.formatDate(this.parseDate(this.customDateEnd))}` :
                    `${this.getMonthName(this.currentMonth)} de ${this.currentYear}`;

                container.innerHTML = `
                    ${upgradeBanner}
                    ${filterInfo}
                    <div class="header-actions" style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; margin-bottom: 20px;">
                        ${this.customDateFilterEnabled ? 
                            `<div style="display: flex; align-items: center; gap: 10px; font-weight: 500;">
                                <span>Período: ${periodDisplay}</span>
                                <button class="btn btn-sm btn-outlined" id="clearCustomFilterDashboard"><i class="fas fa-times"></i> Limpar Filtro</button>
                            </div>` :
                            `<div class="month-navigation">
                                <button class="month-nav-btn" id="prevMonthBtnDashboard"><i class="fas fa-chevron-left"></i></button>
                                <span class="current-month" id="currentMonthDisplayDashboard">${this.getMonthName(this.currentMonth)} de ${this.currentYear}</span>
                                <button class="month-nav-btn" id="nextMonthBtnDashboard"><i class="fas fa-chevron-right"></i></button>
                            </div>`
                        }
                        <div style="display: flex; align-items: center; gap: 10px;" class="toggle-switch-container">
                            <label class="toggle-switch">
                                <input type="checkbox" id="previewToggleDashboard" ${this.isPreviewMode ? 'checked' : ''}>
                                <span class="toggle-slider"></span>
                            </label>
                            <span class="toggle-label">Modo Previsto</span>
                        </div>
                    </div>
                    <div class="grid-container"> 
                        <div class="card stat-card"><div class="stat-title">Saldo Inicial ${this.customDateFilterEnabled ? 'Período' : 'Mês'}</div><div class="stat-value ${monthData.dashboardInitialBalance >= 0 ? 'stat-positive' : 'stat-negative'}" id="dashboardInitialBalance">R$ ${this.formatCurrency(monthData.dashboardInitialBalance)}</div></div> 
                        <div class="card stat-card"><div class="stat-title">Receitas ${this.customDateFilterEnabled ? 'Período' : 'Mês'}</div><div class="stat-value stat-positive" id="dashboardIncome">R$ ${this.formatCurrency(monthData.dashboardIncome)}</div></div> 
                        <div class="card stat-card"><div class="stat-title">Despesas ${this.customDateFilterEnabled ? 'Período' : 'Mês'}</div><div class="stat-value stat-negative" id="dashboardExpense">R$ ${this.formatCurrency(monthData.dashboardExpense)}</div></div> 
                        <div class="card stat-card"><div class="stat-title">Saldo Final ${this.customDateFilterEnabled ? 'Período' : 'Mês'}</div><div class="stat-value ${monthData.dashboardFinalBalance >= 0 ? 'stat-positive' : 'stat-negative'}" id="dashboardFinalBalance">R$ ${this.formatCurrency(monthData.dashboardFinalBalance)}</div></div> 
                        <div class="card stat-card" id="goalStatCard">
                          <div class="stat-title">Meta</div>
                          <div class="stat-value" style="font-size:1.1rem;">
                            <span id="goalCurrent">R$ 0,00</span>
                            <span style="color:var(--text-light);font-size:0.9rem;"> / </span>
                            <span id="goalTarget">R$ 0,00</span>
                          </div>
                          <div class="progress-bar" style="margin-top:8px;height:10px;">
                            <div class="progress-fill" id="goalProgressFill" style="width:0%;"></div>
                          </div>
                          <div style="display:flex;gap:8px;margin-top:10px;align-items:center;">
                            <input type="number" id="goalTargetInput" placeholder="Definir meta (R$)" style="flex:1;min-width:120px;">
                            <button class="btn btn-primary" id="saveGoalBtn" style="white-space:nowrap;">Salvar</button>
                          </div>
                        </div>
                    </div>
                    </div>
                    ${this.isFeatureAvailable('dashboard_advanced') ? `<div class="card"><div class="card-header"><h3 class="card-title">Receitas x Despesas ${this.customDateFilterEnabled ? '(Período Filtrado)' : '(Últimos 6 meses)'}</h3></div><div class="chart-container"><canvas id="incomeExpenseChart"></canvas></div></div><div class="card"><div class="card-header"><h3 class="card-title">Receitas x Despesas ${this.customDateFilterEnabled ? '(Período Filtrado)' : '(Próximos 6 meses)'}</h3></div><div class="chart-container"><canvas id="futureIncomeExpenseChart"></canvas></div></div><div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;"><div class="card"><div class="card-header"><h3 class="card-title">Despesas por Categoria (${this.customDateFilterEnabled ? 'Período Atual' : 'Mês Atual'})</h3></div><div class="chart-container"><canvas id="categoryChart"></canvas></div></div><div class="card"><div class="card-header"><h3 class="card-title">Receitas por Categoria (${this.customDateFilterEnabled ? 'Período Atual' : 'Mês Atual'})</h3></div><div class="chart-container"><canvas id="incomeCategoryChart"></canvas></div></div><div class="card"><div class="card-header"><h3 class="card-title">Limites de Categorias (${this.customDateFilterEnabled ? 'Período Atual' : 'Mês Atual'})</h3></div><div id="categoryProgressDashboard">${this.renderCategoryProgress(monthData.categories)}</div></div></div>` : ''}
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-top: 20px;"> <div class="card"><div class="card-header"><h3 class="card-title">Contas (Saldo Final ${this.customDateFilterEnabled ? 'Período' : 'Mês'})</h3></div><div id="accountsListDashboard">${this.renderAccountsListDashboard(monthData.accounts)}</div></div> ${this.isFeatureAvailable('cards') ? `<div class="card"><div class="card-header"><h3 class="card-title">Cartões (Faturas do ${this.customDateFilterEnabled ? 'Período Atual' : 'Mês Atual'})</h3></div><div id="cardsListDashboard">${this.renderCardsListDashboard(monthData.cards)}</div></div>` : ''} </div>
                `;
                
                const previewToggle = document.getElementById('previewToggleDashboard'); 
                if (previewToggle) { 
                    previewToggle.addEventListener('change', () => { 
                        if (!this.isFeatureAvailable('preview_mode')) {
                            previewToggle.checked = false;
                            this.showUpgradeModal('preview_mode');
                            return;
                        }
                        this.isPreviewMode = previewToggle.checked; 
                        this.refreshView(); 
                    }); 
                }

                // Navigation buttons (apenas quando não há filtro customizado)
                if (!this.customDateFilterEnabled) {
                    const prevMonthBtn = document.getElementById('prevMonthBtnDashboard'); 
                    const nextMonthBtn = document.getElementById('nextMonthBtnDashboard'); 
                    const currentMonthDisplay = document.getElementById('currentMonthDisplayDashboard');
                    if (prevMonthBtn) prevMonthBtn.addEventListener('click', () => this.navigateMonth(-1)); 
                    if (nextMonthBtn) nextMonthBtn.addEventListener('click', () => this.navigateMonth(1)); 
                    if (currentMonthDisplay) { 
                        currentMonthDisplay.addEventListener('click', () => { 
                            const today = new Date(); 
                            this.currentMonth = today.getMonth(); 
                            this.currentYear = today.getFullYear(); 
                            this.refreshView(); 
                        }); 
                    }
                } else {
                    // Event listener para limpar filtro personalizado
                    const clearCustomFilter = document.getElementById('clearCustomFilterDashboard');
                    if (clearCustomFilter) {
                        clearCustomFilter.addEventListener('click', () => {
                            this.customDateFilterEnabled = false;
                            this.customDateStart = null;
                            this.customDateEnd = null;
                            this.refreshView();
                        });
                    }
                }
                
                // Event listener para limpar todos os filtros
                const clearAllFilters = document.getElementById('clearAllFiltersDashboard');
                if (clearAllFilters) {
                    clearAllFilters.addEventListener('click', () => {
                        this.transactionFilters = { type: 'all', category: 'all', account: 'all' };
                        this.transactionsSortOrder = 'asc';
                        this.customDateFilterEnabled = false;
                        this.customDateStart = null;
                        this.customDateEnd = null;
                        this.selectedFilterAccount = 'all';
                        this.refreshView();
                        this.showNotification('Todos os filtros foram limpos!', 'info');
                    });
                }
                
                if (this.isFeatureAvailable('dashboard_advanced')) { 
                    this.renderIncomeExpenseChart(); 
                    this.renderFutureIncomeExpenseChart();
                    this.renderCategoryChart(monthData); 
                    this.renderIncomeCategoryChart(monthData);
                }
            }

            renderCategoryProgress(categoriesData) {
                if (!categoriesData || categoriesData.length === 0) { 
                    return '<div class="no-data"><i class="fas fa-chart-bar"></i><p>Nenhuma categoria encontrada.</p></div>'; 
                }
                let html = '';
                const expenseCategoriesWithLimits = categoriesData.filter(catData => {
                    const originalCategory = this.data.categories.expense.find(c => c.id === catData.id);
                    return originalCategory && originalCategory.limit && originalCategory.limit > 0;
                });

                if (expenseCategoriesWithLimits.length === 0) {
                    return '<div class="no-data"><i class="fas fa-chart-bar"></i><p>Nenhuma categoria de despesa com limite definido.</p></div>';
                }

                expenseCategoriesWithLimits.forEach(category => { 
                    const originalCategory = this.data.categories.expense.find(c => c.id === category.id); 
                    const percentage = Math.min(100, Math.round((category.total / originalCategory.limit) * 100)); 
                    const colorClass = percentage < 70 ? 'var(--secondary-color)' : percentage < 90 ? 'var(--warning-color)' : 'var(--danger-color)'; 
                    html += `<div class="progress-container"><div class="progress-header"><div class="progress-title"><div class="progress-icon" style="background-color: ${category.color}20; color: ${category.color}">${category.emoji}</div><span>${category.name}</span></div><div class="progress-values">R$ ${this.formatCurrency(category.total)} / R$ ${this.formatCurrency(originalCategory.limit)}</div></div><div class="progress-bar clickable" onclick="window.app && window.app.openCategoryDrilldown && window.app.openCategoryDrilldown('${category.id}', 'expense')"><div class="progress-fill" style="width: ${percentage}%; background-color: ${colorClass}"><span class="progress-percent">${Math.round(percentage)}%</span></div></div></div>`; 
                });
                return html;
            }

            renderAccountsListDashboard(accountsData) {
                if (!accountsData || accountsData.length === 0) { 
                    return '<div class="no-data"><i class="fas fa-university"></i><p>Nenhuma conta cadastrada.</p></div>'; 
                }
                let html = ''; 
                accountsData.forEach(account => { 
                    html += `<div class="transaction-item"><div class="transaction-info"><div class="transaction-icon" style="background-color: ${account.color}20; color: ${account.color}">${account.emoji}</div><div class="transaction-details"><div class="transaction-name">${account.name}</div></div></div><div class="transaction-amount ${account.finalBalance >= 0 ? 'income-amount' : 'expense-amount'}">R$ ${this.formatCurrency(account.finalBalance)}</div></div>`; 
                }); 
                return html;
            }

            renderCardsListDashboard(cardsData) {
                if (!this.isFeatureAvailable('cards')) {
                    return '<div class="no-data"><i class="fas fa-credit-card"></i><p>Recurso indisponível no plano atual.</p></div>';
                }
                if (!cardsData || cardsData.length === 0) { 
                    return '<div class="no-data"><i class="fas fa-credit-card"></i><p>Nenhum cartão cadastrado.</p></div>'; 
                }
                
                let html = '';
                
                if (this.customDateFilterEnabled) {
                    const invoicesInPeriod = this.getCardInvoicesInCustomPeriod();
                    if (invoicesInPeriod.length === 0) {
                        return '<div class="no-data"><i class="fas fa-credit-card"></i><p>Nenhuma fatura no período selecionado.</p></div>';
                    }
                    
                    invoicesInPeriod.forEach(invoice => {
                        const card = this.data.cards.find(c => c.id === invoice.cardId);
                        if (!card) return;
                        
                        const isPaid = this.isCardInvoicePaid(invoice.cardId, invoice.month, invoice.year);
                        const statusTag = isPaid ? '<span class="status-tag status-paid"><i class="fas fa-check-circle"></i> Pago</span>' : '';
                        const dueDate = new Date(invoice.year, invoice.month, card.dueDay);
                        const formattedDueDate = `${dueDate.getDate().toString().padStart(2, '0')}/${(dueDate.getMonth() + 1).toString().padStart(2, '0')}/${dueDate.getFullYear()}`;
                        
                        html += `<div class="transaction-item"><div class="transaction-info"><div class="transaction-icon" style="background-color: ${card.color}20; color: ${card.color}">${card.emoji}</div><div class="transaction-details"><div class="transaction-name">${card.name} (*${card.lastDigits}) ${statusTag}</div><div class="transaction-category">Vence em ${formattedDueDate}</div></div></div><div style="text-align: right;"><div class="transaction-amount expense-amount">Fatura: R$ ${this.formatCurrency(invoice.totalAmount)}</div></div></div>`;
                    });
                } else {
                    cardsData.forEach(card => { 
                        const isPaid = this.isCardInvoicePaid(card.id, this.currentMonth, this.currentYear); 
                        const statusTag = isPaid ? '<span class="status-tag status-paid"><i class="fas fa-check-circle"></i> Pago</span>' : ''; 
                        html += `<div class="transaction-item"><div class="transaction-info"><div class="transaction-icon" style="background-color: ${card.color}20; color: ${card.color}">${card.emoji}</div><div class="transaction-details"><div class="transaction-name">${card.name} (*${card.lastDigits}) ${statusTag}</div><div class="transaction-category">Vence dia ${card.dueDay}</div></div></div><div style="text-align: right;"><div class="transaction-amount expense-amount">Fatura: R$ ${this.formatCurrency(card.totalFaturaMes)}</div></div></div>`; 
                    });
                }
                
                return html;
            }

            isCardInvoicePaid(cardId, month, year) { 
                return this.paidCardInvoices.some(invoice => invoice.cardId === cardId && invoice.month === month && invoice.year === year); 
            }

            getCardInvoicesInCustomPeriod() {
                if (!this.customDateStart || !this.customDateEnd) {
                    return [];
                }
                
                const invoices = [];
                const startDate = new Date(this.customDateStart);
                const endDate = new Date(this.customDateEnd);
                
                this.data.cards.forEach(card => {
                    const startMonth = startDate.getMonth();
                    const startYear = startDate.getFullYear();
                    const endMonth = endDate.getMonth();
                    const endYear = endDate.getFullYear();
                    
                    let currentMonth = startMonth;
                    let currentYear = startYear;
                    
                    while (currentYear < endYear || (currentYear === endYear && currentMonth <= endMonth)) {
                        const dueDate = new Date(currentYear, currentMonth, card.dueDay);
                        
                        if (dueDate >= startDate && dueDate <= endDate) {
                            const transactionsInInvoice = this.data.transactions.filter(t => 
                                t.type === 'card' && 
                                t.card === card.id && 
                                t.invoiceMonth === currentMonth && 
                                t.invoiceYear === currentYear
                            );
                            
                            const totalAmount = transactionsInInvoice.reduce((sum, t) => sum + t.amount, 0);
                            
                            if (totalAmount > 0 || transactionsInInvoice.length > 0) {
                                invoices.push({
                                    cardId: card.id,
                                    month: currentMonth,
                                    year: currentYear,
                                    totalAmount: totalAmount,
                                    dueDate: dueDate
                                });
                            }
                        }
                        
                        currentMonth++;
                        if (currentMonth > 11) {
                            currentMonth = 0;
                            currentYear++;
                        }
                    }
                });
                
                return invoices.sort((a, b) => a.dueDate - b.dueDate);
            }

           markCardInvoiceAsPaid(cardId, month, year, paymentTransactionId, carriedOverBalanceTransactionId = null) { 
    if (!this.isCardInvoicePaid(cardId, month, year)) { 
        this.paidCardInvoices.push({ 
            cardId, 
            month, 
            year, 
            paidDate: new Date().toISOString(), 
            paymentTransactionId, 
            carriedOverBalanceTransactionId 
        }); 
        this.saveToStorage('finance_paid_invoices', this.paidCardInvoices); 
    } 
}

            reopenCardInvoice(cardId, month, year) {
    const invoiceToReopen = this.paidCardInvoices.find(invoice => invoice.cardId === cardId && invoice.month === month && invoice.year === year);
    if (invoiceToReopen) { 
        if (invoiceToReopen.paymentTransactionId) { 
            const transactionIds = invoiceToReopen.paymentTransactionId.split(',');
            transactionIds.forEach(id => {
                this.data.transactions = this.data.transactions.filter(t => t.id !== id);
            });
        } 
        if (invoiceToReopen.carriedOverBalanceTransactionId) { 
            this.data.transactions = this.data.transactions.filter(t => t.id !== invoiceToReopen.carriedOverBalanceTransactionId); 
        } 
    }
    this.paidCardInvoices = this.paidCardInvoices.filter(invoice => !(invoice.cardId === cardId && invoice.month === month && invoice.year === year));
    this.saveToStorage('finance_paid_invoices', this.paidCardInvoices); 
    this.saveData(); 
}

            renderIncomeExpenseChart() { 
                const canvasElement = document.getElementById('incomeExpenseChart'); 
                if (!canvasElement) return; 
                const ctx = canvasElement.getContext('2d'); 
                const chartData = this.customDateFilterEnabled ? 
                    this.getChartDataForCustomPeriod() : 
                    this.getChartDataForIncomeExpense(6); 
                
                if (window.incomeExpenseChartInstance) { 
                    window.incomeExpenseChartInstance.destroy(); 
                }
                window.incomeExpenseChartInstance = new Chart(ctx, { 
                    type: 'bar', 
                    data: { 
                        labels: chartData.labels, 
                        datasets: [ 
                            { 
                                label: '💰 Receitas', 
                                data: chartData.income, 
                                backgroundColor: 'rgba(16, 185, 129, 0.8)',
                                borderColor: 'rgba(16, 185, 129, 1)', 
                                borderWidth: 0,
                                borderRadius: 6,
                                borderSkipped: false,
                                hoverBackgroundColor: 'rgba(16, 185, 129, 0.95)',
                                hoverBorderColor: 'rgba(16, 185, 129, 1)',
                                hoverBorderWidth: 2
                            }, 
                            { 
                                label: '💸 Despesas', 
                                data: chartData.expense, 
                                backgroundColor: 'rgba(239, 68, 68, 0.8)',
                                borderColor: 'rgba(239, 68, 68, 1)', 
                                borderWidth: 0,
                                borderRadius: 6,
                                borderSkipped: false,
                                hoverBackgroundColor: 'rgba(239, 68, 68, 0.95)',
                                hoverBorderColor: 'rgba(239, 68, 68, 1)',
                                hoverBorderWidth: 2
                            } 
                        ] 
                    }, 
                    options: { 
                        responsive: true, 
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        scales: { 
                            y: { 
                                beginAtZero: true,
                                grid: {
                                    color: this.darkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)',
                                    lineWidth: 1
                                },
                                border: {
                                    display: false
                                },
                                ticks: { 
                                    callback: value => {
                                        return value.toLocaleString('pt-BR', {
                                            style: 'currency',
                                            currency: 'BRL',
                                            minimumFractionDigits: 0,
                                            maximumFractionDigits: 0
                                        });
                                    },
                                    color: this.darkMode ? '#D1D5DB' : '#6B7280',
                                    font: {
                                        family: 'Poppins',
                                        size: window.innerWidth <= 768 ? 10 : 12
                                    },
                                    padding: 8
                                } 
                            }, 
                            x: {
                                grid: {
                                    display: false
                                },
                                border: {
                                    display: false
                                },
                                ticks: { 
                                    color: this.darkMode ? '#D1D5DB' : '#6B7280',
                                    font: {
                                        family: 'Poppins',
                                        size: window.innerWidth <= 768 ? 10 : 12,
                                        weight: '500'
                                    },
                                    padding: 8
                                } 
                            } 
                        }, 
                        plugins: { 
                            tooltip: {
                                backgroundColor: this.darkMode ? 'rgba(31, 41, 55, 0.95)' : 'rgba(255, 255, 255, 0.95)',
                                titleColor: this.darkMode ? '#FFFFFF' : '#1F2937',
                                bodyColor: this.darkMode ? '#FFFFFF' : '#1F2937',
                                borderColor: this.darkMode ? '#374151' : '#E5E7EB',
                                borderWidth: 1,
                                cornerRadius: 12,
                                padding: 16,
                                titleFont: { 
                                    family: 'Poppins',
                                    size: 14, 
                                    weight: 'bold' 
                                },
                                bodyFont: { 
                                    family: 'Poppins',
                                    size: 13 
                                },
                                displayColors: true,
                                usePointStyle: true,
                                callbacks: { 
                                    title: function(context) {
                                        return `📅 ${context[0].label}`;
                                    },
                                    label: context => {
                                        const value = context.raw.toLocaleString('pt-BR', { 
                                            style: 'currency',
                                            currency: 'BRL',
                                            minimumFractionDigits: 2, 
                                            maximumFractionDigits: 2 
                                        });
                                        return `${context.dataset.label}: ${value}`;
                                    },
                                    afterBody: function(tooltipItems) {
                                        if (tooltipItems.length === 2) {
                                            const receita = tooltipItems.find(item => item.dataset.label.includes('Receitas'))?.raw || 0;
                                            const despesa = tooltipItems.find(item => item.dataset.label.includes('Despesas'))?.raw || 0;
                                            const saldo = receita - despesa;
                                            const saldoFormatted = saldo.toLocaleString('pt-BR', {
                                                style: 'currency',
                                                currency: 'BRL',
                                                minimumFractionDigits: 2,
                                                maximumFractionDigits: 2
                                            });
                                            return `\n📊 Saldo: ${saldoFormatted}`;
                                        }
                                        return '';
                                    }
                                } 
                            }, 
                            legend: {
                                position: window.innerWidth <= 768 ? 'bottom' : 'top',
                                align: 'center',
                                labels: { 
                                    color: this.darkMode ? '#FFFFFF' : '#374151',
                                    font: {
                                        family: 'Poppins',
                                        size: window.innerWidth <= 768 ? 12 : 14,
                                        weight: '600'
                                    },
                                    padding: window.innerWidth <= 768 ? 15 : 20,
                                    usePointStyle: true,
                                    pointStyle: 'rect',
                                    boxWidth: 12,
                                    boxHeight: 12
                                } 
                            }
                        },
                        animation: {
                            duration: 1200,
                            easing: 'easeOutQuart',
                            delay: (context) => {
                                return context.dataIndex * 100;
                            }
                        },
                        onHover: (event, elements) => {
                            event.native.target.style.cursor = elements.length > 0 ? 'pointer' : 'default';
                        } 
                    } 
                });
            }

            renderCategoryChart(monthData) { 
    const canvasElement = document.getElementById('categoryChart'); 
    if (!canvasElement) return; 
    const ctx = canvasElement.getContext('2d');
    
    // Filtrar categorias com total > 0
    const expenseCategoriesWithTotals = monthData.categories.filter(catData => { 
        const originalCategory = this.data.categories.expense.find(c => c.id === catData.id); 
        return originalCategory && catData.total > 0; 
    });

    // Verificar se há dados para exibir
    if (expenseCategoriesWithTotals.length === 0) { 
        canvasElement.style.display = 'none'; 
        const noDataContainer = canvasElement.parentElement; 
        if(noDataContainer.querySelector('.no-data-chart')) { 
            noDataContainer.querySelector('.no-data-chart').remove(); 
        } 
        const noDataHtml = '<div class="no-data no-data-chart" style="height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center;"><i class="fas fa-chart-pie"></i><p>Sem despesas no mês para exibir.</p></div>'; 
        noDataContainer.insertAdjacentHTML('beforeend', noDataHtml); 
        return; 
    } else { 
        canvasElement.style.display = 'block'; 
        const noDataContainer = canvasElement.parentElement; 
        if(noDataContainer.querySelector('.no-data-chart')) { 
            noDataContainer.querySelector('.no-data-chart').remove(); 
        } 
    }

    // Definir cores fixas diferentes para cada fatia
    const chartColors = [
        '#FF6384', // Rosa
        '#36A2EB', // Azul
        '#FFCE56', // Amarelo
        '#4BC0C0', // Verde água
        '#9966FF', // Roxo
        '#FF9F40', // Laranja
        '#8AC249', // Verde
        '#EA526F', // Rosa escuro
        '#00A8B5', // Turquesa
        '#666666', // Cinza
        '#FF5768', // Vermelho claro
        '#7C83FD', // Azul lavanda
        '#96BB7C', // Verde musgo
        '#ECC19C', // Bege
        '#1E3888'  // Azul marinho
    ];
    
    // Pegar dados para o gráfico
    const labels = expenseCategoriesWithTotals.map(cat => cat.name);
    const data = expenseCategoriesWithTotals.map(cat => cat.total);
    
    // Gerar um array de cores com base no número de categorias
    const backgroundColors = [];
    for (let i = 0; i < expenseCategoriesWithTotals.length; i++) {
        backgroundColors.push(chartColors[i % chartColors.length]);
    }
    
    // Log para depuração
    console.log("Categorias:", expenseCategoriesWithTotals);
    console.log("Cores aplicadas:", backgroundColors);

    // Destruir instância anterior do gráfico
    if (window.categoryChartInstance) { 
        window.categoryChartInstance.destroy(); 
    }
    
    // Criar nova instância do gráfico
    const isMobile = window.innerWidth <= 768;
    const totalExpenses = data.reduce((a, b) => a + b, 0);
    
    // Plugin personalizado para mostrar total no centro
    const centerTextPlugin = {
        id: 'centerText',
        afterDraw: function(chart) {
            if (chart.config.type === 'doughnut') {
                const ctx = chart.ctx;
                const centerX = (chart.chartArea.left + chart.chartArea.right) / 2;
                const centerY = (chart.chartArea.top + chart.chartArea.bottom) / 2;
                
                ctx.save();
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Texto principal com shadow para melhor visibilidade
                ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                ctx.shadowBlur = 2;
                ctx.fillStyle = chart.options.plugins.legend.labels.color;
                ctx.font = isMobile ? 'bold 12px Poppins' : 'bold 14px Poppins';
                ctx.fillText('Total Despesas', centerX, centerY - 10);
                
                // Valor com shadow
                ctx.font = isMobile ? 'bold 14px Poppins' : 'bold 16px Poppins';
                ctx.fillStyle = '#ef4444';
                const formattedTotal = totalExpenses.toLocaleString('pt-BR', { 
                    style: 'currency', 
                    currency: 'BRL',
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                });
                ctx.fillText(formattedTotal, centerX, centerY + 10);
                
                ctx.restore();
            }
        }
    };
    
    window.categoryChartInstance = new Chart(ctx, { 
        type: 'doughnut', 
        data: { 
            labels: labels, 
            datasets: [{ 
                data: data, 
                backgroundColor: backgroundColors, 
                hoverBackgroundColor: backgroundColors.map(color => color + 'DD'),
                borderWidth: 0,
                hoverBorderWidth: 2,
                hoverBorderColor: '#FFFFFF'
            }] 
        }, 
        options: { 
            responsive: true, 
            maintainAspectRatio: false,
            cutout: isMobile ? '75%' : '78%',
            plugins: { 
                tooltip: { 
                    backgroundColor: this.darkMode ? 'rgba(31, 41, 55, 0.95)' : 'rgba(255, 255, 255, 0.95)',
                    titleColor: this.darkMode ? '#FFFFFF' : '#1F2937',
                    bodyColor: this.darkMode ? '#FFFFFF' : '#1F2937',
                    borderColor: this.darkMode ? '#374151' : '#E5E7EB',
                    borderWidth: 1,
                    cornerRadius: 8,
                    padding: 15,
                    titleFont: { size: 14, weight: 'bold' },
                    bodyFont: { size: 13 },
                    callbacks: { 
                        title: function(context) {
                            return context[0].label;
                        },
                        label: context => { 
                            const value = context.raw; 
                            const totalDatasetSum = context.dataset.data.reduce((a, b) => a + b, 0); 
                            const percentage = totalDatasetSum > 0 ? Math.round((value / totalDatasetSum) * 100) : 0; 
                            return [
                                `💰 R$ ${value.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`,
                                `📊 ${percentage}% do total`
                            ];
                        } 
                    } 
                }, 
                legend: { 
                    position: isMobile ? 'bottom' : 'right', 
                    align: 'center',
                    labels: { 
                        padding: isMobile ? 15 : 20,
                        usePointStyle: true,
                        pointStyle: 'circle',
                        font: {
                            size: isMobile ? 11 : 12,
                            family: 'Poppins'
                        },
                        color: this.darkMode ? '#FFFFFF' : 'var(--text-color)',
                        generateLabels: function(chart) {
                            const data = chart.data;
                            if (data.labels.length && data.datasets.length) {
                                const dataset = data.datasets[0];
                                const total = dataset.data.reduce((a, b) => a + b, 0);
                                
                                // Criar array com índices e valores para ordenação
                                const itemsWithIndex = data.labels.map((label, i) => ({
                                    label: label,
                                    value: dataset.data[i],
                                    index: i,
                                    backgroundColor: dataset.backgroundColor[i]
                                }));
                                
                                // Ordenar do maior para o menor valor
                                itemsWithIndex.sort((a, b) => b.value - a.value);
                                
                                // Gerar labels ordenadas
                                return itemsWithIndex.map(item => {
                                    const percentage = total > 0 ? Math.round((item.value / total) * 100) : 0;
                                    const valueFormatted = item.value.toLocaleString('pt-BR', { 
                                        minimumFractionDigits: 2, 
                                        maximumFractionDigits: 2,
                                        style: 'currency',
                                        currency: 'BRL'
                                    });
                                    
                                    return {
                                        text: `${item.label} (${percentage}%)`,
                                        fillStyle: item.backgroundColor,
                                        hidden: false,
                                        index: item.index,
                                        pointStyle: 'circle'
                                    };
                                });
                            }
                            return [];
                        }
                    } 
                } 
            },
            onHover: (event, elements) => {
                event.native.target.style.cursor = elements.length > 0 ? 'pointer' : 'default';
            },
            animation: {
                animateRotate: true,
                animateScale: false,
                duration: 1000,
                easing: 'easeOutQuart'
            }
        },
        plugins: [centerTextPlugin]
    });
    
    // Log após criar o gráfico para verificar se tudo foi aplicado corretamente
    console.log("Gráfico criado:", window.categoryChartInstance);
}

            renderFutureIncomeExpenseChart() { 
                const canvasElement = document.getElementById('futureIncomeExpenseChart'); 
                if (!canvasElement) return; 
                const ctx = canvasElement.getContext('2d'); 
                const chartData = this.customDateFilterEnabled ? 
                    this.getChartDataForCustomPeriod() : 
                    this.getFutureChartDataForIncomeExpense(6); 
                
                if (window.futureIncomeExpenseChartInstance) { 
                    window.futureIncomeExpenseChartInstance.destroy(); 
                }
                window.futureIncomeExpenseChartInstance = new Chart(ctx, { 
                    type: 'bar', 
                    data: { 
                        labels: chartData.labels, 
                        datasets: [ 
                            { 
                                label: '💰 Receitas', 
                                data: chartData.income, 
                                backgroundColor: 'rgba(16, 185, 129, 0.8)',
                                borderColor: 'rgba(16, 185, 129, 1)', 
                                borderWidth: 0,
                                borderRadius: 6,
                                borderSkipped: false,
                                hoverBackgroundColor: 'rgba(16, 185, 129, 0.95)',
                                hoverBorderColor: 'rgba(16, 185, 129, 1)',
                                hoverBorderWidth: 2
                            }, 
                            { 
                                label: '💸 Despesas', 
                                data: chartData.expense, 
                                backgroundColor: 'rgba(239, 68, 68, 0.8)',
                                borderColor: 'rgba(239, 68, 68, 1)', 
                                borderWidth: 0,
                                borderRadius: 6,
                                borderSkipped: false,
                                hoverBackgroundColor: 'rgba(239, 68, 68, 0.95)',
                                hoverBorderColor: 'rgba(239, 68, 68, 1)',
                                hoverBorderWidth: 2
                            } 
                        ] 
                    }, 
                    options: { 
                        responsive: true, 
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        scales: { 
                            y: { 
                                beginAtZero: true,
                                grid: {
                                    color: this.darkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)',
                                    lineWidth: 1
                                },
                                border: {
                                    display: false
                                },
                                ticks: { 
                                    callback: value => {
                                        return value.toLocaleString('pt-BR', {
                                            style: 'currency',
                                            currency: 'BRL',
                                            minimumFractionDigits: 0,
                                            maximumFractionDigits: 0
                                        });
                                    },
                                    color: this.darkMode ? '#D1D5DB' : '#6B7280',
                                    font: {
                                        family: 'Poppins',
                                        size: window.innerWidth <= 768 ? 10 : 12
                                    },
                                    padding: 8
                                } 
                            }, 
                            x: {
                                grid: {
                                    display: false
                                },
                                border: {
                                    display: false
                                },
                                ticks: { 
                                    color: this.darkMode ? '#D1D5DB' : '#6B7280',
                                    font: {
                                        family: 'Poppins',
                                        size: window.innerWidth <= 768 ? 10 : 12,
                                        weight: '500'
                                    },
                                    padding: 8
                                } 
                            } 
                        }, 
                        plugins: { 
                            tooltip: {
                                backgroundColor: this.darkMode ? 'rgba(31, 41, 55, 0.95)' : 'rgba(255, 255, 255, 0.95)',
                                titleColor: this.darkMode ? '#FFFFFF' : '#1F2937',
                                bodyColor: this.darkMode ? '#FFFFFF' : '#1F2937',
                                borderColor: this.darkMode ? '#374151' : '#E5E7EB',
                                borderWidth: 1,
                                cornerRadius: 12,
                                padding: 16,
                                titleFont: { 
                                    family: 'Poppins',
                                    size: 14, 
                                    weight: 'bold' 
                                },
                                bodyFont: { 
                                    family: 'Poppins',
                                    size: 13 
                                },
                                displayColors: true,
                                usePointStyle: true,
                                callbacks: { 
                                    title: function(context) {
                                        return `📅 ${context[0].label}`;
                                    },
                                    label: context => {
                                        const value = context.raw.toLocaleString('pt-BR', { 
                                            style: 'currency',
                                            currency: 'BRL',
                                            minimumFractionDigits: 2, 
                                            maximumFractionDigits: 2 
                                        });
                                        return `${context.dataset.label}: ${value}`;
                                    },
                                    afterBody: function(tooltipItems) {
                                        if (tooltipItems.length === 2) {
                                            const receita = tooltipItems.find(item => item.dataset.label.includes('Receitas'))?.raw || 0;
                                            const despesa = tooltipItems.find(item => item.dataset.label.includes('Despesas'))?.raw || 0;
                                            const saldo = receita - despesa;
                                            const saldoFormatted = saldo.toLocaleString('pt-BR', {
                                                style: 'currency',
                                                currency: 'BRL',
                                                minimumFractionDigits: 2,
                                                maximumFractionDigits: 2
                                            });
                                            return `\n📊 Saldo: ${saldoFormatted}`;
                                        }
                                        return '';
                                    }
                                } 
                            }, 
                            legend: {
                                position: window.innerWidth <= 768 ? 'bottom' : 'top',
                                align: 'center',
                                labels: { 
                                    color: this.darkMode ? '#FFFFFF' : '#374151',
                                    font: {
                                        family: 'Poppins',
                                        size: window.innerWidth <= 768 ? 12 : 14,
                                        weight: '600'
                                    },
                                    padding: window.innerWidth <= 768 ? 15 : 20,
                                    usePointStyle: true,
                                    pointStyle: 'rect',
                                    boxWidth: 12,
                                    boxHeight: 12
                                } 
                            }
                        },
                        animation: {
                            duration: 1200,
                            easing: 'easeOutQuart',
                            delay: (context) => {
                                return context.dataIndex * 100;
                            }
                        },
                        onHover: (event, elements) => {
                            event.native.target.style.cursor = elements.length > 0 ? 'pointer' : 'default';
                        } 
                    } 
                });
            }

            renderIncomeCategoryChart(monthData) { 
                const canvasElement = document.getElementById('incomeCategoryChart'); 
                if (!canvasElement) return; 
                const ctx = canvasElement.getContext('2d');
                
                const incomeCategoriesWithTotals = monthData.incomeCategories ? monthData.incomeCategories.filter(catData => { 
                    const originalCategory = this.data.categories.income.find(c => c.id === catData.id); 
                    return originalCategory && catData.total > 0; 
                }) : [];

                if (incomeCategoriesWithTotals.length === 0) { 
                    canvasElement.style.display = 'none'; 
                    const noDataContainer = canvasElement.parentElement; 
                    if(noDataContainer.querySelector('.no-data-chart')) { 
                        noDataContainer.querySelector('.no-data-chart').remove(); 
                    } 
                    const noDataHtml = '<div class="no-data no-data-chart" style="height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center;"><i class="fas fa-chart-pie"></i><p>Sem receitas no mês para exibir.</p></div>'; 
                    noDataContainer.insertAdjacentHTML('beforeend', noDataHtml); 
                    return; 
                } else { 
                    canvasElement.style.display = 'block'; 
                    const noDataContainer = canvasElement.parentElement; 
                    if(noDataContainer.querySelector('.no-data-chart')) { 
                        noDataContainer.querySelector('.no-data-chart').remove(); 
                    } 
                }

                const chartColors = [
                    '#10B981', 
                    '#34D399', 
                    '#6EE7B7', 
                    '#14B8A6', 
                    '#0891B2', 
                    '#0EA5E9', 
                    '#06B6D4', 
                    '#67E8F9', 
                    '#22D3EE', 
                    '#67C6E7', 
                    '#A5F3FC', 
                    '#CFFAFE', 
                    '#0F766E', 
                    '#134E4A', 
                    '#164E63'  
                ];
                
                const labels = incomeCategoriesWithTotals.map(cat => cat.name);
                const data = incomeCategoriesWithTotals.map(cat => cat.total);
                
                const backgroundColors = [];
                for (let i = 0; i < incomeCategoriesWithTotals.length; i++) {
                    backgroundColors.push(chartColors[i % chartColors.length]);
                }

                if (window.incomeCategoryChartInstance) { 
                    window.incomeCategoryChartInstance.destroy(); 
                }
                
                const isMobile = window.innerWidth <= 768;
                const totalIncome = data.reduce((a, b) => a + b, 0);
                
                const centerTextPlugin = {
                    id: 'centerTextIncome',
                    afterDraw: function(chart) {
                        if (chart.config.type === 'doughnut') {
                            const ctx = chart.ctx;
                            const centerX = (chart.chartArea.left + chart.chartArea.right) / 2;
                            const centerY = (chart.chartArea.top + chart.chartArea.bottom) / 2;
                            
                            ctx.save();
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            
                            // Texto principal com shadow para melhor visibilidade
                            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                            ctx.shadowBlur = 2;
                            ctx.fillStyle = chart.options.plugins.legend.labels.color;
                            ctx.font = isMobile ? 'bold 12px Poppins' : 'bold 14px Poppins';
                            ctx.fillText('Total Receitas', centerX, centerY - 10);
                            
                            // Valor com shadow
                            ctx.font = isMobile ? 'bold 14px Poppins' : 'bold 16px Poppins';
                            ctx.fillStyle = '#10b981';
                            const formattedTotal = totalIncome.toLocaleString('pt-BR', { 
                                style: 'currency', 
                                currency: 'BRL',
                                minimumFractionDigits: 2,
                                maximumFractionDigits: 2
                            });
                            ctx.fillText(formattedTotal, centerX, centerY + 10);
                            
                            ctx.restore();
                        }
                    }
                };
                
                window.incomeCategoryChartInstance = new Chart(ctx, { 
                    type: 'doughnut', 
                    data: { 
                        labels: labels, 
                        datasets: [{ 
                            data: data, 
                            backgroundColor: backgroundColors, 
                            hoverBackgroundColor: backgroundColors.map(color => color + 'DD'),
                            borderWidth: 0,
                            hoverBorderWidth: 2,
                            hoverBorderColor: '#FFFFFF'
                        }] 
                    }, 
                    options: { 
                        responsive: true, 
                        maintainAspectRatio: false,
                        cutout: isMobile ? '75%' : '78%',
                        plugins: { 
                            tooltip: { 
                                backgroundColor: this.darkMode ? 'rgba(31, 41, 55, 0.95)' : 'rgba(255, 255, 255, 0.95)',
                                titleColor: this.darkMode ? '#FFFFFF' : '#1F2937',
                                bodyColor: this.darkMode ? '#FFFFFF' : '#1F2937',
                                borderColor: this.darkMode ? '#374151' : '#E5E7EB',
                                borderWidth: 1,
                                cornerRadius: 8,
                                padding: 15,
                                titleFont: { size: 14, weight: 'bold' },
                                bodyFont: { size: 13 },
                                callbacks: { 
                                    title: function(context) {
                                        return context[0].label;
                                    },
                                    label: context => { 
                                        const value = context.raw; 
                                        const totalDatasetSum = context.dataset.data.reduce((a, b) => a + b, 0); 
                                        const percentage = totalDatasetSum > 0 ? Math.round((value / totalDatasetSum) * 100) : 0; 
                                        return [
                                            `💰 R$ ${value.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`,
                                            `📊 ${percentage}% do total`
                                        ];
                                    } 
                                } 
                            }, 
                            legend: { 
                                position: isMobile ? 'bottom' : 'right', 
                                align: 'center',
                                labels: { 
                                    padding: isMobile ? 15 : 20,
                                    usePointStyle: true,
                                    pointStyle: 'circle',
                                    font: {
                                        size: isMobile ? 11 : 12,
                                        family: 'Poppins'
                                    },
                                    color: this.darkMode ? '#FFFFFF' : 'var(--text-color)',
                                    generateLabels: function(chart) {
                                        const data = chart.data;
                                        if (data.labels.length && data.datasets.length) {
                                            const dataset = data.datasets[0];
                                            const total = dataset.data.reduce((a, b) => a + b, 0);
                                            
                                            const itemsWithIndex = data.labels.map((label, i) => ({
                                                label: label,
                                                value: dataset.data[i],
                                                index: i,
                                                backgroundColor: dataset.backgroundColor[i]
                                            }));
                                            
                                            itemsWithIndex.sort((a, b) => b.value - a.value);
                                            
                                            return itemsWithIndex.map(item => {
                                                const percentage = total > 0 ? Math.round((item.value / total) * 100) : 0;
                                                const valueFormatted = item.value.toLocaleString('pt-BR', { 
                                                    minimumFractionDigits: 2, 
                                                    maximumFractionDigits: 2,
                                                    style: 'currency',
                                                    currency: 'BRL'
                                                });
                                                
                                                return {
                                                    text: `${item.label} (${percentage}%)`,
                                                    fillStyle: item.backgroundColor,
                                                    hidden: false,
                                                    index: item.index,
                                                    pointStyle: 'circle'
                                                };
                                            });
                                        }
                                        return [];
                                    }
                                } 
                            } 
                        },
                        onHover: (event, elements) => {
                            event.native.target.style.cursor = elements.length > 0 ? 'pointer' : 'default';
                        },
                        animation: {
                            animateRotate: true,
                            animateScale: false,
                            duration: 1000,
                            easing: 'easeOutQuart'
                        }
                    },
                    plugins: [centerTextPlugin]
                });
            }

            renderTransactions(container) {
                const filterAccountId = this.hasActiveTransactionFilters() ? this.getEffectiveAccountFilter() : this.selectedFilterAccount;
                const monthData = this.customDateFilterEnabled ? 
                    this.getCustomPeriodData(this.customDateStart, this.customDateEnd, filterAccountId) :
                    this.getMonthData(this.currentMonth, this.currentYear, filterAccountId);

                const periodDisplay = this.customDateFilterEnabled ? 
                    `${this.formatDate(this.parseDate(this.customDateStart))} - ${this.formatDate(this.parseDate(this.customDateEnd))}` :
                    `${this.getMonthName(this.currentMonth)} de ${this.currentYear}`;

                // Mostrar informações sobre filtros ativos
                let filterInfo = '';
                if (this.hasActiveTransactionFilters()) {
                    const activeFilters = [];
                    if (this.transactionFilters.type !== 'all') {
                        const typeNames = { income: 'Receitas', expense: 'Despesas', card: 'Cartão', transfer: 'Transferências' };
                        activeFilters.push(`Tipo: ${typeNames[this.transactionFilters.type] || this.transactionFilters.type}`);
                    }
                    if (this.transactionFilters.category !== 'all') {
                        const category = [...this.data.categories.income, ...this.data.categories.expense]
                            .find(c => c.id === this.transactionFilters.category);
                        activeFilters.push(`Categoria: ${category ? category.name : 'Desconhecida'}`);
                    }
                    if (this.transactionFilters.account !== 'all') {
                        const account = this.data.accounts.find(a => a.id === this.transactionFilters.account);
                        activeFilters.push(`Conta: ${account ? account.name : 'Desconhecida'}`);
                    }
                    
                    if (activeFilters.length > 0) {
                        filterInfo = `
                            <div style="background-color: rgba(99, 102, 241, 0.1); border: 1px solid var(--primary-color); border-radius: var(--border-radius); padding: 12px; margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <i class="fas fa-filter" style="color: var(--primary-color);"></i>
                                    <span style="font-weight: 500;">Filtros ativos:</span>
                                    <span style="color: var(--text-light);">${activeFilters.join(' • ')}</span>
                                </div>
                                <button class="btn btn-sm btn-outlined" id="clearAllFiltersTransactions">
                                    <i class="fas fa-times"></i> Limpar Filtros
                                </button>
                            </div>
                        `;
                    }
                }

                container.innerHTML = `
                    ${filterInfo}
                    <div class="header-actions" style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; margin-bottom: 20px;">
                        ${this.customDateFilterEnabled ? 
                            `<div style="display: flex; align-items: center; gap: 10px; font-weight: 500;">
                                <span>Período: ${periodDisplay}</span>
                                <button class="btn btn-sm btn-outlined" id="clearCustomFilterTransactions"><i class="fas fa-times"></i> Limpar Filtro</button>
                            </div>` :
                            `<div class="month-navigation">
                                <button class="month-nav-btn" id="prevMonthBtnTransactions"><i class="fas fa-chevron-left"></i></button>
                                <span class="current-month" id="currentMonthDisplayTransactions">${this.getMonthName(this.currentMonth)} de ${this.currentYear}</span>
                                <button class="month-nav-btn" id="nextMonthBtnTransactions"><i class="fas fa-chevron-right"></i></button>
                            </div>`
                        }
                        <div style="display: flex; align-items: center; gap: 10px;" class="toggle-switch-container">
                            <label class="toggle-switch">
                                <input type="checkbox" id="previewToggleTransactions" ${this.isPreviewMode ? 'checked' : ''}>
                                <span class="toggle-slider"></span>
                            </label>
                            <span class="toggle-label">Modo Previsto</span>
                            <i class="fas fa-filter filter-toggle-icon" id="filterToggleTransactions" title="Opções de Filtro"></i>
                        </div>
                    </div>
                    <div class="grid-container"> 
                        <div class="card stat-card"><div class="stat-title">Saldo Inicial ${this.customDateFilterEnabled ? 'Período' : 'Mês'}</div><div class="stat-value ${monthData.dashboardInitialBalance >= 0 ? 'stat-positive' : 'stat-negative'}" id="transactionsInitialBalance">R$ ${this.formatCurrency(monthData.dashboardInitialBalance)}</div></div> 
                        <div class="card stat-card"><div class="stat-title">Receitas ${this.customDateFilterEnabled ? 'Período' : 'Mês'}</div><div class="stat-value stat-positive" id="transactionsIncome">R$ ${this.formatCurrency(monthData.dashboardIncome)}</div></div> 
                        <div class="card stat-card"><div class="stat-title">Despesas ${this.customDateFilterEnabled ? 'Período' : 'Mês'}</div><div class="stat-value stat-negative" id="transactionsExpense">R$ ${this.formatCurrency(monthData.dashboardExpense)}</div></div> 
                        <div class="card stat-card"><div class="stat-title">Saldo Final ${this.customDateFilterEnabled ? 'Período' : 'Mês'}</div><div class="stat-value ${monthData.dashboardFinalBalance >= 0 ? 'stat-positive' : 'stat-negative'}" id="transactionsFinalBalance">R$ ${this.formatCurrency(monthData.dashboardFinalBalance)}</div></div> 
                    </div>
                    <div class="card"> <div class="card-header"><h3 class="card-title">Transações</h3><div class="header-buttons"><button class="btn btn-secondary" id="exportTransactionsBtn"><i class="fas fa-download"></i><span>Exportar</span></button><button class="btn btn-primary" id="addTransactionBtn"><i class="fas fa-plus"></i><span>Nova Transação</span></button></div></div> <div class="transaction-list" id="transactionsListContainer"></div> </div>
                `;
                const previewToggle = document.getElementById('previewToggleTransactions'); 
                if (previewToggle) { 
                    previewToggle.addEventListener('change', () => { 
                        if (!this.isFeatureAvailable('preview_mode')) {
                            previewToggle.checked = false;
                            this.showUpgradeModal('preview_mode');
                            return;
                        }
                        this.isPreviewMode = previewToggle.checked; 
                        this.refreshTransactionsView(); 
                    }); 
                }

                // Navigation buttons (apenas quando não há filtro customizado)
                if (!this.customDateFilterEnabled) {
                    const prevMonthBtn = document.getElementById('prevMonthBtnTransactions'); 
                    const nextMonthBtn = document.getElementById('nextMonthBtnTransactions'); 
                    const currentMonthDisplay = document.getElementById('currentMonthDisplayTransactions');
                    if(prevMonthBtn) prevMonthBtn.addEventListener('click', () => this.navigateMonth(-1)); 
                    if(nextMonthBtn) nextMonthBtn.addEventListener('click', () => this.navigateMonth(1)); 
                    if(currentMonthDisplay) { 
                        currentMonthDisplay.addEventListener('click', () => { 
                            const today = new Date(); 
                            this.currentMonth = today.getMonth(); 
                            this.currentYear = today.getFullYear(); 
                            this.refreshView(); 
                        }); 
                    }
                } else {
                    // Event listener para limpar filtro personalizado
                    const clearCustomFilter = document.getElementById('clearCustomFilterTransactions');
                    if (clearCustomFilter) {
                        clearCustomFilter.addEventListener('click', () => {
                            this.customDateFilterEnabled = false;
                            this.customDateStart = null;
                            this.customDateEnd = null;
                            this.refreshView();
                        });
                    }
                }

                // Event listener para limpar todos os filtros
                const clearAllFilters = document.getElementById('clearAllFiltersTransactions');
                if (clearAllFilters) {
                    clearAllFilters.addEventListener('click', () => {
                        this.transactionFilters = { type: 'all', category: 'all', account: 'all' };
                        this.transactionsSortOrder = 'asc';
                        this.customDateFilterEnabled = false;
                        this.customDateStart = null;
                        this.customDateEnd = null;
                        this.selectedFilterAccount = 'all';
                        this.refreshView();
                        this.showNotification('Todos os filtros foram limpos!', 'info');
                    });
                }

                const addTransactionBtn = document.getElementById('addTransactionBtn'); 
                if(addTransactionBtn) addTransactionBtn.addEventListener('click', () => this.showTransactionModal());

                const exportTransactionsBtn = document.getElementById('exportTransactionsBtn');
                if(exportTransactionsBtn) exportTransactionsBtn.addEventListener('click', () => this.showExportModal());

                this.refreshTransactionsList(); 
            }

            refreshTransactionsView() { 
                const filterAccountId = this.hasActiveTransactionFilters() ? this.getEffectiveAccountFilter() : this.selectedFilterAccount;
                const monthData = this.customDateFilterEnabled ? 
                    this.getCustomPeriodData(this.customDateStart, this.customDateEnd, filterAccountId) :
                    this.getMonthData(this.currentMonth, this.currentYear, filterAccountId);
                this.refreshMonthlyStats('transactions', monthData); 
                this.refreshTransactionsList(); 
            }

            capitalizeFirstLetter(string) { 
                if (!string) return ''; 
                return string.charAt(0).toUpperCase() + string.slice(1); 
            }
            
            renderTransactionsList() {
    const transactionsListContainer = document.getElementById('transactionsListContainer');
    if (!transactionsListContainer) return;

    const filterAccountId = this.hasActiveTransactionFilters() ? this.getEffectiveAccountFilter() : this.selectedFilterAccount;
    let transactionsInPeriod;
    
    if (this.customDateFilterEnabled) {
        // Para período personalizado, use as transações já filtradas
        const periodData = this.getCustomPeriodData(this.customDateStart, this.customDateEnd, filterAccountId);
        transactionsInPeriod = periodData.transactionsInPeriod;
    } else {
        // Para filtro mensal, use a lógica original
        transactionsInPeriod = this.data.transactions.filter(t => {
            if (t.type === 'card') {
                // Para transações de cartão, filtrar pelo mês da fatura
                return t.invoiceMonth === this.currentMonth && t.invoiceYear === this.currentYear;
            } else {
                // Para outras transações, filtrar pela data normal
                const date = this.parseDate(t.date);
                return date.getMonth() === this.currentMonth && date.getFullYear() === this.currentYear;
            }
        });
    }

    // Aplicar filtros adicionais de tipo, categoria e conta
    if (this.transactionFilters) {
        transactionsInPeriod = transactionsInPeriod.filter(t => {
            // Filtro por tipo
            if (this.transactionFilters.type !== 'all') {
                if (this.transactionFilters.type === 'expense') {
                    // Para despesas, incluir tanto 'expense' quanto 'card' (faturas de cartão)
                    if (t.type !== 'expense' && t.type !== 'card') {
                        return false;
                    }
                } else if (t.type !== this.transactionFilters.type) {
                    return false;
                }
            }
            
            // Filtro por categoria
            if (this.transactionFilters.category !== 'all' && t.category !== this.transactionFilters.category) {
                return false;
            }
            
            // Filtro por conta usando a função auxiliar
            if (this.transactionFilters.account !== 'all') {
                if (!this.transactionBelongsToAccount(t, this.transactionFilters.account)) {
                    return false;
                }
            }
            
            return true;
        });
    }

    const cardInvoiceGroups = {};
    if (this.isFeatureAvailable('cards') && this.isPreviewMode) {
        if (this.customDateFilterEnabled) {
            // Para período personalizado, agrupar por mês/ano de fatura
            const cardTransactionsByInvoice = {};
            
            transactionsInPeriod.filter(t => t.type === 'card').forEach(t => {
                const card = this.data.cards.find(c => c.id === t.card);
                if (!card || (filterAccountId !== 'all' && card.account !== filterAccountId)) {
                    return;
                }
                
                const invoiceKey = `${t.card}-${t.invoiceMonth}-${t.invoiceYear}`;
                if (!cardTransactionsByInvoice[invoiceKey]) {
                    cardTransactionsByInvoice[invoiceKey] = {
                        cardDetails: card,
                        transactions: [],
                        invoiceMonth: t.invoiceMonth,
                        invoiceYear: t.invoiceYear
                    };
                }
                cardTransactionsByInvoice[invoiceKey].transactions.push(t);
            });
            
            // Criar grupos de fatura para cada mês/ano
            Object.keys(cardTransactionsByInvoice).forEach(invoiceKey => {
                const invoiceData = cardTransactionsByInvoice[invoiceKey];
                const dueDate = this.getCardDueDate(invoiceData.cardDetails.id, invoiceData.invoiceMonth, invoiceData.invoiceYear);
                
                cardInvoiceGroups[invoiceKey] = {
                    cardDetails: invoiceData.cardDetails,
                    transactions: invoiceData.transactions,
                    totalAmount: invoiceData.transactions.reduce((sum, t) => sum + t.amount, 0),
                    isPaid: false, // No período personalizado, considerar sempre como não pago para exibir
                    date: dueDate.toISOString()
                };
            });
        } else {
            // Lógica original para filtro mensal
            this.data.cards.forEach(card => {
                if (filterAccountId !== 'all' && card.account !== filterAccountId) {
                    return; 
                }

                const isInvoicePaid = this.isCardInvoicePaid(card.id, this.currentMonth, this.currentYear);
                if (!isInvoicePaid) { 
                    const cardTransactionsForPeriod = transactionsInPeriod.filter(t =>
                        t.type === 'card' && t.card === card.id &&
                        t.invoiceMonth === this.currentMonth && t.invoiceYear === this.currentYear
                    );

                    if (cardTransactionsForPeriod.length > 0) {
                        const dueDate = this.getCardDueDate(card.id, this.currentMonth, this.currentYear);
                        
                        cardInvoiceGroups[card.id] = {
                            cardDetails: card,
                            transactions: cardTransactionsForPeriod,
                            totalAmount: cardTransactionsForPeriod.reduce((sum, t) => sum + t.amount, 0),
                            isPaid: false,
                            date: dueDate.toISOString() 
                        };
                    }
                }
            });
        }
    }

    let displayableTransactions = transactionsInPeriod.filter(t => {
        if (t.type === 'card') {
            if (this.customDateFilterEnabled) {
                // No período personalizado, não mostrar transações de cartão separadas, apenas nos grupos
                return false;
            } else {
                // Lógica original para filtro mensal
                const isInvoicePaid = this.isCardInvoicePaid(t.card, t.invoiceMonth, t.invoiceYear);
                if (this.isPreviewMode && !isInvoicePaid) return false; 
                if (!this.isPreviewMode && !isInvoicePaid) return false; 
                return false; 
            }
        }

        if (filterAccountId !== 'all' && !this.transactionBelongsToAccount(t, filterAccountId)) {
            return false;
        }

        if (!this.isPreviewMode && !t.completed) {
            return false;
        }
        return true;
    });

    const combinedList = [...displayableTransactions];
    for (const invoiceKey in cardInvoiceGroups) {
        const invoiceData = cardInvoiceGroups[invoiceKey];
        // Para período personalizado, usar o invoiceKey que já contém cardId-month-year
        // Para filtro mensal, criar um ID simples
        const uniqueId = this.customDateFilterEnabled ? 
            `invoicegroup-${invoiceKey}` :
            `invoicegroup-${invoiceData.cardDetails.id}-${this.currentMonth}-${this.currentYear}`;
            
        combinedList.push({
            id: uniqueId,
            type: 'invoice_group',
            date: invoiceData.date, 
            data: invoiceData
        });
    }

    // Adiciona o item de saldo inicial se estiver usando o saldo do mês anterior e não for período personalizado
    if (this.usePreviousMonthBalance && !this.customDateFilterEnabled) {
        // Obtém os dados do mês atual para o filtro de conta selecionado
        const monthData = this.getMonthData(this.currentMonth, this.currentYear, filterAccountId);
        const initialBalance = monthData.dashboardInitialBalance;
        
        // Cria uma data para o primeiro dia do mês atual
        const firstDayOfMonth = new Date(this.currentYear, this.currentMonth, 1, 12, 0, 0);
        
        // Cria o item de saldo inicial como uma "pseudo-transação"
        const initialBalanceItem = {
            id: `initial-balance-${this.currentMonth}-${this.currentYear}-${filterAccountId}`,
            type: 'initial_balance',
            description: 'Saldo Inicial do Mês',
            amount: initialBalance,
            date: firstDayOfMonth.toISOString(),
            isSystemGenerated: true
        };
        
        // Adiciona o item de saldo inicial à lista combinada
        combinedList.push(initialBalanceItem);
    } else if (this.customDateFilterEnabled) {
        // Para período personalizado, adiciona o saldo inicial do período
        const periodData = this.getCustomPeriodData(this.customDateStart, this.customDateEnd, filterAccountId);
        const initialBalance = periodData.transactionsInitialBalance;
        
        // Cria uma data para o primeiro dia do período
        const firstDayOfPeriod = this.parseDate(this.customDateStart);
        firstDayOfPeriod.setHours(12, 0, 0, 0);
        
        // Cria o item de saldo inicial como uma "pseudo-transação"
        const initialBalanceItem = {
            id: `initial-balance-period-${filterAccountId}`,
            type: 'initial_balance',
            description: 'Saldo Inicial do Período',
            amount: initialBalance,
            date: firstDayOfPeriod.toISOString(),
            isSystemGenerated: true
        };
        
        // Adiciona o item de saldo inicial à lista combinada
        combinedList.push(initialBalanceItem);
    }

    if (combinedList.length === 0) {
        transactionsListContainer.innerHTML = '<div class="no-data"><i class="fas fa-exchange-alt"></i><p>Nenhuma transação encontrada para este período e filtros.</p></div>';
        return;
    }

    const days = {};
    combinedList.forEach(item => {
        const date = this.parseDate(item.date);
        const day = this.customDateFilterEnabled ? 
            `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}` :
            `${date.getDate()}`;
        
        if (!days[day]) {
            days[day] = [];
        }
        days[day].push(item);
    });

    let sortedDaysKeys = Object.keys(days);
    if (this.customDateFilterEnabled) {
        // Para período personalizado, ordenar por data completa
        if (this.transactionsSortOrder === 'asc') {
            sortedDaysKeys.sort();
        } else {
            sortedDaysKeys.sort().reverse();
        }
    } else {
        // Para filtro mensal, usar a lógica original
        if (this.transactionsSortOrder === 'asc') {
            sortedDaysKeys.sort((a, b) => parseInt(a) - parseInt(b));
        } else {
            sortedDaysKeys.sort((a, b) => parseInt(b) - parseInt(a));
        }
    }

    let html = '';
    sortedDaysKeys.forEach(dayKey => {
        const dayItems = days[dayKey];
        dayItems.sort((a, b) => {
            const dateA = this.parseDate(a.date).getTime();
            const dateB = this.parseDate(b.date).getTime();
            return this.transactionsSortOrder === 'asc' ? dateA - dateB : dateB - dateA;
        });

        const dateForHeader = this.parseDate(dayItems[0].date); 
        
        // Calcular saldo do dia - ajustar para período personalizado
        let dayBalance;
        if (this.customDateFilterEnabled) {
            // Para período personalizado, calcular o saldo acumulado até esta data
            dayBalance = this.calculateDayBalanceForCustomPeriod(dateForHeader, this.customDateStart, this.customDateEnd, this.selectedFilterAccount);
        } else {
            // Para filtro mensal, usar a lógica original
            dayBalance = this.calculateDayBalance(parseInt(dayKey), this.currentMonth, this.currentYear, this.selectedFilterAccount);
        }

        html += `<div class="transaction-day">
                   <div class="day-header">
                     <div class="day-date">${this.formatDate(dateForHeader)}</div>
                     <div class="day-balance ${dayBalance < 0 ? 'negative' : ''}">R$ ${this.formatCurrency(dayBalance)}</div>
                   </div>
                   <div class="day-transactions">`;
        dayItems.forEach(item => {
            if (item.type === 'invoice_group') {
                html += this.renderCardInvoiceGroup(item.data, true); 
            } else if (item.type === 'initial_balance') {
                // Renderiza o item de saldo inicial usando o novo método
                html += this.renderInitialBalanceItem(item);
            } else {
                html += this.renderTransactionItem(item);
            }
        });
        html += `</div></div>`;
    });

    transactionsListContainer.innerHTML = html;
    this.attachTransactionEventListeners();
}
            
            renderCardInvoiceGroup(invoiceGroupData, isTransactionsView = false) {
                const { cardDetails, transactions, totalAmount, isPaid } = invoiceGroupData; 
                
                // Determinar mês e ano da fatura baseado nas transações
                let invoiceMonth, invoiceYear;
                if (transactions.length > 0) {
                    // Usar o mês/ano da primeira transação de cartão para criar o ID único
                    const firstCardTransaction = transactions.find(t => t.type === 'card');
                    if (firstCardTransaction) {
                        invoiceMonth = firstCardTransaction.invoiceMonth;
                        invoiceYear = firstCardTransaction.invoiceYear;
                    } else {
                        invoiceMonth = this.currentMonth;
                        invoiceYear = this.currentYear;
                    }
                } else {
                    invoiceMonth = this.currentMonth;
                    invoiceYear = this.currentYear;
                }
                
                // Para período personalizado, incluir mês e ano específicos no ID
                const groupId = this.customDateFilterEnabled ? 
                    `invoice-${cardDetails.id}-${invoiceMonth}-${invoiceYear}` :
                    `invoice-${cardDetails.id}-${this.currentMonth}-${this.currentYear}`;
                
                const groupClasses = ['card-bill-group']; 
                if (this.isPreviewMode && !isPaid) { 
                    groupClasses.push('invoice-group-pending-preview'); 
                }
            
                transactions.sort((a, b) => this.parseDate(a.date) - this.parseDate(b.date));
                let transactionsHtml = '<div class="no-data" style="padding:10px 0;"><p style="font-size:0.85em;">Nenhuma compra nesta fatura.</p></div>'; 
                if (transactions.length > 0) { 
                    transactionsHtml = transactions.map(t => this.renderTransactionItem(t, true)).join(''); 
                }
            
                if (isTransactionsView && (isPaid || !this.isPreviewMode)) { 
                    return ''; 
                }
            
                const statusTag = isPaid ? '<span class="status-tag status-paid"><i class="fas fa-check-circle"></i> Paga</span>' : ''; 
                const accountLinked = this.data.accounts.find(a => a.id === cardDetails.account);
                
                let actionButtonsHtml = ''; 
                if (!isTransactionsView) { 
                    if (!isPaid) { 
                        actionButtonsHtml = `<button class="btn btn-sm btn-secondary pay-card-bill" data-card="${cardDetails.id}" data-month="${this.currentMonth}" data-year="${this.currentYear}" title="Pagar Fatura"><i class="fas fa-money-bill-wave"></i> Pagar</button>`; 
                    } else { 
                        actionButtonsHtml = `<button class="btn btn-sm btn-warning reopen-card-bill" data-card="${cardDetails.id}" data-month="${this.currentMonth}" data-year="${this.currentYear}" title="Reabrir Fatura"><i class="fas fa-undo"></i> Reabrir</button>`; 
                    } 
                }
            
                return `
                    <div class="${groupClasses.join(' ')}" id="${groupId}">
                        <div class="card-bill-header" data-group-id="${groupId}">
                            <div class="transaction-info">
                                <div class="transaction-icon card-invoice-group-icon"><i class="fas fa-credit-card"></i></div>
                                <div class="transaction-details">
                                    <div class="transaction-name">Fatura ${cardDetails.name} (*${cardDetails.lastDigits}) ${statusTag}</div>
                                    <div class="transaction-category">Vencimento: Dia ${cardDetails.dueDay} ${accountLinked ? `| Conta Padrão: ${accountLinked.name}` : ''}</div>
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <div class="transaction-amount expense-amount">R$ ${this.formatCurrency(totalAmount)}</div>
                                <div class="transaction-actions">
                                    ${actionButtonsHtml}
                                    <button class="action-btn card-bill-icon-toggle" title="Expandir/Recolher"><i class="fas fa-chevron-down"></i></button>
                                </div>
                            </div>
                        </div>
                        <div class="card-bill-body">
                            <div class="card-bill-content">${transactionsHtml}</div>
                        </div>
                    </div>`;
            }

            /**
            * Calcula o saldo final de um dia específico dentro do mês corrente.
            * @param {number} day - O dia do mês (1-31).
            * @param {number} month - O mês (0-11).
            * @param {number} year - O ano.
            * @param {string} filterAccountId - ID da conta para filtrar, ou 'all'.
            * @returns {number} - O saldo no final do dia especificado.
            */
            calculateDayBalance(day, month, year, filterAccountId) {
    const monthData = this.getMonthData(month, year, filterAccountId);
    let dailyBalance = monthData.transactionsInitialBalance; 

    const regularTransactionsInMonthUpToDay = this.data.transactions.filter(t => {
        if (t.type === 'card') return false; 
        const date = this.parseDate(t.date);
        return !isNaN(date.getTime()) && 
               date.getMonth() === month && 
               date.getFullYear() === year && 
               date.getDate() <= day;
    }).sort((a,b) => this.parseDate(a.date) - this.parseDate(b.date));

    regularTransactionsInMonthUpToDay.forEach(t => {
        const belongsToCurrentAccountFilter = (filterAccountId === 'all' || this.transactionBelongsToAccount(t, filterAccountId));

        if (this.isPreviewMode) { 
            if (!belongsToCurrentAccountFilter && t.type !== 'transfer') {
                if(t.type === 'transfer' && (t.sourceAccount === filterAccountId || t.destAccount === filterAccountId || filterAccountId === 'all')) {
                } else if (!belongsToCurrentAccountFilter) {
                    return;
                }
            }
            
            if (t.type === 'income') {
                if (filterAccountId === 'all' || t.account === filterAccountId) {
                    dailyBalance += t.amount;
                }
            } else if (t.type === 'expense') {
                if (filterAccountId === 'all' || t.account === filterAccountId) {
                    dailyBalance -= t.amount;
                }
            } else if (t.type === 'transfer') {
                if (filterAccountId === 'all') { /* Transferências são neutras para "todas as contas" no saldo total */ }
                else if (t.sourceAccount === filterAccountId) dailyBalance -= t.amount;
                else if (t.destAccount === filterAccountId) dailyBalance += t.amount;
            }
        } else { 
            if (!t.completed) return; 
            if (!belongsToCurrentAccountFilter && t.type !== 'transfer') {
                 if(t.type === 'transfer' && (t.sourceAccount === filterAccountId || t.destAccount === filterAccountId || filterAccountId === 'all')) {
                } else if (!belongsToCurrentAccountFilter){
                    return;
                }
            }

            if (t.type === 'income') {
                 if (filterAccountId === 'all' || t.account === filterAccountId) {
                    dailyBalance += t.amount;
                }
            } else if (t.type === 'expense') { 
                if (filterAccountId === 'all' || t.account === filterAccountId) {
                    dailyBalance -= t.amount;
                }
            } else if (t.type === 'transfer') {
                if (filterAccountId === 'all') { /* Neutro */ }
                else if (t.sourceAccount === filterAccountId) dailyBalance -= t.amount;
                else if (t.destAccount === filterAccountId) dailyBalance += t.amount;
            }
        }
    });

    if (this.isPreviewMode) {
    const cardTransactions = this.data.transactions.filter(t => {
        return t.type === 'card' && 
               t.invoiceMonth === month && 
               t.invoiceYear === year;
    });

        const cardGroups = {};
        cardTransactions.forEach(t => {
            if (!cardGroups[t.card]) {
                cardGroups[t.card] = [];
            }
            cardGroups[t.card].push(t);
        });

        for (const cardId in cardGroups) {
            const cardDetails = this.data.cards.find(c => c.id === cardId);
            if (!cardDetails) continue;
            
            if (this.isCardInvoicePaid(cardId, month, year)) continue;
            
            const dueDate = this.getCardDueDate(cardId, month, year);
            
            if (dueDate.getDate() <= day) {
                const cardTotal = cardGroups[cardId].reduce((sum, t) => sum + t.amount, 0);
                
                if (filterAccountId === 'all' || cardDetails.account === filterAccountId) {
                    dailyBalance -= cardTotal;
                }
            }
        }
    }

    return dailyBalance;
}

            calculateDayBalanceForCustomPeriod(targetDate, periodStart, periodEnd, filterAccountId) {
                const periodData = this.getCustomPeriodData(periodStart, periodEnd, filterAccountId);
                let dailyBalance = periodData.transactionsInitialBalance;

                // Filtrar transações até a data alvo dentro do período
                const transactionsUpToDate = periodData.transactionsInPeriod.filter(t => {
                    let transactionDate;
                    if (t.type === 'card') {
                        const cardDetails = this.data.cards.find(c => c.id === t.card);
                        if (cardDetails) {
                            transactionDate = this.getCardDueDate(t.card, t.invoiceMonth, t.invoiceYear);
                        } else {
                            return false;
                        }
                    } else {
                        transactionDate = this.parseDate(t.date);
                    }
                    
                    return transactionDate <= targetDate;
                }).sort((a, b) => {
                    const dateA = a.type === 'card' ? this.getCardDueDate(a.card, a.invoiceMonth, a.invoiceYear) : this.parseDate(a.date);
                    const dateB = b.type === 'card' ? this.getCardDueDate(b.card, b.invoiceMonth, b.invoiceYear) : this.parseDate(b.date);
                    return dateA - dateB;
                });

                transactionsUpToDate.forEach(t => {
                    const belongsToCurrentAccountFilter = (filterAccountId === 'all' || this.transactionBelongsToAccount(t, filterAccountId));

                    if (this.isPreviewMode) {
                        if (t.type === 'income') {
                            if (filterAccountId === 'all' || t.account === filterAccountId) {
                                dailyBalance += t.amount;
                            }
                        } else if (t.type === 'expense') {
                            if (filterAccountId === 'all' || t.account === filterAccountId) {
                                dailyBalance -= t.amount;
                            }
                        } else if (t.type === 'transfer') {
                            if (filterAccountId === 'all') { /* Transferências são neutras para "todas as contas" no saldo total */ }
                            else if (t.sourceAccount === filterAccountId) dailyBalance -= t.amount;
                            else if (t.destAccount === filterAccountId) dailyBalance += t.amount;
                        } else if (t.type === 'card') {
                            const cardDetails = this.data.cards.find(c => c.id === t.card);
                            if (cardDetails && (filterAccountId === 'all' || cardDetails.account === filterAccountId)) {
                                dailyBalance -= t.amount;
                            }
                        }
                    } else {
                        if (!t.completed && t.type !== 'card') return;

                        if (t.type === 'income') {
                            if (filterAccountId === 'all' || t.account === filterAccountId) {
                                dailyBalance += t.amount;
                            }
                        } else if (t.type === 'expense') {
                            if (filterAccountId === 'all' || t.account === filterAccountId) {
                                dailyBalance -= t.amount;
                            }
                        } else if (t.type === 'transfer') {
                            if (filterAccountId === 'all') { /* Neutro */ }
                            else if (t.sourceAccount === filterAccountId) dailyBalance -= t.amount;
                            else if (t.destAccount === filterAccountId) dailyBalance += t.amount;
                        } else if (t.type === 'card') {
                            // Para período personalizado, sempre considerar transações de cartão como incluídas se estão no período
                            const cardDetails = this.data.cards.find(c => c.id === t.card);
                            if (cardDetails && (filterAccountId === 'all' || cardDetails.account === filterAccountId)) {
                                dailyBalance -= t.amount;
                            }
                        }
                    }
                });

                return dailyBalance;
            }
            renderTransactionItem(transaction, isCardTransactionInGroup = false) {
                let icon, iconClass, amountClass;
                if (transaction.type === 'income') { 
                    icon = 'fas fa-arrow-down'; 
                    iconClass = 'income-icon'; 
                    amountClass = 'income-amount'; 
                } else if (transaction.type === 'expense') { 
                    icon = 'fas fa-arrow-up'; 
                    iconClass = 'expense-icon'; 
                    amountClass = 'expense-amount'; 
                } else if (transaction.type === 'transfer') { 
                    icon = 'fas fa-exchange-alt'; 
                    iconClass = 'transfer-icon'; 
                    amountClass = ''; 
                } else if (transaction.type === 'card') { 
                    icon = isCardTransactionInGroup ? 'fas fa-shopping-cart' : 'fas fa-credit-card'; 
                    iconClass = 'card-expense-icon'; 
                    amountClass = 'expense-amount'; 
                }
                let categoryOrAccountText = '';
                if (transaction.type === 'income' || transaction.type === 'expense') { 
                    const category = this.data.categories[transaction.type]?.find(c => c.id === transaction.category); 
                    if (category) categoryOrAccountText = category.name; 
                    const account = this.data.accounts.find(a => a.id === transaction.account); 
                    if (account) categoryOrAccountText += ` (${account.name})`; 
                } else if (transaction.type === 'transfer') { 
                    const sourceAccount = this.data.accounts.find(a => a.id === transaction.sourceAccount); 
                    const destAccount = this.data.accounts.find(a => a.id === transaction.destAccount); 
                    if (sourceAccount && destAccount) categoryOrAccountText = `${sourceAccount.name} → ${destAccount.name}`; 
                } else if (transaction.type === 'card') { 
                    const card = this.data.cards.find(c => c.id === transaction.card); 
                    if (card) categoryOrAccountText = `Cartão ${card.name} (*${card.lastDigits})`; 
                    if (transaction.category) { 
                        const expenseCategory = this.data.categories.expense.find(c => c.id === transaction.category); 
                        if (expenseCategory) categoryOrAccountText += ` - ${expenseCategory.name}`; 
                    } 
                }
                let installmentInfo = ''; 
                if (transaction.recurring && transaction.recurringType === 'installment') { 
                    installmentInfo = ` (${transaction.currentInstallment}/${transaction.totalInstallments})`; 
                }
                
                const itemClasses = ['transaction-item']; 
                let previstoBadge = '';

                if (transaction.type === 'card') {
                } else { 
                    if (!transaction.completed && this.isPreviewMode) { 
                        itemClasses.push('opacity-50'); 
                        previstoBadge = ' <span style="font-size: 0.7rem; background-color: var(--warning-color); color: white; padding: 2px 5px; border-radius: 4px;">Previsto</span>'; 
                    }
                }

                const showCompletedToggle = transaction.type !== 'card'; 

                return `
                    <div class="${itemClasses.join(' ')}">
                        <div class="transaction-info">
                            <div class="transaction-icon ${iconClass}"><i class="${icon}"></i></div>
                            <div class="transaction-details">
                                <div class="transaction-name">${transaction.description}${installmentInfo}${previstoBadge}</div>
                                <div class="transaction-category">${categoryOrAccountText}</div>
                            </div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 15px;">
                            <div class="transaction-amount ${amountClass}">R$ ${this.formatCurrency(transaction.amount)}</div>
                            <div class="transaction-actions">
                                ${showCompletedToggle ? `<label class="toggle-completed" title="${this.PLAN_CONFIG === 'basico' ? 'Clique para fazer upgrade e controlar transações realizadas' : (transaction.completed ? 'Marcar como não realizada' : 'Marcar como realizada')}"><input type="checkbox" class="toggle-completed-input" data-id="${transaction.id}" ${this.PLAN_CONFIG === 'basico' ? 'checked' : (transaction.completed ? 'checked' : '')}><span class="toggle-completed-slider"></span></label>` : ''}
                                <button class="action-btn edit-btn" data-id="${transaction.id}" title="Editar"><i class="fas fa-edit"></i></button>
                                <button class="action-btn delete-btn" data-id="${transaction.id}" title="Excluir"><i class="fas fa-trash"></i></button>
                            </div>
                        </div>
                    </div>`;
            }
renderInitialBalanceItem(item) {
    const isPositive = item.amount >= 0;
    return `
        <div class="transaction-item ${this.isPreviewMode ? 'opacity-50' : ''}">
            <div class="transaction-info">
                <div class="transaction-icon" style="background-color: #6366f120; color: #6366f1"><i class="fas fa-wallet"></i></div>
                <div class="transaction-details">
                    <div class="transaction-name">${item.description}</div>
                    <div class="transaction-category">Saldo transferido do mês anterior</div>
                </div>
            </div>
            <div class="transaction-amount ${isPositive ? 'income-amount' : 'expense-amount'}">R$ ${this.formatCurrency(item.amount)}</div>
        </div>`;
}
            refreshTransactionsList() { 
                this.renderTransactionsList(); 
            }

            refreshMonthlyStats(pagePrefix, monthDataOverride = null) {
                const filterAccountId = this.hasActiveTransactionFilters() ? this.getEffectiveAccountFilter() : this.selectedFilterAccount;
                const monthData = monthDataOverride || (this.customDateFilterEnabled ? 
                    this.getCustomPeriodData(this.customDateStart, this.customDateEnd, filterAccountId) :
                    this.getMonthData(this.currentMonth, this.currentYear, filterAccountId)); 
                const prefixCapitalized = this.capitalizeFirstLetter(pagePrefix); 
            
                let initialBalance, income, expense, finalBalance;
            
                // Usar os mesmos valores filtrados para dashboard e transações
                initialBalance = monthData.dashboardInitialBalance;
                income = monthData.dashboardIncome;
                expense = monthData.dashboardExpense;
                finalBalance = monthData.dashboardFinalBalance;
            
                const initialBalanceEl = document.getElementById(`${pagePrefix}InitialBalance`); 
                const incomeEl = document.getElementById(`${pagePrefix}Income`); 
                const expenseEl = document.getElementById(`${pagePrefix}Expense`); 
                const finalBalanceEl = document.getElementById(`${pagePrefix}FinalBalance`); 
                const currentMonthDisplayEl = document.getElementById(`currentMonthDisplay${prefixCapitalized}`);
            
                if (initialBalanceEl) {
                    initialBalanceEl.textContent = `R$ ${this.formatCurrency(initialBalance)}`;
                    initialBalanceEl.className = `stat-value ${initialBalance >= 0 ? 'stat-positive' : 'stat-negative'}`;
                } 
                if (incomeEl) incomeEl.textContent = `R$ ${this.formatCurrency(income)}`; 
                if (expenseEl) expenseEl.textContent = `R$ ${this.formatCurrency(expense)}`; 
                if (finalBalanceEl) { 
                    finalBalanceEl.textContent = `R$ ${this.formatCurrency(finalBalance)}`; 
                    finalBalanceEl.className = `stat-value ${finalBalance >= 0 ? 'stat-positive' : 'stat-negative'}`; 
                }
                if (currentMonthDisplayEl && !this.customDateFilterEnabled) { 
                    currentMonthDisplayEl.textContent = `${this.getMonthName(this.currentMonth)} de ${this.currentYear}`; 
                }
            
                if (pagePrefix === 'dashboard') { 
                    const categoryProgressContainer = document.getElementById('categoryProgressDashboard'); 
                    if (categoryProgressContainer) categoryProgressContainer.innerHTML = this.renderCategoryProgress(monthData.categories); 
                    
                    const accountsListContainer = document.getElementById('accountsListDashboard'); 
                    if (accountsListContainer) accountsListContainer.innerHTML = this.renderAccountsListDashboard(monthData.accounts); 
                    
                    if (this.isFeatureAvailable('cards')) { 
                        const cardsListContainer = document.getElementById('cardsListDashboard'); 
                        if (cardsListContainer) cardsListContainer.innerHTML = this.renderCardsListDashboard(monthData.cards); 
                    } 
                    if (this.isFeatureAvailable('dashboard_advanced')) { 
                        this.renderIncomeExpenseChart(); 
                        this.renderFutureIncomeExpenseChart();
                        this.renderCategoryChart(monthData); 
                        this.renderIncomeCategoryChart(monthData);
                    } 
                }
            }
            
            attachTransactionEventListeners() {
                const transactionListContainer = document.getElementById('transactionsListContainer'); 
                if (!transactionListContainer) return;

                transactionListContainer.addEventListener('click', (event) => { 
                    const target = event.target; 
                    const toggleInput = target.closest('.toggle-completed-input'); 
                    const editBtn = target.closest('.edit-btn'); 
                    const deleteBtn = target.closest('.delete-btn'); 
                    const cardBillHeader = target.closest('.card-bill-header'); 
                    
                    if (toggleInput) { 
                        this.toggleTransactionCompleted(toggleInput.getAttribute('data-id'), toggleInput.checked); 
                    } else if (editBtn) { 
                        this.editTransaction(editBtn.getAttribute('data-id')); 
                    } else if (deleteBtn) { 
                        if (confirm('Tem certeza que deseja excluir esta transação?')) { 
                            this.deleteTransaction(deleteBtn.getAttribute('data-id')); 
                        } 
                    } else if (cardBillHeader) { 
                        const groupId = cardBillHeader.getAttribute('data-group-id'); 
                        const groupElement = document.getElementById(groupId); 
                        if (groupElement) { 
                            const body = groupElement.querySelector('.card-bill-body'); 
                            const iconToggle = cardBillHeader.querySelector('.card-bill-icon-toggle'); 
                            cardBillHeader.classList.toggle('active'); 
                            if (body) body.classList.toggle('active'); 
                            if (iconToggle) iconToggle.classList.toggle('active'); 
                        } 
                    }
                });
            }

            toggleTransactionCompleted(id, isCompleted) {
                if (this.PLAN_CONFIG === 'basico') {
                    this.showUpgradeModal('transaction_completed');
                    const checkbox = document.querySelector(`.toggle-completed-input[data-id="${id}"]`);
                    if (checkbox) checkbox.checked = true; 
                    return;
                }
                
                const transaction = this.data.transactions.find(t => t.id === id);
                if (!transaction) return;
            
                if (transaction.type === 'card') {
                    this.notificationSystem.show('Aviso', 'O status de transações de cartão é definido pelo pagamento da fatura.', 'warning');
                    const checkbox = document.querySelector(`.toggle-completed-input[data-id="${id}"]`);
                    if (checkbox) checkbox.checked = !isCompleted; 
                    return;
                }
            
                if (isCompleted) {
                    let accountToCheckId = null;
                    if (transaction.type === 'expense') {
                        accountToCheckId = transaction.account;
                    } else if (transaction.type === 'transfer') {
                        accountToCheckId = transaction.sourceAccount;
                    }
            
                    if (accountToCheckId) {
                    }
                }
            
                transaction.completed = isCompleted;
                this.saveData();
                this.refreshView(); 
                this.notificationSystem.show('Sucesso', `Transação ${isCompleted ? 'marcada' : 'desmarcada'} como realizada!`, 'success');
            }

            showPayCardBillModal(cardId, month, year) {
    const card = this.data.cards.find(c => c.id === cardId); 
    if (!card) return;

    const transactionsInInvoice = this.data.transactions.filter(t => 
        t.type === 'card' && t.card === cardId && 
        t.invoiceMonth === month && t.invoiceYear === year
    ); 
    const totalAmount = transactionsInInvoice.reduce((sum, t) => sum + t.amount, 0);

    if (this.isCardInvoicePaid(cardId, month, year)) { 
        this.notificationSystem.show('Informação', 'Esta fatura já foi marcada como paga.', 'info'); 
        return; 
    }
    if (totalAmount <= 0 && transactionsInInvoice.length === 0) {
         this.notificationSystem.show('Informação', 'Fatura sem lançamentos para pagamento.', 'info'); 
        return; 
    }

    const accountOptions = this.data.accounts.map(account => 
        `<option value="${account.id}" ${account.id === card.account ? 'selected' : ''}>${account.name}</option>`
    ).join('');

    const modalContentEl = document.getElementById('modalContent'); 
    modalContentEl.innerHTML = `
        <div class="modal-header"><h3 class="modal-title">Pagar Fatura do Cartão ${card.name}</h3><button class="modal-close" id="modalClosePayBill">&times;</button></div>
        <div class="modal-body">
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 5px;">Valor Total da Fatura (${this.getMonthName(month)}/${year})</div>
                <div style="font-size: 1.5rem; font-weight: 700; color: var(--danger-color);">R$ ${this.formatCurrency(totalAmount)}</div>
            </div>
            <div class="form-row"><label class="form-label" for="paymentAmount">Valor a Pagar</label><input type="text" class="form-input" id="paymentAmount" placeholder="0,00" value="${this.formatValueForEdit(totalAmount)}"></div>
            <div class="form-row"><label class="form-label" for="paymentAccount">Conta para Débito</label><select class="form-select" id="paymentAccount">${accountOptions}</select></div>
            <div class="form-row"><label class="form-label" for="paymentDate">Data do Pagamento</label><input type="date" class="form-input" id="paymentDate" value="${this.formatInputDate(new Date())}"></div>
            <!-- Campos ocultos - removidos do UI mas mantidos como valores no processamento -->
            <input type="hidden" id="paymentCompleted" value="true">
            <input type="hidden" id="useOriginalCategories" value="true">
        </div>
        <div class="form-footer"><button class="btn btn-outlined" id="cancelPayBillBtn">Cancelar</button><button class="btn btn-primary" id="confirmPayBillBtn">Pagar Fatura</button></div>`;
    
    document.getElementById('modalOverlay').classList.add('active');
    this.setupCurrencyMask('paymentAmount');
    document.getElementById('modalClosePayBill').addEventListener('click', () => this.closeModal()); 
    document.getElementById('cancelPayBillBtn').addEventListener('click', () => this.closeModal());

    document.getElementById('confirmPayBillBtn').addEventListener('click', () => { 
        const paymentAmount = this.parseValueInput(document.getElementById('paymentAmount').value); 
        const accountId = document.getElementById('paymentAccount').value; 
        const paymentDateStr = document.getElementById('paymentDate').value; 
        // Valores sempre true, sem depender de checkbox
        const completed = true;
        const useOriginalCategories = true;

        if (isNaN(paymentAmount) || paymentAmount < 0) { 
            this.notificationSystem.show('Erro', 'Informe um valor válido para pagamento!', 'error'); 
            return; 
        } 
        if (!accountId) { 
            this.notificationSystem.show('Erro', 'Selecione uma conta para débito!', 'error'); 
            return; 
        } 
        if (!paymentDateStr) { 
            this.notificationSystem.show('Erro', 'Informe a data do pagamento!', 'error'); 
            return; 
        } 
        
        const paymentDateForBalanceCheck = this.adjustDateForTimezone(this.parseDate(paymentDateStr));



        const paymentDate = this.adjustDateForTimezone(this.parseDate(paymentDateStr));
        const paymentTransactionIds = [];

        // Como useOriginalCategories é sempre true, sempre entramos nesse fluxo
        if (transactionsInInvoice.length > 0) {
            const categoryDistribution = {};
            transactionsInInvoice.forEach(t => {
                if (t.category) {
                    if (!categoryDistribution[t.category]) {
                        categoryDistribution[t.category] = 0;
                    }
                    categoryDistribution[t.category] += t.amount;
                } else {
                    const noCategory = "sem_categoria";
                    if (!categoryDistribution[noCategory]) {
                        categoryDistribution[noCategory] = 0;
                    }
                    categoryDistribution[noCategory] += t.amount;
                }
            });
            
            for (const categoryKey in categoryDistribution) {
                const categoryAmount = categoryDistribution[categoryKey];
                const proportion = categoryAmount / totalAmount; 
                const paymentForCategory = parseFloat((proportion * paymentAmount).toFixed(2)); 
                
                const paymentTransactionId = this.generateId();
                paymentTransactionIds.push(paymentTransactionId);
                
                let categoryName = "sem categoria";
                let categoryId = null;
                
                if (categoryKey !== "sem_categoria") {
                    const category = this.data.categories.expense.find(c => c.id === categoryKey);
                    if (category) {
                        categoryName = category.name;
                        categoryId = category.id;
                    }
                }
                
                const paymentDescription = `Pagamento Fatura ${card.name} - ${categoryName} (${this.getMonthName(month)}/${year})`;
                
                const paymentTransaction = {
                    id: paymentTransactionId,
                    type: 'expense',
                    description: paymentDescription,
                    amount: paymentForCategory,
                    date: paymentDate.toISOString(),
                    category: categoryId, 
                    account: accountId,
                    completed: completed,
                    recurring: false,
                    isInvoicePayment: true,
                    originalInvoiceDetails: { cardId, month, year, totalAmount, categoryId }
                };
                
                this.data.transactions.push(paymentTransaction);
            }
        } else {
            // Esse bloco ainda é necessário para quando não houver transações na fatura
            const paymentTransactionId = this.generateId();
            paymentTransactionIds.push(paymentTransactionId);
            const paymentDescription = `Pagamento Fatura ${card.name} (${this.getMonthName(month)}/${year})`;
            
            const paymentTransaction = {
                id: paymentTransactionId,
                type: 'expense',
                description: paymentDescription,
                amount: paymentAmount,
                date: paymentDate.toISOString(),
                category: null, 
                account: accountId,
                completed: completed,
                recurring: false,
                isInvoicePayment: true,
                originalInvoiceDetails: { cardId, month, year, totalAmount }
            };
            this.data.transactions.push(paymentTransaction);
        }

        let carriedOverBalanceTransactionId = null;
        if (paymentAmount < totalAmount) {
            const remainingBalance = totalAmount - paymentAmount;
            let nextInvoiceMonth = month + 1;
            let nextInvoiceYear = year;
            if (nextInvoiceMonth > 11) {
                nextInvoiceMonth = 0;
                nextInvoiceYear++;
            }
            carriedOverBalanceTransactionId = this.generateId();
            const remainingTransaction = {
                id: carriedOverBalanceTransactionId,
                type: 'card',
                description: `Saldo remanescente fatura ${this.getMonthName(month)}/${year} - ${card.name}`,
                amount: remainingBalance,
                card: cardId,
                date: this.adjustDateForTimezone(new Date(nextInvoiceYear, nextInvoiceMonth, 1)).toISOString(),
                invoiceMonth: nextInvoiceMonth,
                invoiceYear: nextInvoiceYear,
                completed: false,
                category: null,
                isCarriedOverBalance: true,
                originalInvoiceDetails: { cardId, month, year, generatingPaymentId: paymentTransactionIds.join(',') }
            };
            this.data.transactions.push(remainingTransaction);
            this.notificationSystem.show('Aviso', `Saldo remanescente de R$ ${this.formatCurrency(remainingBalance)} lançado para a próxima fatura.`, 'info', 7000);
        }
        
        this.markCardInvoiceAsPaid(cardId, month, year, paymentTransactionIds.join(','), carriedOverBalanceTransactionId);
        this.saveData();
        this.closeModal();
        this.refreshView();
        this.notificationSystem.show('Sucesso', 'Pagamento de fatura registrado com sucesso!', 'success');
    });
}

            editTransaction(id) {
                const transaction = this.data.transactions.find(t => t.id === id); 
                if (transaction) { 
                    if (transaction.isInvoicePayment || transaction.isCarriedOverBalance) { 
                        this.notificationSystem.show('Aviso', 'Pagamentos de fatura e saldos remanescentes não podem ser editados diretamente. Reabra a fatura original para modificar.', 'warning', 7000); 
                        return; 
                    } 
                    this.showTransactionModal(transaction); 
                }
            }

            deleteTransaction(id) {
                const transaction = this.data.transactions.find(t => t.id === id); 
                if (transaction) { 
                    if (transaction.isInvoicePayment || transaction.isCarriedOverBalance) { 
                        this.notificationSystem.show('Aviso', 'Pagamentos de fatura e saldos remanescentes não podem ser excluídos diretamente. Reabra a fatura original para remover.', 'warning', 7000); 
                        return; 
                    } 
                    if (transaction.recurring && transaction.recurringType === 'installment' && transaction.currentInstallment < transaction.totalInstallments) { 
                        const deleteAll = confirm('Esta é uma transação parcelada. Deseja excluir esta e todas as parcelas futuras também? "Cancelar" exclui apenas esta parcela.'); 
                        if (deleteAll) { 
                            this.data.transactions = this.data.transactions.filter(t => !(t.recurringGroupId === transaction.recurringGroupId && t.currentInstallment >= transaction.currentInstallment)); 
                        } else { 
                            this.data.transactions = this.data.transactions.filter(t => t.id !== id); 
                        } 
                    } else if (transaction.recurring && transaction.recurringType === 'fixed') {
                        const deleteFutureFixed = confirm('Esta é uma transação fixa. Deseja excluir esta e todas as ocorrências futuras também (se houver)? "Cancelar" exclui apenas esta ocorrência.');
                        if (deleteFutureFixed) {
                             this.data.transactions = this.data.transactions.filter(t => !(t.recurringGroupId === transaction.recurringGroupId && this.parseDate(t.date) >= this.parseDate(transaction.date) ));
                        } else {
                            this.data.transactions = this.data.transactions.filter(t => t.id !== id);
                        }
                    }
                    else { 
                        this.data.transactions = this.data.transactions.filter(t => t.id !== id); 
                    } 
                    this.saveData(); 
                    this.refreshView(); 
                    this.notificationSystem.show('Sucesso', 'Transação excluída com sucesso!', 'success'); 
                }
            }

            calculateInitialBalanceForMonth(month, year, specificAccountId = null) {
                const targetAccounts = specificAccountId 
                    ? this.data.accounts.filter(acc => acc.id === specificAccountId)
                    : this.data.accounts;

                if (targetAccounts.length === 0 && specificAccountId) return 0; 
                if (targetAccounts.length === 0 && !specificAccountId) return {}; 

                const registeredInitialBalances = {};
                targetAccounts.forEach(account => {
                    registeredInitialBalances[account.id] = account.initialBalance;
                });

                if (!this.usePreviousMonthBalance) {
                    if (specificAccountId) {
                        return registeredInitialBalances[specificAccountId] || 0;
                    }
                    return registeredInitialBalances;
                }

                let calculatedPreviousMonthEndBalances = {};
                this.data.accounts.forEach(acc => { 
                    calculatedPreviousMonthEndBalances[acc.id] = acc.initialBalance;
                });
                
                const firstDayOfCurrentMonth = new Date(year, month, 1, 0, 0, 0, 0);

                const transactionsBeforeThisMonth = this.data.transactions.filter(t => {
                    const date = this.parseDate(t.date);
                    return !isNaN(date.getTime()) && date < firstDayOfCurrentMonth;
                }).sort((a, b) => this.parseDate(a.date) - this.parseDate(b.date));

                transactionsBeforeThisMonth.forEach(t => {
                    if (this.isPreviewMode) { 
                        if (t.type === 'income') {
                            if (calculatedPreviousMonthEndBalances[t.account] !== undefined) calculatedPreviousMonthEndBalances[t.account] += t.amount;
                        } else if (t.type === 'expense') {
                            if (calculatedPreviousMonthEndBalances[t.account] !== undefined) calculatedPreviousMonthEndBalances[t.account] -= t.amount;
                        } else if (t.type === 'transfer') {
                            if (calculatedPreviousMonthEndBalances[t.sourceAccount] !== undefined) calculatedPreviousMonthEndBalances[t.sourceAccount] -= t.amount;
                            if (calculatedPreviousMonthEndBalances[t.destAccount] !== undefined) calculatedPreviousMonthEndBalances[t.destAccount] += t.amount;
                        } else if (t.type === 'card') {
                            const cardDetails = this.data.cards.find(c => c.id === t.card);
                            if (cardDetails && calculatedPreviousMonthEndBalances[cardDetails.account] !== undefined &&
                                !this.isCardInvoicePaid(t.card, t.invoiceMonth, t.invoiceYear)) {
                                calculatedPreviousMonthEndBalances[cardDetails.account] -= t.amount;
                            }
                        }
                    } else {
                        if (t.completed) {
                            if (t.type === 'income') {
                                if (calculatedPreviousMonthEndBalances[t.account] !== undefined) calculatedPreviousMonthEndBalances[t.account] += t.amount;
                            } else if (t.type === 'expense') {
                                if (calculatedPreviousMonthEndBalances[t.account] !== undefined) calculatedPreviousMonthEndBalances[t.account] -= t.amount;
                            } else if (t.type === 'transfer') {
                                if (calculatedPreviousMonthEndBalances[t.sourceAccount] !== undefined) calculatedPreviousMonthEndBalances[t.sourceAccount] -= t.amount;
                                if (calculatedPreviousMonthEndBalances[t.destAccount] !== undefined) calculatedPreviousMonthEndBalances[t.destAccount] += t.amount;
                            }
                        }
                    }
                });
                
                if (specificAccountId) {
                    return calculatedPreviousMonthEndBalances[specificAccountId] || 0;
                } else {
                    const finalBalancesForTarget = {};
                     targetAccounts.forEach(acc => {
                        finalBalancesForTarget[acc.id] = calculatedPreviousMonthEndBalances[acc.id] || 0;
                    });
                    return finalBalancesForTarget;
                }
            }
            
            transactionBelongsToAccount(transaction, accountId) {
                if (accountId === 'all') return true;
                
                switch (transaction.type) {
                    case 'income':
                    case 'expense':
                        return transaction.account === accountId;
                    case 'transfer':
                        return transaction.sourceAccount === accountId || transaction.destAccount === accountId;
                    case 'card':
                        const card = this.data.cards.find(c => c.id === transaction.card);
                        return card && card.account === accountId;
                    default:
                        return false;
                }
            }

            hasActiveTransactionFilters() {
                return this.transactionFilters.type !== 'all' || 
                       this.transactionFilters.category !== 'all' || 
                       this.transactionFilters.account !== 'all';
            }

            getEffectiveAccountFilter() {
                return this.transactionFilters.account !== 'all' ? this.transactionFilters.account : 'all';
            }

            getMonthData(month, year, filterAccountId = 'all', startDate = null, endDate = null) {
                const result = {
                    dashboardInitialBalance: 0,
                    dashboardIncome: 0,
                    dashboardExpense: 0,
                    dashboardFinalBalance: 0,
                    transactionsInitialBalance: 0,
                    transactionsIncome: 0,
                    transactionsExpense: 0,
                    transactionsFinalBalance: 0,
                    transactionsInMonth: [],
                    categories: [], 
                    accounts: [],   
                    cards: []       
                };
            
                const initialBalancesFromPrevMonth = this.calculateInitialBalanceForMonth(month, year, null);
                
                if (this.usePreviousMonthBalance) {
                    result.dashboardInitialBalance = Object.values(initialBalancesFromPrevMonth).reduce((sum, bal) => sum + bal, 0);
                    if (filterAccountId === 'all') {
                        result.transactionsInitialBalance = result.dashboardInitialBalance;
                    } else {
                        result.transactionsInitialBalance = initialBalancesFromPrevMonth[filterAccountId] || 
                            (this.data.accounts.find(a=>a.id === filterAccountId)?.initialBalance || 0); 
                    }
                } else {
                    let sumRegisteredInitial = 0;
                    this.data.accounts.forEach(acc => sumRegisteredInitial += acc.initialBalance);
                    result.dashboardInitialBalance = sumRegisteredInitial;

                    if (filterAccountId === 'all') {
                        result.transactionsInitialBalance = sumRegisteredInitial;
                    } else {
                        const acc = this.data.accounts.find(a => a.id === filterAccountId);
                        result.transactionsInitialBalance = acc ? acc.initialBalance : 0;
                    }
                }
            
                const categoryTotals = {}; 
                this.data.categories.income.forEach(cat => categoryTotals[cat.id] = 0);
                this.data.categories.expense.forEach(cat => categoryTotals[cat.id] = 0);
            
                result.accounts = this.data.accounts.map(acc => {
                    let currentMonthInitialBalanceForAccount;
                    if (this.usePreviousMonthBalance) {
                        currentMonthInitialBalanceForAccount = initialBalancesFromPrevMonth[acc.id] || acc.initialBalance;
                    } else {
                        currentMonthInitialBalanceForAccount = acc.initialBalance;
                    }
                    return {
                        id: acc.id, name: acc.name, emoji: acc.emoji, color: acc.color,
                        initialBalance: currentMonthInitialBalanceForAccount,
                        income: 0, expense: 0,
                        finalBalance: currentMonthInitialBalanceForAccount 
                    };
                });
            
                result.cards = this.data.cards.map(card => ({
                    id: card.id, name: card.name, emoji: card.emoji, color: card.color,
                    limit: card.limit, dueDay: card.dueDay, lastDigits: card.lastDigits,
                    account: card.account, totalFaturaMes: 0
                }));
            
                result.transactionsInMonth = this.data.transactions.filter(t => {
    if (t.type === 'card') {
        // Para transações de cartão, filtrar pelo mês da fatura
        if (startDate && endDate) {
            // Se há filtro de período, verificar se a data da transação está no período
            const transactionDate = this.parseDate(t.date);
            return t.invoiceMonth === month && t.invoiceYear === year &&
                   transactionDate >= startDate && transactionDate <= endDate;
        } else {
            return t.invoiceMonth === month && t.invoiceYear === year;
        }
    } else {
        // Para outras transações, filtrar pela data normal
        const date = this.parseDate(t.date);
        if (startDate && endDate) {
            // Se há filtro de período, verificar se está no período específico
            return date.getMonth() === month && date.getFullYear() === year &&
                   date >= startDate && date <= endDate;
        } else {
            return date.getMonth() === month && date.getFullYear() === year;
        }
    }
}).sort((a,b) => this.parseDate(a.date) - this.parseDate(b.date));
            
                result.transactionsInMonth.forEach(t => {
                    const isCardTransactionForCurrentInvoice = t.type === 'card' && t.invoiceMonth === month && t.invoiceYear === year;
                    
                    // Aplicar filtros de transações
                    const passesTypeFilter = this.transactionFilters.type === 'all' || 
                        this.transactionFilters.type === t.type ||
                        (this.transactionFilters.type === 'expense' && t.type === 'card');
                    const passesCategoryFilter = this.transactionFilters.category === 'all' || this.transactionFilters.category === t.category;
                    const passesAccountFilter = this.transactionFilters.account === 'all' || 
                        this.transactionBelongsToAccount(t, this.transactionFilters.account);
                    
                    const passesAllFilters = passesTypeFilter && passesCategoryFilter && passesAccountFilter;
            
                    if (this.isPreviewMode) { 
                        // Cálculos para Dashboard (aplicando filtros quando necessário)
                        if (passesAllFilters) {
                            if (t.type === 'income') result.dashboardIncome += t.amount;
                            if (t.type === 'expense') result.dashboardExpense += t.amount;
                            if (isCardTransactionForCurrentInvoice && !this.isCardInvoicePaid(t.card, t.invoiceMonth, t.invoiceYear)) {
                                result.dashboardExpense += t.amount;
                            }
                        }
            
                        if (filterAccountId === 'all') {
                            if (passesAllFilters) {
                                if (t.type === 'income') result.transactionsIncome += t.amount;
                                if (t.type === 'expense') result.transactionsExpense += t.amount;
                                if (isCardTransactionForCurrentInvoice && !this.isCardInvoicePaid(t.card, t.invoiceMonth, t.invoiceYear)) {
                                    result.transactionsExpense += t.amount;
                                }
                            }
                        } else { 
                            if (passesAllFilters) {
                                if (t.type === 'income' && t.account === filterAccountId) result.transactionsIncome += t.amount;
                                if (t.type === 'transfer' && t.destAccount === filterAccountId) result.transactionsIncome += t.amount;
                
                                if (t.type === 'expense' && t.account === filterAccountId) result.transactionsExpense += t.amount;
                                if (t.type === 'transfer' && t.sourceAccount === filterAccountId) result.transactionsExpense += t.amount;
                                
                                if (isCardTransactionForCurrentInvoice && !this.isCardInvoicePaid(t.card, t.invoiceMonth, t.invoiceYear)) {
                                    const cardDetails = this.data.cards.find(c => c.id === t.card);
                                    if (cardDetails && cardDetails.account === filterAccountId) {
                                        result.transactionsExpense += t.amount;
                                    }
                                }
                            }
                        }
                    } else { 
                        if (t.completed) {
                            if (passesAllFilters) {
                                if (t.type === 'income') result.dashboardIncome += t.amount;
                                if (t.type === 'expense') result.dashboardExpense += t.amount; 
                            }
            
                            if (filterAccountId === 'all') {
                                if (passesAllFilters) {
                                    if (t.type === 'income') result.transactionsIncome += t.amount;
                                    if (t.type === 'expense') result.transactionsExpense += t.amount;
                                }
                            } else { 
                                if (passesAllFilters) {
                                    if (t.type === 'income' && t.account === filterAccountId) result.transactionsIncome += t.amount;
                                    if (t.type === 'transfer' && t.destAccount === filterAccountId) result.transactionsIncome += t.amount;
                                    
                                    if (t.type === 'expense' && t.account === filterAccountId) result.transactionsExpense += t.amount;
                                    if (t.type === 'transfer' && t.sourceAccount === filterAccountId) result.transactionsExpense += t.amount;
                                }
                            }
                        }
                    }
            
                    const accountToUpdate = result.accounts.find(acc => acc.id === t.account);
                    const sourceAccountToUpdate = result.accounts.find(acc => acc.id === t.sourceAccount);
                    const destAccountToUpdate = result.accounts.find(acc => acc.id === t.destAccount);
            
                    if ((this.isPreviewMode || t.completed) && passesAllFilters) {
                        if (t.type === 'income') {
                            if (accountToUpdate) {
                                accountToUpdate.income += t.amount; 
                                accountToUpdate.finalBalance += t.amount;
                            }
                            if (t.category && categoryTotals[t.category] !== undefined) categoryTotals[t.category] += t.amount;
                        } else if (t.type === 'expense') {
                            if (accountToUpdate) {
                                accountToUpdate.expense += t.amount;
                                accountToUpdate.finalBalance -= t.amount;
                            }
                            if (t.category && categoryTotals[t.category] !== undefined) categoryTotals[t.category] += t.amount;
                        } else if (t.type === 'transfer') {
                            if (sourceAccountToUpdate) sourceAccountToUpdate.finalBalance -= t.amount;
                            if (destAccountToUpdate) destAccountToUpdate.finalBalance += t.amount;
                        } else if (isCardTransactionForCurrentInvoice && this.isPreviewMode) {
                             const cardDetails = this.data.cards.find(c => c.id === t.card);
                             if (cardDetails && !this.isCardInvoicePaid(t.card, t.invoiceMonth, t.invoiceYear)) {
                                const linkedAccountForCard = result.accounts.find(acc => acc.id === cardDetails.account);
                                if (linkedAccountForCard) {
                                    linkedAccountForCard.finalBalance -= t.amount; 
                                }
                                if (t.category && categoryTotals[t.category] !== undefined) categoryTotals[t.category] += t.amount;
                             }
                        }
                    }
                    if (isCardTransactionForCurrentInvoice && passesAllFilters) {
                        const cardToUpdate = result.cards.find(c => c.id === t.card);
                        if (cardToUpdate) cardToUpdate.totalFaturaMes += t.amount;
                    }
                });
            
                result.dashboardFinalBalance = result.dashboardInitialBalance + result.dashboardIncome - result.dashboardExpense;
                result.transactionsFinalBalance = result.transactionsInitialBalance + result.transactionsIncome - result.transactionsExpense;
            
                result.categories = Object.keys(categoryTotals).map(catId => {
                    const incomeCat = this.data.categories.income.find(c => c.id === catId);
                    const expenseCat = this.data.categories.expense.find(c => c.id === catId);
                    const catDetails = incomeCat || expenseCat;
                    return {
                        id: catId,
                        name: catDetails ? catDetails.name : 'Desconhecida',
                        emoji: catDetails ? catDetails.emoji : '❓',
                        color: catDetails ? catDetails.color : '#ccc',
                        limit: expenseCat ? expenseCat.limit : null, 
                        total: categoryTotals[catId]
                    };
                });

                result.incomeCategories = Object.keys(categoryTotals).map(catId => {
                    const incomeCat = this.data.categories.income.find(c => c.id === catId);
                    if (incomeCat && categoryTotals[catId] > 0) {
                        return {
                            id: catId,
                            name: incomeCat.name,
                            emoji: incomeCat.emoji,
                            color: incomeCat.color,
                            total: categoryTotals[catId]
                        };
                    }
                    return null;
                }).filter(cat => cat !== null);
            
                return result;
            }

            getCustomPeriodData(startDateStr, endDateStr, filterAccountId = 'all') {
                const startDate = this.parseDate(startDateStr);
                const endDate = this.parseDate(endDateStr);
                
                const result = {
                    dashboardInitialBalance: 0,
                    dashboardIncome: 0,
                    dashboardExpense: 0,
                    dashboardFinalBalance: 0,
                    transactionsInitialBalance: 0,
                    transactionsIncome: 0,
                    transactionsExpense: 0,
                    transactionsFinalBalance: 0,
                    transactionsInPeriod: [],
                    categories: [],
                    accounts: [],
                    cards: [],
                    isCustomPeriod: true,
                    periodStart: startDateStr,
                    periodEnd: endDateStr
                };

                // Calcular saldo inicial antes do período
                const initialBalancesBeforePeriod = this.calculateInitialBalanceForPeriod(startDate, filterAccountId === 'all' ? null : filterAccountId);
                
                if (filterAccountId === 'all') {
                    result.dashboardInitialBalance = Object.values(initialBalancesBeforePeriod).reduce((sum, bal) => sum + bal, 0);
                    result.transactionsInitialBalance = result.dashboardInitialBalance;
                } else {
                    result.dashboardInitialBalance = initialBalancesBeforePeriod[filterAccountId] || 0;
                    result.transactionsInitialBalance = result.dashboardInitialBalance;
                }

                const categoryTotals = {};
                this.data.categories.income.forEach(cat => categoryTotals[cat.id] = 0);
                this.data.categories.expense.forEach(cat => categoryTotals[cat.id] = 0);

                // Preparar contas
                result.accounts = this.data.accounts.map(acc => ({
                    id: acc.id, name: acc.name, emoji: acc.emoji, color: acc.color,
                    initialBalance: initialBalancesBeforePeriod[acc.id] || 0,
                    income: 0, expense: 0,
                    finalBalance: initialBalancesBeforePeriod[acc.id] || 0
                }));

                // Preparar cartões
                result.cards = this.data.cards.map(card => ({
                    id: card.id, name: card.name, emoji: card.emoji, color: card.color,
                    limit: card.limit, dueDay: card.dueDay, lastDigits: card.lastDigits,
                    account: card.account, totalFaturaMes: 0
                }));

                // Filtrar transações no período
                result.transactionsInPeriod = this.data.transactions.filter(t => {
                    if (t.type === 'card') {
                        // Para transações de cartão, verificar se o vencimento está no período
                        const cardDetails = this.data.cards.find(c => c.id === t.card);
                        if (cardDetails) {
                            const dueDate = this.getCardDueDate(t.card, t.invoiceMonth, t.invoiceYear);
                            return dueDate >= startDate && dueDate <= endDate;
                        }
                        return false;
                    } else {
                        const date = this.parseDate(t.date);
                        return date >= startDate && date <= endDate;
                    }
                }).sort((a, b) => {
                    const dateA = a.type === 'card' ? this.getCardDueDate(a.card, a.invoiceMonth, a.invoiceYear) : this.parseDate(a.date);
                    const dateB = b.type === 'card' ? this.getCardDueDate(b.card, b.invoiceMonth, b.invoiceYear) : this.parseDate(b.date);
                    return dateA - dateB;
                });

                // Processar transações
                result.transactionsInPeriod.forEach(t => {
                    const isCardTransactionInPeriod = t.type === 'card';
                    
                    // Aplicar filtros de transações
                    const passesTypeFilter = this.transactionFilters.type === 'all' || 
                        this.transactionFilters.type === t.type ||
                        (this.transactionFilters.type === 'expense' && t.type === 'card');
                    const passesCategoryFilter = this.transactionFilters.category === 'all' || this.transactionFilters.category === t.category;
                    const passesAccountFilter = this.transactionFilters.account === 'all' || 
                        this.transactionBelongsToAccount(t, this.transactionFilters.account);
                    
                    const passesAllFilters = passesTypeFilter && passesCategoryFilter && passesAccountFilter;

                    if (this.isPreviewMode) {
                        if (passesAllFilters) {
                            if (t.type === 'income') {
                                result.dashboardIncome += t.amount;
                                if (categoryTotals[t.category] !== undefined) categoryTotals[t.category] += t.amount;
                                
                                const account = result.accounts.find(a => a.id === t.account);
                                if (account) {
                                    account.income += t.amount;
                                    account.finalBalance += t.amount;
                                }
                            }
                            
                            if (t.type === 'expense') {
                                result.dashboardExpense += t.amount;
                                if (categoryTotals[t.category] !== undefined) categoryTotals[t.category] += t.amount;
                                
                                const account = result.accounts.find(a => a.id === t.account);
                                if (account) {
                                    account.expense += t.amount;
                                    account.finalBalance -= t.amount;
                                }
                            }
                            
                            if (isCardTransactionInPeriod) {
                                result.dashboardExpense += t.amount;
                                if (categoryTotals[t.category] !== undefined) categoryTotals[t.category] += t.amount;
                                
                                const card = result.cards.find(c => c.id === t.card);
                                if (card) card.totalFaturaMes += t.amount;
                            }

                            // Filtros por conta
                            if (filterAccountId === 'all') {
                                if (t.type === 'income') result.transactionsIncome += t.amount;
                                if (t.type === 'expense') result.transactionsExpense += t.amount;
                                if (isCardTransactionInPeriod) {
                                    result.transactionsExpense += t.amount;
                                }
                            } else {
                                if (t.type === 'income' && t.account === filterAccountId) result.transactionsIncome += t.amount;
                                if (t.type === 'transfer' && t.destAccount === filterAccountId) result.transactionsIncome += t.amount;
                                if (t.type === 'expense' && t.account === filterAccountId) result.transactionsExpense += t.amount;
                                if (t.type === 'transfer' && t.sourceAccount === filterAccountId) result.transactionsExpense += t.amount;
                                
                                if (isCardTransactionInPeriod) {
                                    const cardDetails = this.data.cards.find(c => c.id === t.card);
                                    if (cardDetails && cardDetails.account === filterAccountId) {
                                        result.transactionsExpense += t.amount;
                                    }
                                }
                            }
                        }
                    } else {
                        // Modo realizado - apenas transações completed
                        if (t.completed && passesAllFilters) {
                            if (t.type === 'income') {
                                result.dashboardIncome += t.amount;
                                if (categoryTotals[t.category] !== undefined) categoryTotals[t.category] += t.amount;
                                
                                const account = result.accounts.find(a => a.id === t.account);
                                if (account) {
                                    account.income += t.amount;
                                    account.finalBalance += t.amount;
                                }
                            }
                            
                            if (t.type === 'expense') {
                                result.dashboardExpense += t.amount;
                                if (categoryTotals[t.category] !== undefined) categoryTotals[t.category] += t.amount;
                                
                                const account = result.accounts.find(a => a.id === t.account);
                                if (account) {
                                    account.expense += t.amount;
                                    account.finalBalance -= t.amount;
                                }
                            }

                            // Filtros por conta para modo realizado
                            if (filterAccountId === 'all') {
                                if (t.type === 'income') result.transactionsIncome += t.amount;
                                if (t.type === 'expense') result.transactionsExpense += t.amount;
                            } else {
                                if (t.type === 'income' && t.account === filterAccountId) result.transactionsIncome += t.amount;
                                if (t.type === 'transfer' && t.destAccount === filterAccountId) result.transactionsIncome += t.amount;
                                if (t.type === 'expense' && t.account === filterAccountId) result.transactionsExpense += t.amount;
                                if (t.type === 'transfer' && t.sourceAccount === filterAccountId) result.transactionsExpense += t.amount;
                            }
                        }

                        // Transações de cartão pagas
                        if (isCardTransactionInPeriod && this.isCardInvoicePaid(t.card, t.invoiceMonth, t.invoiceYear) && passesAllFilters) {
                            result.dashboardExpense += t.amount;
                            if (categoryTotals[t.category] !== undefined) categoryTotals[t.category] += t.amount;
                            
                            const card = result.cards.find(c => c.id === t.card);
                            if (card) card.totalFaturaMes += t.amount;

                            if (filterAccountId === 'all') {
                                result.transactionsExpense += t.amount;
                            } else {
                                const cardDetails = this.data.cards.find(c => c.id === t.card);
                                if (cardDetails && cardDetails.account === filterAccountId) {
                                    result.transactionsExpense += t.amount;
                                }
                            }
                        }
                    }

                    // Processar transferências
                    if (t.type === 'transfer' && passesAllFilters) {
                        const sourceAccount = result.accounts.find(a => a.id === t.sourceAccount);
                        const destAccount = result.accounts.find(a => a.id === t.destAccount);
                        
                        if (this.isPreviewMode || t.completed) {
                            if (sourceAccount) {
                                sourceAccount.expense += t.amount;
                                sourceAccount.finalBalance -= t.amount;
                            }
                            if (destAccount) {
                                destAccount.income += t.amount;
                                destAccount.finalBalance += t.amount;
                            }
                        }
                    }
                });

                // Calcular saldos finais
                result.dashboardFinalBalance = result.dashboardInitialBalance + result.dashboardIncome - result.dashboardExpense;
                result.transactionsFinalBalance = result.transactionsInitialBalance + result.transactionsIncome - result.transactionsExpense;

                // Preparar dados de categorias
                result.categories = [];
                this.data.categories.expense.forEach(cat => {
                    const total = categoryTotals[cat.id] || 0;
                    if (total > 0) {
                        result.categories.push({
                            id: cat.id,
                            name: cat.name,
                            emoji: cat.emoji,
                            color: cat.color,
                            total: total
                        });
                    }
                });

                result.incomeCategories = [];
                this.data.categories.income.forEach(cat => {
                    const total = categoryTotals[cat.id] || 0;
                    if (total > 0) {
                        result.incomeCategories.push({
                            id: cat.id,
                            name: cat.name,
                            emoji: cat.emoji,
                            color: cat.color,
                            total: total
                        });
                    }
                });

                return result;
            }

            getCustomPeriodTransactions(startDateStr, endDateStr, filterAccountId = 'all') {
                const startDate = this.parseDate(startDateStr);
                const endDate = this.parseDate(endDateStr);
                
                return this.data.transactions.filter(transaction => {
                    const transactionDate = this.parseDate(transaction.date);
                    const isInPeriod = transactionDate >= startDate && transactionDate <= endDate;
                    
                    if (!isInPeriod) return false;
                    
                    if (filterAccountId !== 'all') {
                        const accountMatches = transaction.account === filterAccountId || 
                                             (transaction.type === 'transfer' && transaction.targetAccount === filterAccountId);
                        if (!accountMatches) return false;
                    }
                    
                    return true;
                });
            }

            calculateInitialBalanceForPeriod(beforeDate, specificAccountId = null) {
                const calculatedBalances = {};
                const targetAccounts = specificAccountId ? [this.data.accounts.find(a => a.id === specificAccountId)].filter(Boolean) : this.data.accounts;
                
                // Se não houver contas (problema de filtro), usar todas as contas
                if (targetAccounts.length === 0 && specificAccountId !== null) {
                    const allAccounts = this.data.accounts;
                    allAccounts.forEach(acc => {
                        calculatedBalances[acc.id] = acc.initialBalance;
                    });
                } else {
                    targetAccounts.forEach(acc => {
                        calculatedBalances[acc.id] = acc.initialBalance;
                    });
                }

                const transactionsBeforePeriod = this.data.transactions.filter(t => {
                    if (t.type === 'card') {
                        const cardDetails = this.data.cards.find(c => c.id === t.card);
                        if (cardDetails) {
                            const dueDate = this.getCardDueDate(t.card, t.invoiceMonth, t.invoiceYear);
                            return dueDate < beforeDate;
                        }
                        return false;
                    } else {
                        const date = this.parseDate(t.date);
                        return date < beforeDate;
                    }
                }).sort((a, b) => {
                    const dateA = a.type === 'card' ? this.getCardDueDate(a.card, a.invoiceMonth, a.invoiceYear) : this.parseDate(a.date);
                    const dateB = b.type === 'card' ? this.getCardDueDate(b.card, b.invoiceMonth, b.invoiceYear) : this.parseDate(b.date);
                    return dateA - dateB;
                });

                transactionsBeforePeriod.forEach(t => {
                    if (t.type === 'card') {
                        const cardDetails = this.data.cards.find(c => c.id === t.card);
                        if (cardDetails && calculatedBalances[cardDetails.account] !== undefined) {
                            if (this.isPreviewMode) {
                                // No modo preview, considerar todas as transações de cartão não pagas
                                if (!this.isCardInvoicePaid(t.card, t.invoiceMonth, t.invoiceYear)) {
                                    calculatedBalances[cardDetails.account] -= t.amount;
                                }
                            } else {
                                // No modo normal, só considerar faturas pagas
                                if (this.isCardInvoicePaid(t.card, t.invoiceMonth, t.invoiceYear)) {
                                    calculatedBalances[cardDetails.account] -= t.amount;
                                }
                            }
                        }
                    } else {
                        if (this.isPreviewMode) {
                            // No modo preview, considerar todas as transações
                            if (t.type === 'income') {
                                if (calculatedBalances[t.account] !== undefined) calculatedBalances[t.account] += t.amount;
                            } else if (t.type === 'expense') {
                                if (calculatedBalances[t.account] !== undefined) calculatedBalances[t.account] -= t.amount;
                            } else if (t.type === 'transfer') {
                                if (calculatedBalances[t.sourceAccount] !== undefined) calculatedBalances[t.sourceAccount] -= t.amount;
                                if (calculatedBalances[t.destAccount] !== undefined) calculatedBalances[t.destAccount] += t.amount;
                            }
                        } else {
                            // No modo normal, só considerar transações completadas
                            if (t.completed) {
                                if (t.type === 'income') {
                                    if (calculatedBalances[t.account] !== undefined) calculatedBalances[t.account] += t.amount;
                                } else if (t.type === 'expense') {
                                    if (calculatedBalances[t.account] !== undefined) calculatedBalances[t.account] -= t.amount;
                                } else if (t.type === 'transfer') {
                                    if (calculatedBalances[t.sourceAccount] !== undefined) calculatedBalances[t.sourceAccount] -= t.amount;
                                    if (calculatedBalances[t.destAccount] !== undefined) calculatedBalances[t.destAccount] += t.amount;
                                }
                            }
                        }
                    }
                });

                if (specificAccountId) {
                    return calculatedBalances[specificAccountId] || 0;
                } else {
                    return calculatedBalances;
                }
            }
            
            transactionBelongsToAccount(transaction, accountId) { 
                if (accountId === 'all') return true; 

                if (transaction.type === 'income' || transaction.type === 'expense') { 
                    return transaction.account === accountId; 
                } else if (transaction.type === 'transfer') { 
                    return transaction.sourceAccount === accountId || transaction.destAccount === accountId; 
                } else if (transaction.type === 'card') { 
                    const cardDetails = this.data.cards.find(c => c.id === transaction.card);
                    return cardDetails && cardDetails.account === accountId; 
                } else if (transaction.isInvoicePayment) { 
                    return transaction.account === accountId; 
                } 
                return false; 
            }

            getChartDataForIncomeExpense(monthCount) { 
                const labels = []; 
                const incomeData = []; 
                const expenseData = []; 
                const currentDate = new Date(this.currentYear, this.currentMonth); 

                for (let i = monthCount - 1; i >= 0; i--) { 
                    const date = new Date(currentDate); 
                    date.setMonth(currentDate.getMonth() - i); 
                    const month = date.getMonth(); 
                    const year = date.getFullYear(); 
                    
                    const monthSummary = this.getMonthData(month, year, 'all'); 
                    
                    labels.push(`${this.getMonthName(month).substring(0, 3)}/${year.toString().slice(-2)}`); 
                    incomeData.push(monthSummary.dashboardIncome); 
                    expenseData.push(monthSummary.dashboardExpense); 
                } 
                return { labels, income: incomeData, expense: expenseData }; 
            }

            getChartDataForCustomPeriod() {
                if (!this.customDateStart || !this.customDateEnd) {
                    return { labels: [], income: [], expense: [] };
                }
                
                const labels = [];
                const incomeData = [];
                const expenseData = [];
                
                const startDate = new Date(this.customDateStart);
                const endDate = new Date(this.customDateEnd);
                
                const startMonth = startDate.getMonth();
                const startYear = startDate.getFullYear();
                const endMonth = endDate.getMonth();
                const endYear = endDate.getFullYear();
                
                let currentMonth = startMonth;
                let currentYear = startYear;
                
                while (currentYear < endYear || (currentYear === endYear && currentMonth <= endMonth)) {
                    const monthSummary = this.getMonthData(currentMonth, currentYear, 'all', 
                        currentYear === startYear && currentMonth === startMonth ? startDate : null,
                        currentYear === endYear && currentMonth === endMonth ? endDate : null
                    );
                    
                    labels.push(`${this.getMonthName(currentMonth).substring(0, 3)}/${currentYear.toString().slice(-2)}`);
                    incomeData.push(monthSummary.dashboardIncome);
                    expenseData.push(monthSummary.dashboardExpense);
                    
                    currentMonth++;
                    if (currentMonth > 11) {
                        currentMonth = 0;
                        currentYear++;
                    }
                }
                
                return { labels, income: incomeData, expense: expenseData };
            }

            getFutureChartDataForIncomeExpense(monthCount) { 
                const labels = []; 
                const incomeData = []; 
                const expenseData = []; 
                const currentDate = new Date(this.currentYear, this.currentMonth); 

                for (let i = 1; i <= monthCount; i++) { 
                    const date = new Date(currentDate); 
                    date.setMonth(currentDate.getMonth() + i); 
                    const month = date.getMonth(); 
                    const year = date.getFullYear(); 
                    
                    const monthSummary = this.getMonthData(month, year, 'all'); 
                    
                    labels.push(`${this.getMonthName(month).substring(0, 3)}/${year.toString().slice(-2)}`); 
                    incomeData.push(monthSummary.dashboardIncome); 
                    expenseData.push(monthSummary.dashboardExpense); 
                } 
                return { labels, income: incomeData, expense: expenseData }; 
            }

            getNextDueDate(dueDay) { 
                const today = new Date(); 
                const currentDay = today.getDate(); 
                let nextDueDate = new Date(today.getFullYear(), today.getMonth(), dueDay); 
                if (currentDay > dueDay) { 
                    nextDueDate.setMonth(nextDueDate.getMonth() + 1); 
                } 
                return nextDueDate; 
            }

            formatCurrency(value) { 
                if (typeof value !== 'number' || isNaN(value)) { 
                    value = 0; 
                } 
                return value.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }); 
            }
            
            formatInputCurrency(value) {
                if (!value) return '';
                value = value.toString().replace(/\D/g, '');
                if (!value) return '';
                value = (parseInt(value) / 100).toFixed(2);
                return value.replace('.', ',').replace(/\B(?=(\d{3})+(?!\d))/g, '.');
            }
            
            parseInputCurrency(value) {
                if (!value) return 0;
                return parseFloat(value.replace(/\./g, '').replace(',', '.')) || 0;
            }

            formatValueInput(value) {
                if (!value) return '';
                
                // Remove tudo exceto números
                let cleanValue = value.replace(/\D/g, '');
                
                if (!cleanValue) return '';
                
                // Converte para formato brasileiro com centavos
                let numericValue = parseInt(cleanValue);
                let formattedValue = (numericValue / 100).toFixed(2);
                
                // Aplica formatação brasileira: 1.000,00
                return formattedValue.replace('.', ',').replace(/\B(?=(\d{3})+(?!\d))/g, '.');
            }
            
            parseValueInput(value) {
                if (!value) return 0;
                
                let cleanValue = value.replace(/\./g, '').replace(',', '.');
                return parseFloat(cleanValue) || 0;
            }
            
            formatValueForEdit(value) {
                if (!value || value === 0) return '';
                
                // Converte para número se necessário
                const numericValue = typeof value === 'string' ? parseFloat(value) : value;
                if (isNaN(numericValue)) return '';
                
                // Formata no padrão brasileiro: 1.000,00
                return numericValue.toLocaleString('pt-BR', { 
                    minimumFractionDigits: 2, 
                    maximumFractionDigits: 2 
                });
            }
            
            restrictToNumbersCommaAndDot(event) {
                const key = event.key;
                const isNumber = /\d/.test(key);
                const isControlKey = ['Backspace', 'Delete', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Tab', 'Home', 'End'].includes(key);
                
                if (!(isNumber || isControlKey)) {
                    event.preventDefault();
                }
            }
            
            setupCurrencyMask(elementId) {
                const element = document.getElementById(elementId);
                if (!element) return;
                
                element.addEventListener('keydown', (event) => this.restrictToNumbersCommaAndDot(event));
                
                element.addEventListener('input', (e) => {
                    const cursorPosition = e.target.selectionStart;
                    const oldValue = e.target.value;
                    const oldLength = oldValue.length;
                    
                    const newValue = this.formatValueInput(oldValue);
                    
                    if (newValue !== oldValue) {
                        e.target.value = newValue;
                        
                        const newLength = newValue.length;
                        const lengthDiff = newLength - oldLength;
                        const newCursorPosition = cursorPosition + lengthDiff;
                        
                        const safePosition = Math.max(0, Math.min(newCursorPosition, newLength));
                        e.target.setSelectionRange(safePosition, safePosition);
                    }
                    
                    if (elementId === 'amount') {
                        this.updateInstallmentValueDisplay();
                    }
                });
            }
            
            updateInstallmentValueDisplay() {
                const recurringElement = document.getElementById('recurring');
                const installmentValueDisplay = document.getElementById('installmentValueDisplay');
                const installmentValueText = document.getElementById('installmentValueText');
                
                if (!recurringElement || !installmentValueDisplay || !installmentValueText) {
                    return;
                }
                
                const recurringChecked = recurringElement.checked;
                
                if (!recurringChecked) {
                    installmentValueDisplay.style.display = 'none';
                    return;
                }
                
                const amount = this.parseValueInput(document.getElementById('amount').value) || 0;
                const totalInstallmentsElement = document.getElementById('totalInstallments');
                const currentInstallmentElement = document.getElementById('currentInstallment');
                
                if (!totalInstallmentsElement || !currentInstallmentElement) {
                    return;
                }
                
                const totalInstallments = parseInt(totalInstallmentsElement.value) || 1;
                const currentInstallment = parseInt(currentInstallmentElement.value) || 1;
                const valueType = document.querySelector('input[name="valueType"]:checked')?.value || 'total';
                const recurringType = document.querySelector('input[name="recurringType"]:checked')?.value;
                
                if (amount > 0 && totalInstallments > 0) {
                    let installmentValue = 0;
                    let displayText = '';
                    
                    if (valueType === 'total') {
                        installmentValue = amount / totalInstallments;
                    } else {
                        installmentValue = amount;
                    }
                    
                    if (recurringType === 'installment') {
                        displayText = `${totalInstallments}x de R$ ${this.formatCurrency(installmentValue)}`;
                        if (currentInstallment > 1) {
                            displayText += `, começando a partir da ${currentInstallment}º parcela`;
                        }
                    } else {
                        displayText = `Valor por parcela: R$ ${this.formatCurrency(installmentValue)}`;
                    }
                    
                    installmentValueText.textContent = displayText;
                    installmentValueDisplay.style.display = 'block';
                } else {
                    installmentValueDisplay.style.display = 'none';
                }
            }
            
            setupCurrencyInput(inputId) {
                const input = document.getElementById(inputId);
                if (!input) return;
                
                input.addEventListener('input', (e) => {
                    const cursorPosition = e.target.selectionStart;
                    const oldLength = e.target.value.length;
                    
                    let value = e.target.value.replace(/\D/g, '');
                    if (value.length === 0) {
                        e.target.value = '';
                        return;
                    }
                    
                    value = (parseInt(value) / 100).toFixed(2);
                    const formattedValue = value.replace('.', ',').replace(/\B(?=(\d{3})+(?!\d))/g, '.');
                    
                    e.target.value = formattedValue;
                    
                    const newLength = e.target.value.length;
                    const lengthDiff = newLength - oldLength;
                    const newCursorPosition = cursorPosition + lengthDiff;
                    e.target.setSelectionRange(newCursorPosition, newCursorPosition);
                });
                
                input.addEventListener('keypress', (e) => {
                    if (!/[\d,.]/.test(e.key) && !['Backspace', 'Delete', 'ArrowLeft', 'ArrowRight', 'Tab'].includes(e.key)) {
                        e.preventDefault();
                    }
                });
            }

            formatDate(date) { 
                if (!(date instanceof Date) || isNaN(date.getTime())) return 'Data inválida'; 
                const day = date.getDate().toString().padStart(2, '0'); 
                const month = (date.getMonth() + 1).toString().padStart(2, '0'); 
                const year = date.getFullYear(); 
                const weekday = this.getWeekdayName(date.getDay()); 
                return `${weekday}, ${day}/${month}/${year}`; 
            }

            formatDateShort(date) { 
                if (!(date instanceof Date) || isNaN(date.getTime())) return '--/--/----'; 
                const day = date.getDate().toString().padStart(2, '0'); 
                const month = (date.getMonth() + 1).toString().padStart(2, '0'); 
                const year = date.getFullYear(); 
                return `${day}/${month}/${year}`; 
            }

            formatInputDate(date) { 
                if (!(date instanceof Date) || isNaN(date.getTime())) { 
                    date = new Date(); 
                } 
                const localDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());

                const day = localDate.getDate().toString().padStart(2, '0'); 
                const monthNum = localDate.getMonth() + 1;
                const month = monthNum.toString().padStart(2, '0'); 
                const year = localDate.getFullYear(); 
                return `${year}-${month}-${day}`; 
            }

            getMonthName(monthIndex) { 
                const months = ['Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro']; 
                return months[monthIndex] || ''; 
            }

            getWeekdayName(weekdayIndex) { 
                const weekdays = ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb']; 
                return weekdays[weekdayIndex] || ''; 
            }

            getCategoryName(id, type) { 
                if (!this.data.categories[type]) return 'Sem Categoria'; 
                const category = this.data.categories[type].find(c => c.id === id); 
                return category ? category.name : 'Sem Categoria'; 
            }

            generateId() { 
                return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15); 
            }

            renderCategories(container) { 
                container.innerHTML = `
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                        <div class="card">
                            <div class="card-header"><h3 class="card-title">Categorias de Receita</h3><button class="btn btn-primary" id="addIncomeCategoryBtn"><i class="fas fa-plus"></i><span>Nova Categoria</span></button></div>
                            <div id="incomeCategoriesList">${this.renderCategoriesList('income')}</div>
                        </div>
                        <div class="card">
                            <div class="card-header"><h3 class="card-title">Categorias de Despesa</h3><button class="btn btn-primary" id="addExpenseCategoryBtn"><i class="fas fa-plus"></i><span>Nova Categoria</span></button></div>
                            <div id="expenseCategoriesList">${this.renderCategoriesList('expense')}</div>
                        </div>
                    </div>`; 
                document.getElementById('addIncomeCategoryBtn').addEventListener('click', () => this.showCategoryModal('income')); 
                document.getElementById('addExpenseCategoryBtn').addEventListener('click', () => this.showCategoryModal('expense')); 
                this.attachCategoryEventListeners(); 
            }

            renderCategoriesList(type) { 
                const categories = this.data.categories[type]; 
                if (!categories || categories.length === 0) { 
                    return `<div class="no-data"><i class="fas fa-tags"></i><p>Nenhuma categoria cadastrada.</p></div>`; 
                } 
                return categories.map(category => `
                    <div class="transaction-item">
                        <div class="transaction-info">
                            <div class="transaction-icon" style="background-color: ${category.color}20; color: ${category.color}">${category.emoji}</div>
                            <div class="transaction-details">
                                <div class="transaction-name">${category.name}</div>
                                ${type === 'expense' && category.limit ? `<div class="transaction-category">Limite: R$ ${this.formatCurrency(category.limit)}</div>` : ''}
                            </div>
                        </div>
                        <div class="transaction-actions" style="opacity: 1;">
                            <button class="action-btn edit-cat-btn" data-type="${type}" data-id="${category.id}" title="Editar"><i class="fas fa-edit"></i></button>
                            <button class="action-btn delete-cat-btn" data-type="${type}" data-id="${category.id}" title="Excluir"><i class="fas fa-trash"></i></button>
                        </div>
                    </div>`).join(''); 
            }

attachCategoryEventListeners() { 
    document.querySelectorAll('.edit-cat-btn').forEach(btn => { 
        btn.addEventListener('click', () => { 
            const type = btn.getAttribute('data-type'); 
            const id = btn.getAttribute('data-id'); 
            this.editCategory(type, id); 
        }); 
    }); 
    document.querySelectorAll('.delete-cat-btn').forEach(btn => { 
        btn.addEventListener('click', () => { 
            const type = btn.getAttribute('data-type'); 
            const id = btn.getAttribute('data-id'); 
            
            const isInUse = this.data.transactions.some(t => ((t.type === type || (type === 'expense' && t.type === 'card')) && t.category === id)); 
            if (isInUse) { 
                this.notificationSystem.show('Erro', 'Esta categoria está em uso em transações e não pode ser excluída!', 'error'); 
                return; 
            } 
            if (confirm('Tem certeza que deseja excluir esta categoria?')) { 
                this.deleteCategory(type, id); 
            } 
        }); 
    }); 
}

            editCategory(type, id) { 
                const category = this.data.categories[type].find(c => c.id === id); 
                if (category) { 
                    this.showCategoryModal(type, category); 
                } 
            }

            deleteCategory(type, id) { 
                this.data.categories[type] = this.data.categories[type].filter(c => c.id !== id); 
                this.saveData(); 
                const listId = type === 'income' ? 'incomeCategoriesList' : 'expenseCategoriesList'; 
                const listElement = document.getElementById(listId);
                if (listElement) { 
                    listElement.innerHTML = this.renderCategoriesList(type); 
                    this.attachCategoryEventListeners(); 
                }
                this.notificationSystem.show('Sucesso', 'Categoria excluída com sucesso!', 'success'); 
            }

            showCategoryModal(type, category = null) { 
                const isEdit = category !== null; 
                const modalTitle = isEdit ? `Editar Categoria de ${type === 'income' ? 'Receita' : 'Despesa'}` : `Nova Categoria de ${type === 'income' ? 'Receita' : 'Despesa'}`; 
                
                if (!isEdit) {
    const currentCount = this.data.categories[type].length;
    if (!this.checkPlanLimits('categories', currentCount)) {
        const limits = this.getPlanLimits();
        const limitText = limits.categories === -1 ? 'ilimitadas' : limits.categories;
        this.notificationSystem.show('Limite Atingido', `Você atingiu o limite de ${limitText} categorias de ${type === 'income' ? 'receita' : 'despesa'} para seu plano atual.`, 'warning');
        this.showUpgradeModal('categories');
        return;
    }
}
                
                const modalContentEl = document.getElementById('modalContent'); 
                modalContentEl.innerHTML = `
                    <div class="modal-header"><h3 class="modal-title">${modalTitle}</h3><button class="modal-close" id="modalCloseCategory">&times;</button></div>
                    <div class="modal-body">
                        <div class="form-row"><label class="form-label" for="categoryName">Nome</label><input type="text" class="form-input" id="categoryName" value="${isEdit ? category.name : ''}"></div>
                        <div class="form-row"><label class="form-label">Emoji</label><div class="emoji-picker" id="categoryEmojiPicker">${this.renderEmojiPicker(isEdit ? category.emoji : this.emojiList[0])}</div></div>
                        <div class="form-row"><label class="form-label">Cor</label><div class="color-picker" id="categoryColorPicker">${this.renderColorPicker(isEdit ? category.color : this.colorList[0])}</div></div>
                        ${type === 'expense' ? `<div class="form-row"><label class="form-label" for="categoryLimit">Limite Mensal (opcional)</label><input type="text" class="form-input" id="categoryLimit" placeholder="0,00 (deixe vazio para sem limite)" value="${isEdit && category.limit ? this.formatValueForEdit(category.limit) : ''}"></div>` : ''}
                    </div>
                    <div class="form-footer"><button class="btn btn-outlined" id="cancelCategoryBtn">Cancelar</button><button class="btn btn-primary" id="saveCategoryBtn">${isEdit ? 'Atualizar' : 'Salvar'}</button></div>`; 
                
                document.getElementById('modalOverlay').classList.add('active'); 
                if (type === 'expense') {
                    this.setupCurrencyMask('categoryLimit');
                }
                document.getElementById('modalCloseCategory').addEventListener('click', () => this.closeModal()); 
                document.getElementById('cancelCategoryBtn').addEventListener('click', () => this.closeModal()); 
                
                document.querySelectorAll('#categoryEmojiPicker .emoji-item').forEach(item => { 
                    item.addEventListener('click', () => { 
                        document.querySelectorAll('#categoryEmojiPicker .emoji-item').forEach(i => i.classList.remove('selected')); 
                        item.classList.add('selected'); 
                    }); 
                }); 
                document.querySelectorAll('#categoryColorPicker .color-item').forEach(item => { 
                    item.addEventListener('click', () => { 
                        document.querySelectorAll('#categoryColorPicker .color-item').forEach(i => i.classList.remove('selected')); 
                        item.classList.add('selected'); 
                    }); 
                }); 
                
                document.getElementById('saveCategoryBtn').addEventListener('click', () => { 
                    const name = document.getElementById('categoryName').value; 
                    const selectedEmojiEl = document.querySelector('#categoryEmojiPicker .emoji-item.selected'); 
                    const selectedColorEl = document.querySelector('#categoryColorPicker .color-item.selected'); 
                    let limit = 0; 
                    if (type === 'expense') { 
                        const limitInput = document.getElementById('categoryLimit').value;
                        limit = this.parseValueInput(limitInput) || 0; 
                    } 
                    if (!name || !selectedEmojiEl || !selectedColorEl) { 
                        this.notificationSystem.show('Erro', 'Nome, emoji e cor são obrigatórios!', 'error'); 
                        return; 
                    } 
                    const emoji = selectedEmojiEl.textContent; 
                    const color = selectedColorEl.getAttribute('data-color'); 
                    const categoryObj = { id: isEdit ? category.id : this.generateId(), name, emoji, color }; 
                    if (type === 'expense') { 
                        categoryObj.limit = limit > 0 ? limit : null; 
                    } 
                    if (isEdit) { 
                        const index = this.data.categories[type].findIndex(c => c.id === category.id); 
                        if (index !== -1) { 
                            this.data.categories[type][index] = categoryObj; 
                        } 
                    } else { 
                        this.data.categories[type].push(categoryObj); 
                    } 
                    this.saveData(); 
                    this.closeModal(); 
                    const listId = type === 'income' ? 'incomeCategoriesList' : 'expenseCategoriesList'; 
                    const listElement = document.getElementById(listId);
                    if (listElement) {
                        listElement.innerHTML = this.renderCategoriesList(type); 
                        this.attachCategoryEventListeners();
                    }
                    this.notificationSystem.show('Sucesso', `Categoria ${isEdit ? 'atualizada' : 'adicionada'} com sucesso!`, 'success'); 
                }); 
            }

            renderEmojiPicker(selectedEmoji = '') { 
                return this.emojiList.map(emoji => `<div class="emoji-item ${emoji === selectedEmoji ? 'selected' : ''}" title="${emoji}">${emoji}</div>`).join(''); 
            }

            renderColorPicker(selectedColor = '') { 
                return this.colorList.map(color => `<div class="color-item ${color === selectedColor ? 'selected' : ''}" style="background-color: ${color};" data-color="${color}" title="${color}"></div>`).join(''); 
            }

            renderAccounts(container) { 
                const monthData = this.getMonthData(this.currentMonth, this.currentYear, 'all'); 
                container.innerHTML = `
                    <div class="header-actions" style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; margin-bottom: 20px;">
                        <div class="month-navigation">
                            <button class="month-nav-btn" id="prevMonthBtnAccounts"><i class="fas fa-chevron-left"></i></button>
                            <span class="current-month" id="currentMonthDisplayAccounts">${this.getMonthName(this.currentMonth)} de ${this.currentYear}</span>
                            <button class="month-nav-btn" id="nextMonthBtnAccounts"><i class="fas fa-chevron-right"></i></button>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;" class="toggle-switch-container">
                            <label class="toggle-switch">
                                <input type="checkbox" id="previewToggleAccounts" ${this.isPreviewMode ? 'checked' : ''}>
                                <span class="toggle-slider"></span>
                            </label>
                            <span class="toggle-label">Modo Previsto</span>
                        </div>
                    </div>
                    <div class="card">
                        <div class="card-header">
                            <h3 class="card-title">Contas</h3>
                            <button class="btn btn-primary" id="addAccountBtn"><i class="fas fa-plus"></i><span>Nova Conta</span></button>
                        </div>
                        <div id="accountsListContainer">
                            ${this.renderAccountsDetailsList(monthData.accounts)}
                        </div>
                    </div>`; 
                document.getElementById('addAccountBtn').addEventListener('click', () => this.showAccountModal()); 
                const previewToggle = document.getElementById('previewToggleAccounts'); 
                if (previewToggle) { 
                    previewToggle.addEventListener('change', () => { 
                        if (!this.isFeatureAvailable('preview_mode')) {
                            previewToggle.checked = false;
                            this.showUpgradeModal('preview_mode');
                            return;
                        }
                        this.isPreviewMode = previewToggle.checked; 
                        this.refreshView(); 
                    }); 
                } 
                const prevMonthBtn = document.getElementById('prevMonthBtnAccounts'); 
                const nextMonthBtn = document.getElementById('nextMonthBtnAccounts'); 
                const currentMonthDisplay = document.getElementById('currentMonthDisplayAccounts'); 
                if(prevMonthBtn) prevMonthBtn.addEventListener('click', () => this.navigateMonth(-1)); 
                if(nextMonthBtn) nextMonthBtn.addEventListener('click', () => this.navigateMonth(1)); 
                if(currentMonthDisplay) { 
                    currentMonthDisplay.addEventListener('click', () => { 
                        const today = new Date(); 
                        this.currentMonth = today.getMonth(); 
                        this.currentYear = today.getFullYear(); 
                        this.refreshView(); 
                    }); 
                } 
                this.attachAccountEventListeners(); 
            }

            renderAccountsDetailsList(accountsDataFromMonth) { 
                if (!this.data.accounts || this.data.accounts.length === 0) { 
                    return `<div class="no-data"><i class="fas fa-university"></i><p>Nenhuma conta cadastrada.</p></div>`; 
                } 
                return this.data.accounts.map(originalAccount => { 
                    const accountMonthData = accountsDataFromMonth.find(ad => ad.id === originalAccount.id); 
                    const finalBalanceToShow = accountMonthData ? accountMonthData.finalBalance : originalAccount.initialBalance; 
                    const initialBalanceRegistered = originalAccount.initialBalance; 
                    const initialBalanceForMonthDisplay = accountMonthData ? accountMonthData.initialBalance : originalAccount.initialBalance;


                    return `
                        <div class="transaction-item">
                            <div class="transaction-info">
                                <div class="transaction-icon" style="background-color: ${originalAccount.color}20; color: ${originalAccount.color}">${originalAccount.emoji}</div>
                                <div class="transaction-details">
                                    <div class="transaction-name">${originalAccount.name}</div>
                                    <div class="transaction-category" title="Saldo inicial conforme cadastro da conta.">Saldo Cadastrado: R$ ${this.formatCurrency(initialBalanceRegistered)}</div>
                                    <div class="transaction-category" title="Saldo no início de ${this.getMonthName(this.currentMonth)}/${this.currentYear}, considerando a config. 'usar saldo do mês anterior'.">Saldo Início Mês: R$ ${this.formatCurrency(initialBalanceForMonthDisplay)}</div>
                                </div>
                            </div>
                            <div style="text-align: right;">
                                <div class="transaction-amount ${finalBalanceToShow >= 0 ? 'income-amount' : 'expense-amount'}">Saldo Final Mês: R$ ${this.formatCurrency(finalBalanceToShow)}</div>
                                <div class="transaction-actions" style="opacity:1;">
                                    <button class="action-btn edit-acc-btn" data-id="${originalAccount.id}" title="Editar"><i class="fas fa-edit"></i></button>
                                    <button class="action-btn delete-acc-btn" data-id="${originalAccount.id}" title="Excluir"><i class="fas fa-trash"></i></button>
                                </div>
                            </div>
                        </div>`; 
                }).join(''); 
            }

            attachAccountEventListeners() { 
                document.querySelectorAll('.edit-acc-btn').forEach(btn => { 
                    btn.addEventListener('click', () => { 
                        const id = btn.getAttribute('data-id'); 
                        this.editAccount(id); 
                    }); 
                }); 
                document.querySelectorAll('.delete-acc-btn').forEach(btn => { 
                    btn.addEventListener('click', () => { 
                        const id = btn.getAttribute('data-id'); 
                        const isInUseInTransactions = this.data.transactions.some(t => 
                            (t.type === 'income' && t.account === id) || 
                            (t.type === 'expense' && t.account === id) || 
                            (t.type === 'transfer' && (t.sourceAccount === id || t.destAccount === id)) ||
                            (t.isInvoicePayment && t.account === id) 
                        ); 
                        const isUsedByCard = this.data.cards.some(c => c.account === id); 

                        if (isInUseInTransactions || isUsedByCard) { 
                            this.notificationSystem.show('Erro', 'Esta conta está em uso em transações ou associada a um cartão e não pode ser excluída!', 'error', 7000); 
                            return; 
                        } 
                        if (confirm('Tem certeza que deseja excluir esta conta?')) { 
                            this.deleteAccount(id); 
                        } 
                    }); 
                }); 
            }

            editAccount(id) { 
                const account = this.data.accounts.find(a => a.id === id); 
                if (account) { 
                    this.showAccountModal(account); 
                } 
            }

            deleteAccount(id) { 
                this.data.accounts = this.data.accounts.filter(a => a.id !== id); 
                this.saveData(); 
                this.refreshView(); 
                this.notificationSystem.show('Sucesso', 'Conta excluída com sucesso!', 'success'); 
            }

            showAccountModal(account = null) { 
    const isEdit = account !== null; 
    const modalTitle = isEdit ? 'Editar Conta' : 'Nova Conta'; 
    
    if (!isEdit) {
        const currentCount = this.data.accounts.length;
        if (!this.checkPlanLimits('accounts', currentCount)) {
            const limits = this.getPlanLimits();
            const limitText = limits.accounts === -1 ? 'ilimitadas' : limits.accounts;
            this.notificationSystem.show('Limite Atingido', `Você atingiu o limite de ${limitText} contas para seu plano atual.`, 'warning');
            this.showUpgradeModal('accounts');
            return;
        }
    }
                
                const modalContentEl = document.getElementById('modalContent'); 
                modalContentEl.innerHTML = `
                    <div class="modal-header"><h3 class="modal-title">${modalTitle}</h3><button class="modal-close" id="modalCloseAccount">&times;</button></div>
                    <div class="modal-body">
                        <div class="form-row"><label class="form-label" for="accountName">Nome</label><input type="text" class="form-input" id="accountName" value="${isEdit ? account.name : ''}"></div>
                        <div class="form-row"><label class="form-label">Emoji</label><div class="emoji-picker" id="accountEmojiPicker">${this.renderEmojiPicker(isEdit ? account.emoji : this.emojiList[0])}</div></div>
                        <div class="form-row"><label class="form-label">Cor</label><div class="color-picker" id="accountColorPicker">${this.renderColorPicker(isEdit ? account.color : this.colorList[0])}</div></div>
                        <div class="form-row"><label class="form-label" for="initialBalance">Saldo Inicial (Cadastro)</label><input type="text" class="form-input" id="initialBalance" placeholder="0,00" value="${isEdit ? this.formatValueForEdit(account.initialBalance) : ''}"></div>
                    </div>
                    <div class="form-footer"><button class="btn btn-outlined" id="cancelAccountBtn">Cancelar</button><button class="btn btn-primary" id="saveAccountBtn">${isEdit ? 'Atualizar' : 'Salvar'}</button></div>`; 
                
                document.getElementById('modalOverlay').classList.add('active'); 
                this.setupCurrencyMask('initialBalance');
                document.getElementById('modalCloseAccount').addEventListener('click', () => this.closeModal()); 
                document.getElementById('cancelAccountBtn').addEventListener('click', () => this.closeModal()); 
                
                document.querySelectorAll('#accountEmojiPicker .emoji-item').forEach(item => { 
                    item.addEventListener('click', () => { 
                        document.querySelectorAll('#accountEmojiPicker .emoji-item').forEach(i => i.classList.remove('selected')); 
                        item.classList.add('selected'); 
                    }); 
                }); 
                document.querySelectorAll('#accountColorPicker .color-item').forEach(item => { 
                    item.addEventListener('click', () => { 
                        document.querySelectorAll('#accountColorPicker .color-item').forEach(i => i.classList.remove('selected')); 
                        item.classList.add('selected'); 
                    }); 
                }); 
                
                document.getElementById('saveAccountBtn').addEventListener('click', () => { 
                    const name = document.getElementById('accountName').value; 
                    const selectedEmojiEl = document.querySelector('#accountEmojiPicker .emoji-item.selected'); 
                    const selectedColorEl = document.querySelector('#accountColorPicker .color-item.selected'); 
                    const initialBalanceInput = document.getElementById('initialBalance').value; 
                    let initialBalance = 0; 
                    if (initialBalanceInput !== '') { 
                        initialBalance = this.parseValueInput(initialBalanceInput); 
                        if (isNaN(initialBalance)) { 
                            this.notificationSystem.show('Erro', 'Saldo inicial inválido!', 'error'); 
                            return; 
                        } 
                    } 
                    if (!name || !selectedEmojiEl || !selectedColorEl) { 
                        this.notificationSystem.show('Erro', 'Nome, emoji e cor são obrigatórios!', 'error'); 
                        return; 
                    } 
                    const emoji = selectedEmojiEl.textContent; 
                    const color = selectedColorEl.getAttribute('data-color'); 
                    const accountObj = { id: isEdit ? account.id : this.generateId(), name, emoji, color, initialBalance }; 
                    if (isEdit) { 
                        const index = this.data.accounts.findIndex(a => a.id === account.id); 
                        if (index !== -1) { 
                            this.data.accounts[index] = accountObj; 
                        } 
                    } else { 
                        this.data.accounts.push(accountObj); 
                    } 
                    this.saveData(); 
                    this.closeModal(); 
                    this.refreshView(); 
                    this.notificationSystem.show('Sucesso', `Conta ${isEdit ? 'atualizada' : 'adicionada'} com sucesso!`, 'success'); 
                }); 
            }
            getCardDueDate(cardId, month, year) {
    const card = this.data.cards.find(c => c.id === cardId);
    if (!card) return new Date();
    
    const dueDate = new Date(year, month, card.dueDay);
    
    if (dueDate.getMonth() !== month) {
        dueDate.setDate(0);
    }
    
    return dueDate;
}

calculateCardOutstandingBalance(cardId) {
    let outstandingBalance = 0;
    const currentDate = new Date();
    const currentMonth = currentDate.getMonth();
    const currentYear = currentDate.getFullYear();
    
    const cardTransactions = this.data.transactions.filter(t => {
    if (t.type !== 'card' || t.card !== cardId) return false;
    
    // Incluir todas as transações de cartão até o mês atual (baseado na fatura)
    if (t.invoiceYear > currentYear) return false;
    if (t.invoiceYear === currentYear && t.invoiceMonth > currentMonth) return false;
    
    return true;
});

    const invoices = {};
    cardTransactions.forEach(t => {
        const invoiceKey = `${t.invoiceMonth}-${t.invoiceYear}`;
        if (!invoices[invoiceKey]) {
            invoices[invoiceKey] = { month: t.invoiceMonth, year: t.invoiceYear, total: 0 };
        }
        invoices[invoiceKey].total += t.amount;
    });

    for (const key in invoices) {
        const invoice = invoices[key];
        if (!this.isCardInvoicePaid(cardId, invoice.month, invoice.year)) {
            outstandingBalance += invoice.total;
        }
    }
    
    return outstandingBalance;
}

            adjustDateForTimezone(date) { 
                if (!(date instanceof Date) || isNaN(date.getTime())) return new Date('invalid date'); 
                const localDate = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 12, 0, 0); 
                return localDate; 
            }

            parseDate(dateString) { 
                if (typeof dateString === 'string' && dateString.length === 10 && dateString.match(/^\d{4}-\d{2}-\d{2}$/)) { 
                    const [year, month, day] = dateString.split('-').map(Number); 
                    return new Date(Date.UTC(year, month - 1, day, 12, 0, 0)); 
                } 
                if (dateString instanceof Date && !isNaN(dateString)) { 
                    return new Date(dateString.getFullYear(), dateString.getMonth(), dateString.getDate(), 12, 0, 0);
                } 
                try {
                    const parsed = new Date(dateString); 
                    if (!isNaN(parsed)) { 
                        return new Date(parsed.getFullYear(), parsed.getMonth(), parsed.getDate(), 12, 0, 0); 
                    } 
                } catch (e) {} 
                console.warn("Data inválida recebida para parseDate:", dateString);
                return new Date('invalid date'); 
            }

            calculateRecurringDate(baseDate, period, multiplier) { 
                const newDate = this.parseDate(baseDate.toISOString()); 
                if (isNaN(newDate.getTime())) return new Date('invalid date'); 
                
                switch (period) { 
                    case 'days': newDate.setDate(newDate.getDate() + multiplier); break; 
                    case 'weeks': newDate.setDate(newDate.getDate() + (multiplier * 7)); break; 
                    case 'months': 
                        const originalDay = newDate.getDate(); 
                        newDate.setMonth(newDate.getMonth() + multiplier); 
                        if (newDate.getDate() !== originalDay) { 
                            newDate.setDate(0); 
                        } 
                        break; 
                    case 'years': newDate.setFullYear(newDate.getFullYear() + multiplier); break; 
                } 
                return newDate; 
            }
            
			
            showTransactionModal(transaction = null) {
                const isEdit = transaction !== null;
                const modalTitle = isEdit ? 'Editar Transação' : 'Nova Transação';
                const isBasicPlan = this.PLAN_CONFIG === 'basico';

                const incomeCategories = this.data.categories.income.map(c =>
                    `<option value="${c.id}">${c.name}</option>`).join('');
                const expenseCategories = this.data.categories.expense.map(c =>
                    `<option value="${c.id}">${c.name}</option>`).join('');
                const accounts = this.data.accounts.map(a =>
                    `<option value="${a.id}">${a.name}</option>`).join('');
                const cards = this.data.cards.map(c =>
                    `<option value="${c.id}">${c.name} (*${c.lastDigits})</option>`).join('');
                
                const months = [];
                const currentDateForMonths = new Date();
                for (let i = -6; i < 18; i++) {
                    const dateLoop = new Date(currentDateForMonths.getFullYear(), currentDateForMonths.getMonth() + i, 1);
                    const monthYear = `${this.getMonthName(dateLoop.getMonth())}/${dateLoop.getFullYear()}`;
                    const value = `${dateLoop.getMonth()},${dateLoop.getFullYear()}`; 
                    months.push(`<option value="${value}">${monthYear}</option>`);
                }

let defaultType = 'expense', defaultDescription = '', defaultAmount = '', defaultCategory = '';
let defaultAccount = this.data.accounts.length > 0 ? this.data.accounts[0].id : '';
let defaultCard = this.data.cards.length > 0 ? this.data.cards[0].id : '';
let defaultSourceAccount = defaultAccount;
let defaultDestAccount = this.data.accounts.length > 1 ? this.data.accounts[1].id : defaultAccount;
let defaultDate = this.formatInputDate(new Date()); 
let defaultCompleted = isBasicPlan ? true : true; // No plano básico sempre será true
let defaultRecurring = isBasicPlan ? false : false; // No plano básico sempre será false
let defaultRecurringType = 'installment';
let defaultRecurringFrequency = '1', defaultRecurringPeriod = 'months';
let defaultCurrentInstallment = 1, defaultTotalInstallments = 1;
let defaultInvoiceMonthYear = `${this.currentMonth},${this.currentYear}`; 

if (isEdit) {
    defaultType = transaction.type; 
    defaultDescription = transaction.description; 
    defaultAmount = this.formatValueForEdit(transaction.amount); 
    // Para transações de cartão, não precisamos da data original
    if (transaction.type !== 'card') {
        defaultDate = this.formatInputDate(this.parseDate(transaction.date)); 
    }
    if (transaction.type === 'income' || transaction.type === 'expense' || transaction.type === 'transfer') { 
        defaultCompleted = isBasicPlan ? true : transaction.completed; 
    }
    if (transaction.type === 'income' || transaction.type === 'expense') { 
        defaultCategory = transaction.category; 
        defaultAccount = transaction.account; 
    } else if (transaction.type === 'transfer') { 
        defaultSourceAccount = transaction.sourceAccount; 
        defaultDestAccount = transaction.destAccount; 
    } else if (transaction.type === 'card') { 
        defaultCard = transaction.card; 
        if (transaction.invoiceMonth !== undefined && transaction.invoiceYear !== undefined) { 
            defaultInvoiceMonthYear = `${transaction.invoiceMonth},${transaction.invoiceYear}`; 
        } 
        defaultCategory = transaction.category || ''; 
    }
    if (!isBasicPlan && transaction.recurring) { 
        defaultRecurring = true; 
        defaultRecurringType = transaction.recurringType; 
        defaultRecurringFrequency = transaction.recurringFrequency; 
        defaultRecurringPeriod = transaction.recurringPeriod; 
        defaultCurrentInstallment = transaction.currentInstallment; 
        defaultTotalInstallments = transaction.totalInstallments; 
    }
}

                const modalContentEl = document.getElementById('modalContent');
                modalContentEl.innerHTML = `
                    <div class="modal-header"><h3 class="modal-title">${modalTitle}</h3><button class="modal-close" id="modalCloseTransaction">&times;</button></div>
                    <div class="modal-body">
                        <div class="form-row"><label class="form-label">Tipo de Transação</label><div style="display: flex; gap: 10px; flex-wrap: wrap;"><div class="form-check"><input type="radio" name="transactionType" id="typeIncome" value="income" ${defaultType === 'income' ? 'checked' : ''}><label for="typeIncome">Receita</label></div><div class="form-check"><input type="radio" name="transactionType" id="typeExpense" value="expense" ${defaultType === 'expense' ? 'checked' : ''}><label for="typeExpense">Despesa</label></div><div class="form-check"><input type="radio" name="transactionType" id="typeTransfer" value="transfer" ${defaultType === 'transfer' ? 'checked' : ''}><label for="typeTransfer">Transferência</label></div><div class="form-check"><input type="radio" name="transactionType" id="typeCard" value="card" ${defaultType === 'card' ? 'checked' : ''}><label for="typeCard">Despesa Cartão</label></div></div></div>
                        <div class="form-row"><label class="form-label" for="description">Descrição</label><input type="text" class="form-input" id="description" value="${defaultDescription}"></div>
                        <div class="form-row">
                            <label class="form-label" for="amount">Valor</label>
                            <input type="text" class="form-input" id="amount" value="${defaultAmount}" placeholder="0,00">
                        </div>
                        ${!isBasicPlan ? `<div class="form-row"><div class="form-check"><input type="checkbox" id="recurring" ${defaultRecurring ? 'checked' : ''}><label for="recurring">Recorrente</label></div></div>` : ''}
                        ${!isBasicPlan ? `<div id="recurringOptions" ${!defaultRecurring ? 'style="display: none;"' : ''}>
                            <div class="form-row"><label class="form-label">Tipo de Recorrência</label><div style="display: flex; gap: 10px;"><div class="form-check"><input type="radio" name="recurringType" id="typeInstallment" value="installment" ${defaultRecurringType === 'installment' ? 'checked' : ''}><label for="typeInstallment">Parcelado</label></div><div class="form-check"><input type="radio" name="recurringType" id="typeFixed" value="fixed" ${defaultRecurringType === 'fixed' ? 'checked' : ''}><label for="typeFixed">Fixo</label></div></div></div> <div class="form-row" id="recurringFrequencyRow"><label class="form-label">Repetir a cada</label><div style="display: flex; gap: 10px; align-items: center;"><input type="number" class="form-input" id="recurringFrequency" min="1" max="12" style="width: 80px;" value="${defaultRecurringFrequency}"><select class="form-select" id="recurringPeriod"><option value="days" ${defaultRecurringPeriod === 'days' ? 'selected' : ''}>Dias</option><option value="weeks" ${defaultRecurringPeriod === 'weeks' ? 'selected' : ''}>Semanas</option><option value="months" ${defaultRecurringPeriod === 'months' ? 'selected' : ''}>Meses</option><option value="years" ${defaultRecurringPeriod === 'years' ? 'selected' : ''}>Anos</option></select></div></div> <div class="form-row" id="installmentOptions" ${defaultRecurringType !== 'installment' ? 'style="display: none;"' : ''}>
                                <div class="form-row-inline"><div><label class="form-label" for="currentInstallment">Parcela Atual</label><input type="number" class="form-input" id="currentInstallment" min="1" value="${defaultCurrentInstallment}" ${isEdit ? 'readonly' : ''}></div><div><label class="form-label" for="totalInstallments">Total de Parcelas</label><input type="number" class="form-input" id="totalInstallments" min="1" max="999" value="${defaultTotalInstallments}"></div></div>
                                <div id="installmentValueOptions" style="margin-top: 15px;">
                                    <div style="display: flex; gap: 15px; align-items: center; font-size: 0.9rem;">
                                        <div class="form-check">
                                            <input type="radio" name="valueType" id="valueTotalRadio" value="total" checked>
                                            <label for="valueTotalRadio">Valor Total</label>
                                        </div>
                                        <div class="form-check">
                                            <input type="radio" name="valueType" id="valueInstallmentRadio" value="installment">
                                            <label for="valueInstallmentRadio">Valor da Parcela</label>
                                        </div>
                                    </div>
                                    <div id="installmentValueDisplay" style="margin-top: 10px; padding: 10px; background-color: rgba(99, 102, 241, 0.1); border-radius: 4px; font-size: 0.95rem; color: var(--primary-color); display: none;">
                                        <span id="installmentValueText"></span>
                                    </div>
                                </div>
                            </div> </div>` : ''}
                        <div class="form-row" id="categoryRow" ${defaultType === 'transfer' || defaultType === 'card' ? 'style="display: none;"' : ''}><label class="form-label" for="category">Categoria</label><select class="form-select" id="category"><option value="">Selecione uma categoria</option></select></div>
                        <div class="form-row" id="accountRow" ${defaultType === 'transfer' || defaultType === 'card' ? 'style="display: none;"' : ''}><label class="form-label" for="account">Conta</label><select class="form-select" id="account"><option value="">Selecione uma conta</option>${accounts}</select></div>
                        <div class="form-row" id="transferRow" ${defaultType !== 'transfer' ? 'style="display: none;"' : ''}><div class="form-row-inline"><div><label class="form-label" for="sourceAccount">Conta de Origem</label><select class="form-select" id="sourceAccount"><option value="">Selecione uma conta</option>${accounts}</select></div><div><label class="form-label" for="destAccount">Conta de Destino</label><select class="form-select" id="destAccount"><option value="">Selecione uma conta</option>${accounts}</select></div></div></div>
                        <div class="form-row" id="cardRow" ${defaultType !== 'card' ? 'style="display: none;"' : ''}>
    <div class="form-row"><label class="form-label" for="cardTransactionDate">Data da Compra</label><input type="date" class="form-input" id="cardTransactionDate" value="${defaultDate}"></div>
    <div class="form-row-inline">
        <div><label class="form-label" for="card">Cartão</label><select class="form-select" id="card"><option value="">Selecione um cartão</option>${cards}</select></div>
        <div><label class="form-label" for="invoiceMonthYear">Mês da Fatura</label><select class="form-select" id="invoiceMonthYear">${months.join('')}</select></div>
    </div>
     <div class="form-row" id="cardCategoryRow"><label class="form-label" for="cardCategory">Categoria da Despesa do Cartão</label><select class="form-select" id="cardCategory"><option value="">Selecione uma categoria</option></select></div>
</div>
                        <div class="form-row" id="dateRow" ${defaultType === 'card' ? 'style="display: none;"' : ''}><label class="form-label" for="transactionDate">Data</label><input type="date" class="form-input" id="transactionDate" value="${defaultDate}"></div>
                        ${!isBasicPlan ? `<div class="form-row" id="completedRow" ${defaultType === 'card' ? 'style="display: none;"' : ''}><div class="form-check"><input type="checkbox" id="completed" ${defaultCompleted ? 'checked' : ''}><label for="completed">Realizada</label></div></div>` : ''}
                    </div>
                    <div class="form-footer"><button class="btn btn-outlined" id="cancelTransactionBtn">Cancelar</button><button class="btn btn-primary" id="saveTransactionBtn">${isEdit ? 'Atualizar' : 'Salvar'}</button></div>
                `;
                document.getElementById('modalOverlay').classList.add('active');
                const categorySelect = document.getElementById('category'); 
                const cardCategorySelect = document.getElementById('cardCategory');
                const accountSelect = document.getElementById('account'); 
                const sourceAccountSelect = document.getElementById('sourceAccount'); 
                const destAccountSelect = document.getElementById('destAccount'); 
                const cardSelect = document.getElementById('card'); 
                const invoiceMonthYearSelect = document.getElementById('invoiceMonthYear');
                
                const updateCategoryOptions = (type) => { 
                    let optionsHtml = '<option value="">Selecione uma categoria</option>'; 
                    let targetSelect = categorySelect;

                    if (type === 'income') { 
                        optionsHtml += incomeCategories; 
                        document.getElementById('categoryRow').style.display = 'block';
                        document.getElementById('cardCategoryRow').style.display = 'none';
                    } else if (type === 'expense') { 
                        optionsHtml += expenseCategories; 
                        document.getElementById('categoryRow').style.display = 'block';
                        document.getElementById('cardCategoryRow').style.display = 'none';
                    } else if (type === 'card') {
                        optionsHtml += expenseCategories;
                        targetSelect = cardCategorySelect;
                        document.getElementById('categoryRow').style.display = 'none';
                        document.getElementById('cardCategoryRow').style.display = 'block';
                    } else { 
                        document.getElementById('categoryRow').style.display = 'none';
                        document.getElementById('cardCategoryRow').style.display = 'none';
                    }
                    targetSelect.innerHTML = optionsHtml; 

                    if (isEdit && type === transaction?.type) { 
                        targetSelect.value = defaultCategory; 
                    } else {
                        targetSelect.value = ''; 
                    }
                };
                updateCategoryOptions(defaultType); 

                if (isEdit) { 
                    if (defaultType === 'income' || defaultType === 'expense') { 
                        if(accountSelect) accountSelect.value = defaultAccount; 
                    } else if (defaultType === 'transfer') { 
                        if(sourceAccountSelect) sourceAccountSelect.value = defaultSourceAccount; 
                        if(destAccountSelect) destAccountSelect.value = defaultDestAccount; 
                    } else if (defaultType === 'card') { 
                        if(cardSelect) cardSelect.value = defaultCard; 
                        if(invoiceMonthYearSelect) invoiceMonthYearSelect.value = defaultInvoiceMonthYear; 
                        if(cardCategorySelect) cardCategorySelect.value = defaultCategory;
                    } 
                } else { 
                    if(accountSelect) accountSelect.value = defaultAccount; 
                    if(sourceAccountSelect) sourceAccountSelect.value = defaultSourceAccount; 
                    if(destAccountSelect) destAccountSelect.value = defaultDestAccount; 
                    if(cardSelect) cardSelect.value = defaultCard;
                    if(invoiceMonthYearSelect && defaultType === 'card') invoiceMonthYearSelect.value = defaultInvoiceMonthYear;
                    if(cardCategorySelect && defaultType === 'card') cardCategorySelect.value = ''; 
                }

                document.getElementById('modalCloseTransaction').addEventListener('click', () => this.closeModal()); 
                document.getElementById('cancelTransactionBtn').addEventListener('click', () => this.closeModal());
                const updateRecurringPeriodOptions = (transactionType) => {
    const recurringPeriodSelect = document.getElementById('recurringPeriod');
    const recurringFrequencyRow = document.getElementById('recurringFrequencyRow');
    const frequencyInput = document.getElementById('recurringFrequency');
    
    if (!recurringPeriodSelect) return;
    
    if (transactionType === 'card') {
        // Para cartão, esconder completamente a seção "Repetir a cada"
        if (recurringFrequencyRow) {
            recurringFrequencyRow.style.display = 'none';
        }
        
        // Fixar os valores automaticamente para cartão
        recurringPeriodSelect.innerHTML = `<option value="months" selected>Meses</option>`;
        recurringPeriodSelect.value = 'months';
        
        if (frequencyInput) {
            frequencyInput.value = '1';
        }
    } else {
        // Para outros tipos, mostrar a seção "Repetir a cada" e todas as opções
        if (recurringFrequencyRow) {
            recurringFrequencyRow.style.display = 'block';
        }
        
        recurringPeriodSelect.innerHTML = `
            <option value="days">Dias</option>
            <option value="weeks">Semanas</option>
            <option value="months" selected>Meses</option>
            <option value="years">Anos</option>
        `;
        recurringPeriodSelect.value = 'months';
    }
};
                document.querySelectorAll('input[name="transactionType"]').forEach(radio => { 
                    radio.addEventListener('change', (e) => { 
                        const type = e.target.value; 
                        
                        // Interceptar tentativas de usar funcionalidades bloqueadas
                        if (type === 'transfer' && !this.isFeatureAvailable('transfers')) {
                            e.preventDefault();
                            radio.checked = false;
                            // Voltar para o tipo anterior (expense como padrão)
                            document.querySelector('input[name="transactionType"][value="expense"]').checked = true;
                            this.showUpgradeModal('transfers');
                            return;
                        }
                        
                        if (type === 'card' && !this.isFeatureAvailable('cards')) {
                            e.preventDefault();
                            radio.checked = false;
                            // Voltar para o tipo anterior (expense como padrão)
                            document.querySelector('input[name="transactionType"][value="expense"]').checked = true;
                            this.showUpgradeModal('cards');
                            return;
                        }
                        
                        updateCategoryOptions(type); 
                        updateRecurringPeriodOptions(type); // Adicionar esta linha
                        document.getElementById('accountRow').style.display = (type === 'income' || type === 'expense') ? 'block' : 'none'; 
                        document.getElementById('transferRow').style.display = type === 'transfer' ? 'block' : 'none'; 
                        document.getElementById('cardRow').style.display = type === 'card' ? 'block' : 'none'; 
                        document.getElementById('dateRow').style.display = type === 'card' ? 'none' : 'block'; 
                        document.getElementById('completedRow').style.display = type === 'card' ? 'none' : 'block'; 
                        
                        if (!isEdit) { 
                            if (type === 'card') { 
                                document.getElementById('cardTransactionDate').value = this.formatInputDate(new Date()); 
                                document.getElementById('invoiceMonthYear').value = `${this.currentMonth},${this.currentYear}`; 
                            } else { 
                                document.getElementById('transactionDate').value = this.formatInputDate(new Date()); 
                            } 
                        }
                    }); 
                });

                const recurringCheckbox = document.getElementById('recurring');
                if (recurringCheckbox) {
                    recurringCheckbox.addEventListener('change', (e) => { 
                        const recurringOptions = document.getElementById('recurringOptions');
                        
                        if (e.target.checked) {
                            recurringOptions.style.display = 'block';
                        } else {
                            recurringOptions.style.display = 'none';
                        }
                        
                        this.updateInstallmentValueDisplay();
                    });
                }
                
                document.querySelectorAll('input[name="recurringType"]').forEach(radio => { 
                    radio.addEventListener('change', (e) => { 
                        const installmentOptions = document.getElementById('installmentOptions');
                        
                        if (e.target.value === 'installment') {
                            installmentOptions.style.display = 'block';
                            document.getElementById('totalInstallments').value = defaultTotalInstallments > 1 ? defaultTotalInstallments : 12;
                        } else {
                            installmentOptions.style.display = 'none';
                            document.getElementById('totalInstallments').value = 999;
                        }
                        
                        this.updateInstallmentValueDisplay();
                    }); 
                });


                

                // Inicializar as opções de período baseado no tipo padrão
                updateRecurringPeriodOptions(defaultType);

                // Event listeners para atualizar o display em tempo real
                const amountInput = document.getElementById('amount');
                
                // Configurar formatação para o campo amount
                this.setupCurrencyMask('amount');
                
                const totalInstallmentsElement = document.getElementById('totalInstallments');
                if (totalInstallmentsElement) {
                    totalInstallmentsElement.addEventListener('input', () => this.updateInstallmentValueDisplay());
                }
                
                const currentInstallmentElement = document.getElementById('currentInstallment');
                if (currentInstallmentElement) {
                    currentInstallmentElement.addEventListener('input', () => this.updateInstallmentValueDisplay());
                }
                
                document.querySelectorAll('input[name="valueType"]').forEach(radio => {
                    radio.addEventListener('change', () => this.updateInstallmentValueDisplay());
                });
                
                document.querySelectorAll('input[name="recurringType"]').forEach(radio => {
                    radio.addEventListener('change', () => this.updateInstallmentValueDisplay());
                });

                // Chamada inicial para configurar o estado correto
                this.updateInstallmentValueDisplay();

                // Configurar estado inicial se estiver editando uma transação parcelada
                if (isEdit && !isBasicPlan && defaultRecurring) {
                    const installmentValueOptions = document.getElementById('installmentValueOptions');
                    if (installmentValueOptions) {
                        this.updateInstallmentValueDisplay();
                    }
                }
				
                document.getElementById('saveTransactionBtn').addEventListener('click', () => {
                    const type = document.querySelector('input[name="transactionType"]:checked').value; 
                    const description = document.getElementById('description').value; 
                    const amountInput = this.parseValueInput(document.getElementById('amount').value);
                    if (!description || isNaN(amountInput) || amountInput <= 0) { 
                        this.notificationSystem.show('Erro', 'Descrição e valor são obrigatórios e o valor deve ser positivo!', 'error'); 
                        return; 
                    }

                    // Calcular o valor correto por parcela baseado na escolha do usuário
                    let amount = amountInput;
                    const recurring = isBasicPlan ? false : (document.getElementById('recurring')?.checked || false);
                    const recurringType = recurring ? document.querySelector('input[name="recurringType"]:checked')?.value : '';
                    
                    if (recurring && recurringType === 'installment') {
                        const valueType = document.querySelector('input[name="valueType"]:checked')?.value || 'total';
                        const totalInstallments = parseInt(document.getElementById('totalInstallments').value) || 1;
                        
                        if (valueType === 'total') {
                            // Se for valor total, dividir pelo número de parcelas
                            amount = amountInput / totalInstallments;
                        }
                        // Se for valor da parcela, usar o valor como está
                    }
                    let categoryId = '', accountId = '', sourceAccountId = '', destAccountId = '', cardId = ''; 
                    let invoiceMonth = 0, invoiceYear = 0, transactionDateStr, completed = true;

                    if (type === 'income' || type === 'expense') { 
                        categoryId = document.getElementById('category').value; 
                        accountId = document.getElementById('account').value; 
                        transactionDateStr = document.getElementById('transactionDate').value; 
                        completed = isBasicPlan ? true : (document.getElementById('completed')?.checked || false); 
                        if (!categoryId || !accountId) { 
                            this.notificationSystem.show('Erro', 'Selecione uma categoria e uma conta!', 'error'); 
                            return; 
                        } 
                    } else if (type === 'transfer') { 
                        sourceAccountId = document.getElementById('sourceAccount').value; 
                        destAccountId = document.getElementById('destAccount').value; 
                        transactionDateStr = document.getElementById('transactionDate').value; 
                        completed = isBasicPlan ? true : (document.getElementById('completed')?.checked || false); 
                        if (!sourceAccountId || !destAccountId) { 
                            this.notificationSystem.show('Erro', 'Selecione as contas de origem e destino!', 'error'); 
                            return; 
                        } 
                        if (sourceAccountId === destAccountId) { 
                            this.notificationSystem.show('Erro', 'As contas de origem e destino não podem ser iguais!', 'error'); 
                            return; 
                        } 
                    } else if (type === 'card') { 
    cardId = document.getElementById('card').value; 
    const invoiceMonthYearValue = document.getElementById('invoiceMonthYear').value; 
    categoryId = document.getElementById('cardCategory').value;
    completed = false; 
    if (!cardId || !invoiceMonthYearValue || !categoryId) { 
        this.notificationSystem.show('Erro', 'Selecione o cartão, o mês da fatura e a categoria da despesa!', 'error'); 
        return; 
    } 
    [invoiceMonth, invoiceYear] = invoiceMonthYearValue.split(',').map(Number); 
    
    // Para transações de cartão, usar sempre o primeiro dia do mês da fatura como data
    const faturaDate = new Date(invoiceYear, invoiceMonth, 1, 12, 0, 0);
    transactionDateStr = this.formatInputDate(faturaDate);
}
                    const transactionDate = this.parseDate(transactionDateStr);
if (!transactionDate || isNaN(transactionDate.getTime())) { 
    this.notificationSystem.show('Erro', 'Data da transação inválida!', 'error'); 
    return; 
}



                    
                    let recurringFrequency = 1, recurringPeriod = 'months'; 
                    let currentInstallment = 1, totalInstallments = 1;
                    if (recurring) { 
                        // recurringType já foi declarado anteriormente
                        recurringFrequency = parseInt(document.getElementById('recurringFrequency').value); 
                        recurringPeriod = document.getElementById('recurringPeriod').value; 
                        currentInstallment = isEdit ? (transaction.currentInstallment || 1) : parseInt(document.getElementById('currentInstallment').value);
                        totalInstallments = parseInt(document.getElementById('totalInstallments').value); 
                        if (isNaN(recurringFrequency) || recurringFrequency <= 0) { 
                            this.notificationSystem.show('Erro', 'Frequência de recorrência inválida!', 'error'); 
                            return; 
                        } 
                        if (recurringType === 'installment') { 
                            if (isNaN(currentInstallment) || currentInstallment <= 0 || isNaN(totalInstallments) || totalInstallments <= 0 || currentInstallment > totalInstallments) { 
                                this.notificationSystem.show('Erro', 'Informações de parcelas inválidas!', 'error'); 
                                return; 
                            } 
                        } else { 
                            totalInstallments = 999; 
                        } 
                    }
                    const transactionObjBase = { 
                        id: isEdit ? transaction.id : this.generateId(), 
                        type, 
                        description, 
                        amount, 
                        date: this.adjustDateForTimezone(transactionDate).toISOString(), 
                        completed, 
                        recurring: false 
                    };
                    if (type === 'income' || type === 'expense') { 
                        transactionObjBase.category = categoryId; 
                        transactionObjBase.account = accountId; 
                    } else if (type === 'transfer') { 
                        transactionObjBase.sourceAccount = sourceAccountId; 
                        transactionObjBase.destAccount = destAccountId; 
                    } else if (type === 'card') { 
                        transactionObjBase.card = cardId; 
                        transactionObjBase.invoiceMonth = invoiceMonth; 
                        transactionObjBase.invoiceYear = invoiceYear; 
                        transactionObjBase.category = categoryId; 
                    }

                    if (recurring) { 
                        const recurringGroupId = (isEdit && transaction.recurringGroupId) ? transaction.recurringGroupId : this.generateId(); 
                        if (isEdit) { 
                            const applyToFuture = transaction.recurring && confirm('Aplicar alterações a esta e todas as parcelas futuras (se houver)? "Cancelar" altera apenas esta parcela.'); 
                            if (applyToFuture) { 
                                this.data.transactions = this.data.transactions.filter(t => !(t.recurringGroupId === recurringGroupId && t.currentInstallment > transaction.currentInstallment)); 
                                const index = this.data.transactions.findIndex(t => t.id === transaction.id);
                                if (index !== -1) {
                                    this.data.transactions[index] = {
                                        ...transactionObjBase,
                                        recurring: true, recurringType, recurringFrequency, recurringPeriod,
                                        currentInstallment: transaction.currentInstallment, 
                                        totalInstallments, recurringGroupId,
                                        completed: type === 'card' ? false : completed 
                                    };
                                }
                                const startInstallmentForNew = transaction.currentInstallment + 1;
                                const maxInstallments = recurringType === 'installment' ? totalInstallments : (transaction.currentInstallment + 998); 

                                for (let i = startInstallmentForNew; i <= maxInstallments; i++) {
                                    if (recurringType === 'installment' && i > totalInstallments) break;

                                    const installmentDiff = i - transaction.currentInstallment;
                                    const currentParcelDate = this.calculateRecurringDate(this.parseDate(transactionObjBase.date), recurringPeriod, recurringFrequency * installmentDiff);
                                    const newTransaction = { 
                                        ...transactionObjBase, 
                                        id: this.generateId(), 
                                        date: this.adjustDateForTimezone(currentParcelDate).toISOString(), 
                                        recurring: true, recurringType, recurringFrequency, recurringPeriod, 
                                        currentInstallment: i, totalInstallments, recurringGroupId, 
                                        completed: false 
                                    }; 
                                    if (type === 'card') { 
                                        const { invoiceMonth: invM, invoiceYear: invY } = this.getInvoiceMonthYearForCardPurchase(currentParcelDate, this.data.cards.find(c => c.id === cardId)?.dueDay);
                                        newTransaction.invoiceMonth = invM; 
                                        newTransaction.invoiceYear = invY; 
                                    } 
                                    this.data.transactions.push(newTransaction); 
                                    if (recurringType === 'fixed' && (i - transaction.currentInstallment) >= 998) { 
                                        this.notificationSystem.show('Aviso', 'Transações fixas são limitadas a aproximadamente 999 ocorrências futuras.', 'warning'); 
                                        break; 
                                    }
                                }

                            } else { 
                                const index = this.data.transactions.findIndex(t => t.id === transaction.id); 
                                if (index !== -1) { 
                                    this.data.transactions[index] = { 
                                        ...transactionObjBase, 
                                        recurring: transaction.recurring, 
                                        recurringType: transaction.recurringType, 
                                        recurringFrequency: transaction.recurringFrequency, 
                                        recurringPeriod: transaction.recurringPeriod, 
                                        currentInstallment: transaction.currentInstallment, 
                                        totalInstallments: transaction.totalInstallments, 
                                        recurringGroupId: transaction.recurringGroupId 
                                    }; 
                                    if (!document.getElementById('recurring').checked) { 
                                        this.data.transactions[index].recurring = false;
                                        delete this.data.transactions[index].recurringGroupId;
                                        delete this.data.transactions[index].recurringType;
                                    }
                                } 
                            } 
                        } else { 
                            const numberOfInstallmentsToAdd = (recurringType === 'installment') ? (totalInstallments - currentInstallment + 1) : 999; 
                            
                            for (let i = 0; i < numberOfInstallmentsToAdd; i++) { 
    const installmentNumber = currentInstallment + i; 
    if (recurringType === 'installment' && installmentNumber > totalInstallments) break;

    const currentParcelDate = this.calculateRecurringDate(transactionDate, recurringPeriod, recurringFrequency * i); 
    const newTransaction = { 
        ...transactionObjBase, 
        id: i === 0 ? transactionObjBase.id : this.generateId(), 
        date: this.adjustDateForTimezone(currentParcelDate).toISOString(), 
        recurring: true, recurringType, recurringFrequency, recurringPeriod, 
        currentInstallment: installmentNumber, totalInstallments, recurringGroupId, 
        completed: type === 'card' ? false : (i === 0 ? completed : false) 
    }; 
    if (type === 'card') { 
        // Para transações de cartão, usar o mês escolhido pelo usuário e incrementar para parcelas seguintes
        let targetInvoiceMonth = invoiceMonth + i;
        let targetInvoiceYear = invoiceYear;
        
        // Ajustar ano se o mês ultrapassar dezembro
        while (targetInvoiceMonth > 11) {
            targetInvoiceMonth -= 12;
            targetInvoiceYear++;
        }
        
        newTransaction.invoiceMonth = targetInvoiceMonth; 
        newTransaction.invoiceYear = targetInvoiceYear; 
    } 
    this.data.transactions.push(newTransaction); 
    if (recurringType === 'fixed' && i >= 998) { 
        this.notificationSystem.show('Aviso', 'Transações fixas são limitadas a 999 ocorrências futuras.', 'warning'); 
        break; 
    } 
}
                        } 
                    } else { 
                        if (isEdit) { 
                            if (transaction.recurring && transaction.recurringGroupId) { 
                                this.data.transactions = this.data.transactions.filter(t => !(t.recurringGroupId === transaction.recurringGroupId && t.currentInstallment > transaction.currentInstallment)); 
                            } 
                            const index = this.data.transactions.findIndex(t => t.id === transaction.id); 
                            if (index !== -1) { 
                                this.data.transactions[index] = transactionObjBase; 
                            } 
                        } else { 
                            this.data.transactions.push(transactionObjBase); 
                        } 
                    }
                    this.saveData(); 
                    this.closeModal(); 
                    this.refreshView(); 
                    this.notificationSystem.show('Sucesso', `Transação ${isEdit ? 'atualizada' : 'adicionada'} com sucesso!`, 'success');
                });
            }
			renderCards(container) {
                const monthData = this.getMonthData(this.currentMonth, this.currentYear, 'all'); 

                container.innerHTML = `
                    <div class="header-actions" style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; margin-bottom: 20px;">
                        <div class="month-navigation">
                            <button class="month-nav-btn" id="prevMonthBtnCards"><i class="fas fa-chevron-left"></i></button>
                            <span class="current-month" id="currentMonthDisplayCards">${this.getMonthName(this.currentMonth)} de ${this.currentYear}</span>
                            <button class="month-nav-btn" id="nextMonthBtnCards"><i class="fas fa-chevron-right"></i></button>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;" class="toggle-switch-container">
                            <label class="toggle-switch">
                                <input type="checkbox" id="previewToggleCards" ${this.isPreviewMode ? 'checked' : ''}>
                                <span class="toggle-slider"></span>
                            </label>
                            <span class="toggle-label">Modo Previsto</span>
                        </div>
                    </div>

                    <div class="card">
                        <div class="card-header">
                            <h3 class="card-title">Meus Cartões</h3>
                            <button class="btn btn-primary" id="addCardBtn">
                                <i class="fas fa-plus"></i>
                                <span>Novo Cartão</span>
                            </button>
                        </div>
                        <div id="cardsListContainer">
                            ${this.renderCardsDetailsList(monthData.cards)} 
                        </div>
                    </div>
                `;
                
                document.getElementById('addCardBtn').addEventListener('click', () => this.showCardModal());
                
                const previewToggleCards = document.getElementById('previewToggleCards');
                if (previewToggleCards) {
                    previewToggleCards.addEventListener('change', () => {
                        if (!this.isFeatureAvailable('preview_mode')) {
                            previewToggleCards.checked = false;
                            this.showUpgradeModal('preview_mode');
                            return;
                        }
                        this.isPreviewMode = previewToggleCards.checked;
                        this.refreshView(); 
                    });
                }

                const prevMonthBtn = document.getElementById('prevMonthBtnCards'); 
                const nextMonthBtn = document.getElementById('nextMonthBtnCards'); 
                const currentMonthDisplay = document.getElementById('currentMonthDisplayCards');
                if(prevMonthBtn) prevMonthBtn.addEventListener('click', () => this.navigateMonth(-1));
                if(nextMonthBtn) nextMonthBtn.addEventListener('click', () => this.navigateMonth(1));
                if(currentMonthDisplay) { 
                    currentMonthDisplay.addEventListener('click', () => { 
                        const today = new Date(); 
                        this.currentMonth = today.getMonth(); 
                        this.currentYear = today.getFullYear(); 
                        this.refreshView(); 
                    }); 
                }
                this.attachCardEventListeners();
            }
            
            renderCardsDetailsList(cardsDataFromMonth) { 
                if (!this.isFeatureAvailable('cards') || !this.data.cards || this.data.cards.length === 0) {
                    return `<div class="no-data"><i class="fas fa-credit-card"></i><p>Nenhum cartão cadastrado ou recurso indisponível.</p></div>`;
                }

                return this.data.cards.map(originalCard => {
                    const cardMonthInfo = cardsDataFromMonth.find(cd => cd.id === originalCard.id);
                    const totalFaturaMesAtual = cardMonthInfo ? cardMonthInfo.totalFaturaMes : 0; 
                    
                    const outstandingBalance = this.calculateCardOutstandingBalance(originalCard.id); 
                    const availableLimit = originalCard.limit - outstandingBalance; 
                    
                    const nextDueDate = this.getNextDueDate(originalCard.dueDay);
                    const isPaidThisMonth = this.isCardInvoicePaid(originalCard.id, this.currentMonth, this.currentYear);
                    const statusTag = isPaidThisMonth ? '<span class="status-tag status-paid"><i class="fas fa-check-circle"></i> Fatura Paga</span>' : (totalFaturaMesAtual > 0 ? '<span class="status-tag" style="background-color: var(--warning-color); color: white;">Fatura Aberta</span>' : '<span class="status-tag" style="background-color: var(--text-light); color: white;">Sem Fatura</span>');
                    const account = this.data.accounts.find(a => a.id === originalCard.account);

                    return `
                    <div class="transaction-item">
                        <div class="transaction-info">
                            <div class="transaction-icon" style="background-color: ${originalCard.color}20; color: ${originalCard.color}">${originalCard.emoji}</div>
                            <div class="transaction-details">
                                <div class="transaction-name">${originalCard.name} (*${originalCard.lastDigits}) ${statusTag}</div>
                                <div class="transaction-category">Vencimento: Dia ${originalCard.dueDay} (Próx.: ${this.formatDateShort(nextDueDate)})${account ? `<br>Conta Débito: ${account.name}` : ''}</div>
                            </div>
                        </div>
                        <div style="text-align: right;">
                            <div class="transaction-amount expense-amount">Fatura (${this.getMonthName(this.currentMonth).substring(0,3)}): R$ ${this.formatCurrency(totalFaturaMesAtual)}</div>
                            <div style="font-size: 0.8rem; color: var(--text-light); margin-bottom: 2px;">Limite Total: R$ ${this.formatCurrency(originalCard.limit)}</div>
                            <div style="font-size: 0.8rem; font-weight: 600; color: ${availableLimit >= 0 ? 'var(--secondary-color)' : 'var(--danger-color)'};">Disponível (Total): R$ ${this.formatCurrency(availableLimit)}</div>
                            <div class="transaction-actions" style="opacity:1;">
                                <button class="action-btn view-card-btn" data-id="${originalCard.id}" title="Ver Fatura / Pagar"><i class="fas fa-eye"></i></button>
                                <button class="action-btn edit-card-btn" data-id="${originalCard.id}" title="Editar Cartão"><i class="fas fa-edit"></i></button>
                                <button class="action-btn delete-card-btn" data-id="${originalCard.id}" title="Excluir Cartão"><i class="fas fa-trash"></i></button>
                            </div>
                        </div>
                    </div>`;
                }).join('');
            }
            
            attachCardEventListeners() {
                 document.querySelectorAll('.view-card-btn').forEach(btn => { 
                    btn.addEventListener('click', () => { 
                        const id = btn.getAttribute('data-id'); 
                        this.viewCardDetails(id); 
                    }); 
                });
                 document.querySelectorAll('.edit-card-btn').forEach(btn => { 
                    btn.addEventListener('click', () => { 
                        const id = btn.getAttribute('data-id'); 
                        this.editCard(id); 
                    }); 
                });
                 document.querySelectorAll('.delete-card-btn').forEach(btn => { 
                    btn.addEventListener('click', () => { 
                        const id = btn.getAttribute('data-id'); 
                        const isInUse = this.data.transactions.some(t => t.type === 'card' && t.card === id); 
                        if (isInUse) { 
                            this.notificationSystem.show('Erro', 'Este cartão possui transações associadas e não pode ser excluído!', 'error', 7000); 
                            return; 
                        } 
                        if (confirm('Tem certeza que deseja excluir este cartão?')) { 
                            this.deleteCard(id); 
                        } 
                    }); 
                });
            }
            
            viewCardDetails(id) { 
                const card = this.data.cards.find(c => c.id === id); 
                if (!card) return;

                const monthData = this.getMonthData(this.currentMonth, this.currentYear, 'all'); 
                const cardMonthData = monthData.cards.find(cmd => cmd.id === id); 
                const totalFaturaAtual = cardMonthData ? cardMonthData.totalFaturaMes : 0;
                
                const outstandingBalance = this.calculateCardOutstandingBalance(card.id); 
                const availableLimit = card.limit - outstandingBalance; 
                
                const transactionsInCurrentInvoice = monthData.transactionsInMonth.filter(t => 
                    t.type === 'card' && t.card === id && 
                    t.invoiceMonth === this.currentMonth && t.invoiceYear === this.currentYear
                );

                const account = this.data.accounts.find(a => a.id === card.account);
                const isPaidThisMonth = this.isCardInvoicePaid(card.id, this.currentMonth, this.currentYear);
                const limitPercentage = card.limit > 0 ? Math.min(100, Math.round((outstandingBalance / card.limit) * 100)) : 0; 
                
                const modalContentEl = document.getElementById('modalContent');
                modalContentEl.innerHTML = `
                    <div class="modal-header"><h3 class="modal-title">Detalhes do Cartão ${card.name} (${this.getMonthName(this.currentMonth)}/${this.currentYear})</h3><button class="modal-close" id="modalCloseCardDetails">&times;</button></div>
                    <div class="modal-body">
                        <div style="display: flex; gap: 20px; margin-bottom: 20px; flex-wrap: wrap;">
                            <div style="flex: 1; min-width: 200px;">
                                <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 15px;">
                                    <div class="transaction-icon" style="background-color: ${card.color}20; color: ${card.color}">${card.emoji}</div>
                                    <div><div style="font-weight: 600;">${card.name}</div><div style="font-size: 0.85rem; color: var(--text-light);">**** **** **** ${card.lastDigits}</div></div>
                                </div>
                                <div style="margin-bottom: 10px;"><div style="font-size: 0.85rem; color: var(--text-light);">Limite Total</div><div style="font-weight: 600;">R$ ${this.formatCurrency(card.limit)}</div></div>
                                <div style="margin-bottom: 10px;"><div style="font-size: 0.85rem; color: var(--text-light);">Vencimento</div><div style="font-weight: 600;">Dia ${card.dueDay} de cada mês</div></div>
                                <div><div style="font-size: 0.85rem; color: var(--text-light);">Conta de Débito Padrão</div><div style="font-weight: 600;">${account ? account.name : 'Nenhuma'}</div></div>
                            </div>
                            <div style="flex: 1; min-width: 200px; border-left: 1px solid var(--border-color); padding-left: 20px;">
                                <div style="margin-bottom: 10px;"><div style="font-size: 0.85rem; color: var(--text-light);">Fatura (${this.getMonthName(this.currentMonth)}/${this.currentYear})</div><div style="font-weight: 600; font-size: 1.5rem; color: var(--danger-color);">R$ ${this.formatCurrency(totalFaturaAtual)}</div></div>
                                <div style="margin-bottom: 10px;"><div style="font-size: 0.85rem; color: var(--text-light);">Limite Disponível (Total)</div><div style="font-weight: 600; color: ${availableLimit >= 0 ? 'var(--secondary-color)' : 'var(--danger-color)'};">R$ ${this.formatCurrency(availableLimit)}</div></div>
                                <div>
                                    <div style="font-size: 0.85rem; color: var(--text-light);">Limite Utilizado (Total)</div>
                                    <div class="progress-bar" style="margin-top: 5px;"><div class="progress-fill" style="width: ${limitPercentage}%; background-color: ${limitPercentage < 70 ? 'var(--secondary-color)' : limitPercentage < 90 ? 'var(--warning-color)' : 'var(--danger-color)'};"></div></div>
                                    <div style="font-size: 0.85rem; color: var(--text-light); text-align: right; margin-top: 5px;">${limitPercentage}%</div>
                                </div>
                                ${isPaidThisMonth ? `<div style="margin-top: 15px; text-align: center;"><span class="status-tag status-paid" style="font-size: 0.9rem;"><i class="fas fa-check-circle"></i> Fatura Paga</span></div>` : (totalFaturaAtual > 0 ? `<div style="margin-top: 15px; text-align: center;"><span class="status-tag" style="font-size: 0.9rem; background-color: var(--warning-color); color:white;"><i class="fas fa-file-invoice-dollar"></i> Fatura em Aberto</span></div>` : '')}
                            </div>
                        </div>
                        <h4 style="margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color);">Transações da Fatura (${this.getMonthName(this.currentMonth)}/${this.currentYear})</h4>
                        <div style="max-height: 300px; overflow-y: auto;" id="cardInvoiceTransactionsList">
                            ${this.renderCardTransactionsForInvoiceModal(transactionsInCurrentInvoice)}
                        </div>
                    </div>
                    <div class="form-footer">
                        ${isPaidThisMonth ? `<button class="btn btn-warning reopen-card-bill" data-card="${card.id}" data-month="${this.currentMonth}" data-year="${this.currentYear}"><i class="fas fa-undo"></i><span>Reabrir Fatura</span></button>` : (totalFaturaAtual > 0 ? `<button class="btn btn-primary pay-card-bill" data-card="${card.id}" data-month="${this.currentMonth}" data-year="${this.currentYear}"><i class="fas fa-money-bill-wave"></i><span>Pagar Fatura</span></button>` : `<button class="btn btn-primary" disabled title="Fatura sem lançamentos"><i class="fas fa-money-bill-wave"></i><span>Pagar Fatura</span></button>`)}
                        <button class="btn btn-outlined" id="closeCardDetailsBtn">Fechar</button>
                    </div>`;
                document.getElementById('modalOverlay').classList.add('active');
                document.getElementById('modalCloseCardDetails').addEventListener('click', () => this.closeModal()); 
                document.getElementById('closeCardDetailsBtn').addEventListener('click', () => this.closeModal());

                const payCardBtn = modalContentEl.querySelector('.pay-card-bill'); 
                if (payCardBtn && !payCardBtn.disabled) { 
                    payCardBtn.addEventListener('click', () => { 
                        this.closeModal(); 
                        this.showPayCardBillModal(id, this.currentMonth, this.currentYear); 
                    }); 
                }
                const reopenCardBtn = modalContentEl.querySelector('.reopen-card-bill'); 
                if (reopenCardBtn) { 
                    reopenCardBtn.addEventListener('click', () => { 
                        if (confirm('Tem certeza que deseja reabrir esta fatura? As transações do cartão voltarão a ser listadas e a transação de pagamento (e saldo remanescente, se houver) será removida.')) { 
                            this.reopenCardInvoice(id, this.currentMonth, this.currentYear); 
                            this.closeModal(); 
                            this.refreshView(); 
                            this.notificationSystem.show('Fatura reaberta', 'A fatura foi reaberta com sucesso.', 'info'); 
                        } 
                    }); 
                }
                this.attachCardInvoiceTransactionEventListeners(id); 
            }
            
            renderCardTransactionsForInvoiceModal(transactions) {
                if (!transactions || transactions.length === 0) { 
                    return `<div class="no-data"><i class="fas fa-exchange-alt"></i><p>Nenhuma transação nesta fatura.</p></div>`; 
                }
                transactions.sort((a, b) => this.parseDate(a.date) - this.parseDate(b.date)); 
                return transactions.map(transaction => { 
                    const category = transaction.category ? this.data.categories.expense.find(c => c.id === transaction.category) : null; 
                    const installmentInfo = transaction.recurring && transaction.recurringType === 'installment' ? ` (${transaction.currentInstallment}/${transaction.totalInstallments})` : ''; 
                    
                    return `
                        <div class="transaction-item">
                            <div class="transaction-info">
                                <div class="transaction-icon card-expense-icon" style="flex-shrink: 0;"><i class="fas fa-shopping-cart"></i></div>
                                <div class="transaction-details">
                                    <div class="transaction-name" title="${transaction.description}">${transaction.description} ${installmentInfo}</div>
                                    <div class="transaction-category">${this.formatDateShort(this.parseDate(transaction.date))} - ${category ? category.name : 'Sem Categoria'}</div>
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <div class="transaction-amount expense-amount">R$ ${this.formatCurrency(transaction.amount)}</div>
                                <div class="transaction-actions" style="opacity:1;">
                                    <button class="action-btn edit-card-invoice-trans-btn" data-id="${transaction.id}" title="Editar Transação"><i class="fas fa-edit"></i></button>
                                    <button class="action-btn delete-card-invoice-trans-btn" data-id="${transaction.id}" title="Excluir Transação"><i class="fas fa-trash"></i></button>
                                </div>
                            </div>
                        </div>`;
                }).join('');
            }


            attachCardInvoiceTransactionEventListeners(cardIdForRefresh) { 
                const transactionListContainer = document.getElementById('cardInvoiceTransactionsList'); 
                if (!transactionListContainer) return;

                transactionListContainer.addEventListener('click', (event) => { 
                    const target = event.target; 
                    const editBtn = target.closest('.edit-card-invoice-trans-btn'); 
                    const deleteBtn = target.closest('.delete-card-invoice-trans-btn'); 
                    
                    if (editBtn) { 
                        const transactionId = editBtn.getAttribute('data-id'); 
                        this.closeModal(); 
                        this.editTransaction(transactionId); 
                    } else if (deleteBtn) { 
                        const transactionId = deleteBtn.getAttribute('data-id'); 
                        const transaction = this.data.transactions.find(t => t.id === transactionId);
                        if (transaction && (transaction.isInvoicePayment || transaction.isCarriedOverBalance)) {
                             this.notificationSystem.show('Aviso', 'Este tipo de transação não pode ser excluída diretamente.', 'warning');
                            return;
                        }

                        if (confirm('Tem certeza que deseja excluir esta transação da fatura?')) { 
                            this.deleteTransaction(transactionId); 
                            this.notificationSystem.show('Sucesso', 'Transação removida da fatura. Atualizando detalhes...', 'success', 2000); 
                            this.closeModal();
                            setTimeout(() => {
                                 if(this.currentView === 'cards') this.refreshView(); 
                                 else this.viewCardDetails(cardIdForRefresh); 
                            }, 100);
                        } 
                    } 
                });
            }
            
            editCard(id) { 
                const card = this.data.cards.find(c => c.id === id); 
                if (card) { 
                    this.showCardModal(card); 
                } 
            }
            deleteCard(id) { 
                this.data.cards = this.data.cards.filter(c => c.id !== id); 
                this.saveData(); 
                this.refreshView(); 
                this.notificationSystem.show('Sucesso', 'Cartão excluído com sucesso!', 'success'); 
            }
            
            showCardModal(card = null) {
                const isEdit = card !== null; 
                const modalTitle = isEdit ? 'Editar Cartão' : 'Novo Cartão'; 
                
                if (!isEdit) {
    const currentCount = this.data.cards.length;
    if (!this.checkPlanLimits('cards', currentCount)) {
        const limits = this.getPlanLimits();
        if (limits.cards === 0) {
            this.notificationSystem.show('Recurso Indisponível', 'Gerenciamento de cartões não está disponível em seu plano atual.', 'warning');
        } else {
            const limitText = limits.cards === -1 ? 'ilimitados' : limits.cards;
            this.notificationSystem.show('Limite Atingido', `Você atingiu o limite de ${limitText} cartões para seu plano atual.`, 'warning');
        }
        this.showUpgradeModal('cards');
        return;
    }
}

                const accountOptions = this.data.accounts.map(account => 
                    `<option value="${account.id}" ${isEdit && card.account === account.id ? 'selected' : (this.data.accounts.length > 0 && !isEdit && account.id === this.data.accounts[0].id ? 'selected' : '')}>${account.name}</option>`
                ).join('');

                const modalContentEl = document.getElementById('modalContent'); 
                modalContentEl.innerHTML = `
                    <div class="modal-header"><h3 class="modal-title">${modalTitle}</h3><button class="modal-close" id="modalCloseCard">&times;</button></div>
                    <div class="modal-body">
                        <div class="form-row"><label class="form-label" for="cardName">Nome</label><input type="text" class="form-input" id="cardName" value="${isEdit ? card.name : ''}"></div>
                        <div class="form-row"><label class="form-label">Emoji</label><div class="emoji-picker" id="cardEmojiPicker">${this.renderEmojiPicker(isEdit ? card.emoji : '💳')}</div></div>
                        <div class="form-row"><label class="form-label">Cor</label><div class="color-picker" id="cardColorPicker">${this.renderColorPicker(isEdit ? card.color : this.colorList[5])}</div></div>
                        <div class="form-row-inline">
                            <div class="form-row"><label class="form-label" for="cardLimit">Limite</label><input type="text" class="form-input" id="cardLimit" placeholder="0,00" value="${isEdit ? this.formatValueForEdit(card.limit) : ''}"></div>
                            <div class="form-row"><label class="form-label" for="cardDueDay">Dia de Vencimento</label><input type="number" class="form-input" id="cardDueDay" min="1" max="31" value="${isEdit ? card.dueDay : 1}"></div>
                        </div>
                        <div class="form-row"><label class="form-label" for="cardLastDigits">Últimos 4 dígitos</label><input type="text" class="form-input" id="cardLastDigits" maxlength="4" pattern="[0-9]{4}" placeholder="1234" value="${isEdit ? card.lastDigits : ''}"></div>
                        <div class="form-row"><label class="form-label" for="cardAccount">Conta para Débito da Fatura (Obrigatório)</label><select class="form-select" id="cardAccount" required><option value="">Selecione uma conta</option>${accountOptions}</select></div>
                    </div>
                    <div class="form-footer"><button class="btn btn-outlined" id="cancelCardBtn">Cancelar</button><button class="btn btn-primary" id="saveCardBtn">${isEdit ? 'Atualizar' : 'Salvar'}</button></div>`;
                
                document.getElementById('modalOverlay').classList.add('active'); 
                this.setupCurrencyMask('cardLimit');
                document.getElementById('modalCloseCard').addEventListener('click', () => this.closeModal()); 
                document.getElementById('cancelCardBtn').addEventListener('click', () => this.closeModal());

                document.querySelectorAll('#cardEmojiPicker .emoji-item').forEach(item => { 
                    item.addEventListener('click', () => { 
                        document.querySelectorAll('#cardEmojiPicker .emoji-item').forEach(i => i.classList.remove('selected')); 
                        item.classList.add('selected'); 
                    }); 
                }); 
                document.querySelectorAll('#cardColorPicker .color-item').forEach(item => { 
                    item.addEventListener('click', () => { 
                        document.querySelectorAll('#cardColorPicker .color-item').forEach(i => i.classList.remove('selected')); 
                        item.classList.add('selected'); 
                    }); 
                });

                const lastDigitsInput = document.getElementById('cardLastDigits'); 
                lastDigitsInput.addEventListener('input', () => { 
                    lastDigitsInput.value = lastDigitsInput.value.replace(/[^0-9]/g, ''); 
                });

                document.getElementById('saveCardBtn').addEventListener('click', () => { 
                    const name = document.getElementById('cardName').value; 
                    const selectedEmojiEl = document.querySelector('#cardEmojiPicker .emoji-item.selected'); 
                    const selectedColorEl = document.querySelector('#cardColorPicker .color-item.selected'); 
                    const limitInput = document.getElementById('cardLimit').value; 
                    const dueDayInput = document.getElementById('cardDueDay').value; 
                    const lastDigits = document.getElementById('cardLastDigits').value; 
                    const accountId = document.getElementById('cardAccount').value; 
                    
                    const limit = this.parseValueInput(limitInput) || 0; 
                    const dueDay = parseInt(dueDayInput) || 1; 

                    if (!name || !selectedEmojiEl || !selectedColorEl || isNaN(limit) || limit < 0 || isNaN(dueDay) || dueDay < 1 || dueDay > 31 || (lastDigits.length !== 0 && lastDigits.length !== 4) || !accountId) { 
                        this.notificationSystem.show('Erro', 'Preencha todos os campos corretamente! A conta de débito é obrigatória. Últimos dígitos devem ser 4 números ou vazio.', 'error', 7000); 
                        return; 
                    } 
                    if (lastDigits.length > 0 && !/^\d{4}$/.test(lastDigits)) {
                        this.notificationSystem.show('Erro', 'Últimos 4 dígitos devem conter apenas números.', 'error');
                        return;
                    }

                    const emoji = selectedEmojiEl.textContent; 
                    const color = selectedColorEl.getAttribute('data-color'); 
                    const cardObj = { id: isEdit ? card.id : this.generateId(), name, emoji, color, limit, dueDay, lastDigits, account: accountId }; 
                    
                    if (isEdit) { 
                        const index = this.data.cards.findIndex(c => c.id === card.id); 
                        if (index !== -1) { 
                            this.data.cards[index] = cardObj; 
                        } 
                    } else { 
                        this.data.cards.push(cardObj); 
                    } 
                    this.saveData(); 
                    this.closeModal(); 
                    this.refreshView(); 
                    this.notificationSystem.show('Sucesso', `Cartão ${isEdit ? 'atualizado' : 'adicionado'} com sucesso!`, 'success'); 
                });
            }

            renderSettings(container) {
                const user = this.user; 
                const licenseInfo = this.licenseInfo; 
                
                // Determinar o tipo de plano baseado na configuração
                let licenseTypeDisplay = 'Básico';
                switch(this.PLAN_CONFIG) {
                    case 'basico':
                        licenseTypeDisplay = 'Básico';
                        break;
                    case 'essencial':
                        licenseTypeDisplay = 'Essencial';
                        break;
                    case 'completo':
                        licenseTypeDisplay = 'Completo';
                        break;
                }
                
                const licenseValidityDisplay = 'Ativo';
                const isCompleteLifetime = (this.PLAN_CONFIG === 'completo');
                const currentOffsetInMinutes = this.timezoneOffset; 
                const timezoneOptions = this.timezoneList.map(tz => `<option value="${tz.value}" ${currentOffsetInMinutes === (tz.value * -60) ? 'selected' : ''}>${tz.label}</option>`).join('');
                
                container.innerHTML = `
                <div class="card">
                    <div class="settings-section">
                        <h3 class="settings-title">Perfil</h3>
                        <div class="settings-option"><div><div class="settings-label">Nome</div><div class="settings-description">Seu nome de exibição</div></div><div class="form-row" style="margin: 0; flex: 1; max-width: 250px;"><input type="text" class="form-input" id="userName" value="${user.name}"></div></div>
                        <div class="settings-option"><div><div class="settings-label">E-mail</div><div class="settings-description">Seu endereço de e-mail</div></div><div class="form-row" style="margin: 0; flex: 1; max-width: 250px;"><input type="email" class="form-input" id="userEmail" value="${user.email}"></div></div>
                        <div class="settings-option"><div><div class="settings-label">Emoji</div><div class="settings-description">Emoji do seu perfil</div></div><div class="form-row" style="margin: 0;"><button class="btn btn-outlined" id="changeEmojiBtn"><span id="currentEmoji">${user.emoji}</span><i class="fas fa-edit" style="margin-left: 5px;"></i></button></div></div>
                        <div class="settings-option" style="border-bottom: none; padding-bottom: 0;"><div></div><div><button class="btn btn-primary" id="saveProfileBtn"><i class="fas fa-save"></i><span>Salvar Perfil</span></button></div></div>
                    </div>

                    <div class="settings-section">
                        <h3 class="settings-title">Plano</h3>
                        <div class="settings-option"><div><div class="settings-label">Tipo</div><div class="settings-description">Seu plano atual</div></div><div><span class="badge" style="background-color: ${licenseTypeDisplay === 'Básico' ? '#6366f1' : licenseTypeDisplay === 'Essencial' ? '#10b981' : '#8b5cf6'}; color: white; padding: 4px 12px; border-radius: 4px; font-weight: 600;">${licenseTypeDisplay}</span></div></div>
                        <div class="settings-option"><div><div class="settings-label">Status</div><div class="settings-description">Status do seu plano</div></div><div><span style="color: var(--secondary-color); font-weight: 600;">${licenseValidityDisplay}</span></div></div>
                        ${!isCompleteLifetime ? `<div class="settings-option" style="border-bottom: none; padding-bottom: 0;"><div><div class="settings-label">Fazer Upgrade</div><div class="settings-description">Desbloqueie mais recursos com planos superiores</div></div><div><button class="btn btn-secondary" id="upgradeLicenseBtn"><i class="fas fa-rocket"></i><span>Ver Planos</span></button></div></div>` : ''}
                    </div>

                    <div class="settings-section">
                        <h3 class="settings-title">Aparência e Exibição</h3>
                        <div class="settings-option"><div><div class="settings-label">Modo Escuro</div><div class="settings-description">Ativar/desativar modo escuro</div></div><div><label class="toggle-switch"><input type="checkbox" id="darkModeToggle" ${this.darkMode ? 'checked' : ''}><span class="toggle-slider"></span></label></div></div>
                        <div class="settings-option"><div><div class="settings-label">Fuso Horário</div><div class="settings-description">Ajustar fuso horário para exibição correta das datas</div></div><div style="flex: 1; max-width: 300px;"><select class="form-select" id="timezoneSelect">${timezoneOptions}</select></div></div>
                        <div class="settings-option" style="border-bottom: none; padding-bottom: 0;"><div><div class="settings-label">Usar saldo final do mês anterior como saldo inicial</div><div class="settings-description">Calcula o saldo inicial do mês com base no saldo final do mês anterior</div></div><div><label class="toggle-switch"><input type="checkbox" id="usePrevMonthToggle" ${this.usePreviousMonthBalance ? 'checked' : ''}><span class="toggle-slider"></span></label></div></div>
                    </div>

                    ${this.isFeatureAvailable('import_export') ? `
                    <div class="settings-section">
                        <h3 class="settings-title">Dados</h3>
                        <div class="settings-option"><div><div class="settings-label">Exportar Dados</div><div class="settings-description">Baixar seus dados em formato JSON</div></div><div><button class="btn btn-primary" id="exportDataBtn"><i class="fas fa-download"></i><span>Exportar</span></button></div></div>
                        <div class="settings-option"><div><div class="settings-label">Importar Dados</div><div class="settings-description">Carregar dados de um arquivo JSON (substitui dados atuais)</div></div><div><input type="file" id="importFileInput" accept=".json" style="display: none;"><button class="btn btn-primary" id="importDataBtn"><i class="fas fa-upload"></i><span>Importar</span></button></div></div>
                        <div class="settings-option" style="border-bottom: none; padding-bottom: 0;"><div><div class="settings-label">Limpar Dados</div><div class="settings-description">Remover todos os dados do aplicativo (ação irreversível)</div></div><div><button class="btn btn-danger" id="clearDataBtn"><i class="fas fa-trash"></i><span>Limpar</span></button></div></div>
                    </div>` : ''}
                </div>`;

                document.getElementById('saveProfileBtn').addEventListener('click', () => { 
    const name = document.getElementById('userName').value; 
    const email = document.getElementById('userEmail').value; 
    if (!name || !email) { 
        this.notificationSystem.show('Erro', 'Nome e e-mail são obrigatórios!', 'error'); 
        return; 
    } 
    this.user.name = name; 
    this.user.email = email; 
    this.saveToStorage('finance_user', this.user); 
    const profileNameEl = document.querySelector('.profile-name'); 
    const profileEmailEl = document.querySelector('.profile-email'); 
    if (profileNameEl) profileNameEl.textContent = name; 
    if (profileEmailEl) profileEmailEl.textContent = email; 
    this.notificationSystem.show('Sucesso', 'Perfil atualizado com sucesso!', 'success'); 
});
                document.getElementById('changeEmojiBtn').addEventListener('click', () => this.showEmojiPickerModal()); 
                
                const upgradeBtn = document.getElementById('upgradeLicenseBtn'); 
                if (upgradeBtn) upgradeBtn.addEventListener('click', () => this.showUpgradeModal());

                document.getElementById('darkModeToggle').addEventListener('change', (e) => { 
                    this.darkMode = e.target.checked; 
                    this.saveToStorage('finance_darkmode', this.darkMode); 
                    document.documentElement.setAttribute('data-theme', this.darkMode ? 'dark' : 'light'); 
                    this.notificationSystem.show('Sucesso', `Modo escuro ${this.darkMode ? 'ativado' : 'desativado'}!`, 'success'); 
                    this.refreshView(); 
                });

                document.getElementById('timezoneSelect').addEventListener('change', (e) => { 
                    const selectedTimezoneOffsetHours = parseFloat(e.target.value); 
                    this.timezoneOffset = selectedTimezoneOffsetHours * -60; 
                    this.saveToStorage('finance_timezone_offset', this.timezoneOffset); 
                    this.notificationSystem.show('Sucesso', 'Fuso horário atualizado! Algumas datas podem requerer recarregamento da página para refletir totalmente.', 'success', 7000); 
                    this.refreshView(); 
                });

                document.getElementById('usePrevMonthToggle').addEventListener('change', (e) => { 
                    this.usePreviousMonthBalance = e.target.checked; 
                    this.saveToStorage('finance_use_prev_month', this.usePreviousMonthBalance); 
                    this.refreshView(); 
                    this.notificationSystem.show('Sucesso', `Cálculo de saldo inicial atualizado!`, 'success'); 
                });

                if (this.isFeatureAvailable('import_export')) { 
                    document.getElementById('exportDataBtn').addEventListener('click', () => this.exportData()); 
                    
                    const importBtn = document.getElementById('importDataBtn'); 
                    const fileInput = document.getElementById('importFileInput'); 
                    importBtn.addEventListener('click', () => fileInput.click()); 
                    fileInput.addEventListener('change', (e) => { 
                        if (e.target.files.length > 0) { 
                            this.importData(e.target.files[0]); 
                            e.target.value = null; 
                        } 
                    }); 
                    document.getElementById('clearDataBtn').addEventListener('click', () => { 
                        if (confirm('ATENÇÃO! Tem certeza que deseja limpar TODOS os seus dados (transações, categorias, contas, cartões)? Esta ação é IRREVERSÍVEL!')) { 
                            if (prompt('Para confirmar, digite a palavra "LIMPAR" em maiúsculas:') === 'LIMPAR') { 
                                this.clearData(); 
                            } else { 
                                this.notificationSystem.show('Cancelado', 'Limpeza de dados cancelada.', 'info'); 
                            } 
                        } 
                    }); 
                }
            }

            showEmojiPickerModal() { 
                const modalContentEl = document.getElementById('modalContent'); 
                modalContentEl.innerHTML = `
                    <div class="modal-header"><h3 class="modal-title">Escolha um Emoji</h3><button class="modal-close" id="modalCloseEmoji">&times;</button></div>
                    <div class="modal-body"><div class="emoji-picker" id="profileEmojiPicker" style="max-height: 300px; overflow-y: auto;">${this.renderEmojiPicker(this.user.emoji)}</div></div>
                    <div class="form-footer"><button class="btn btn-outlined" id="cancelEmojiBtn">Cancelar</button><button class="btn btn-primary" id="saveEmojiBtn">Salvar</button></div>`; 
                
                document.getElementById('modalOverlay').classList.add('active'); 
                document.getElementById('modalCloseEmoji').addEventListener('click', () => this.closeModal()); 
                document.getElementById('cancelEmojiBtn').addEventListener('click', () => this.closeModal()); 
                
                document.querySelectorAll('#profileEmojiPicker .emoji-item').forEach(item => { 
                    item.addEventListener('click', () => { 
                        document.querySelectorAll('#profileEmojiPicker .emoji-item').forEach(i => i.classList.remove('selected')); 
                        item.classList.add('selected'); 
                    }); 
                }); 
                document.getElementById('saveEmojiBtn').addEventListener('click', () => { 
                    const selectedEmojiEl = document.querySelector('#profileEmojiPicker .emoji-item.selected'); 
                    if (!selectedEmojiEl) { 
                        this.notificationSystem.show('Erro', 'Selecione um emoji!', 'error'); 
                        return; 
                    } 
                    const emoji = selectedEmojiEl.textContent; 
                    this.user.emoji = emoji; 
                    this.saveToStorage('finance_user', this.user); 
                    
                    const currentEmojiBtn = document.getElementById('currentEmoji'); 
                    if (currentEmojiBtn) currentEmojiBtn.textContent = emoji; 
                    const profileAvatar = document.querySelector('.profile-avatar'); 
                    if (profileAvatar) profileAvatar.textContent = emoji; 
                    
                    this.closeModal(); 
                    this.notificationSystem.show('Sucesso', 'Emoji atualizado com sucesso!', 'success'); 
                }); 
            }

            showLicenseModal(isUpgradeContext = false) { 
                const modalContentEl = document.getElementById('modalContent'); 
                modalContentEl.innerHTML = `
                    <div class="modal-header"><h3 class="modal-title">${isUpgradeContext ? 'Fazer Upgrade com Chave' : 'Trocar Chave de Licença'}</h3><button class="modal-close" id="modalCloseLicense">&times;</button></div>
                    <div class="modal-body">
                        <p style="margin-bottom: 15px;">${isUpgradeContext ? 'Insira a chave do plano Completo para fazer o upgrade.' : 'Insira sua nova chave de licença.'}</p>
                        <div class="form-row"><label class="form-label" for="newLicenseKey">Nova Chave de Licença</label><input type="text" class="form-input" id="newLicenseKey" placeholder="xxxx-xxxx-xxxx-xxxx"></div>
                    </div>
                    <div class="form-footer"><button class="btn btn-outlined" id="cancelLicenseBtn">Cancelar</button><button class="btn btn-primary" id="updateLicenseKeyBtn">${isUpgradeContext ? 'Fazer Upgrade' : 'Atualizar Chave'}</button></div>`; 
                
                document.getElementById('modalOverlay').classList.add('active'); 
                document.getElementById('modalCloseLicense').addEventListener('click', () => this.closeModal()); 
                document.getElementById('cancelLicenseBtn').addEventListener('click', () => this.closeModal()); 
                
                document.getElementById('updateLicenseKeyBtn').addEventListener('click', () => { 
                    const licenseKey = document.getElementById('newLicenseKey').value; 
                    if (!licenseKey) { 
                        this.notificationSystem.show('Erro', 'Insira uma chave de licença!', 'error'); 
                        return; 
                    } 
                    let tempLicenseType = '', tempLicenseValidity = '', licenseFound = false; 
                    for (const type in this.licenseKeys) { 
                        for (const validity in this.licenseKeys[type]) { 
                            if (this.licenseKeys[type][validity] === licenseKey) { 
                                tempLicenseType = type; 
                                tempLicenseValidity = validity; 
                                licenseFound = true; 
                                break; 
                            } 
                        } 
                        if (licenseFound) break; 
                    } 
                    if (!licenseFound) { 
                        this.notificationSystem.show('Erro', 'Chave de licença inválida!', 'error'); 
                        return; 
                    } 
                    
                    const tempInfoForValidation = { key: licenseKey, type: tempLicenseType, validity: tempLicenseValidity, activationDate: new Date().toISOString() };
                    const originalLicense = JSON.parse(JSON.stringify(this.licenseInfo)); 
                    this.licenseInfo = tempInfoForValidation; 

                    if (!this.validateLicense(licenseKey)) { 
                         this.licenseInfo = originalLicense; 
                        return; 
                    }
                    this.saveToStorage('finance_license', this.licenseInfo); 
                    this.closeModal(); 
                    this.notificationSystem.show('Sucesso', `Licença ${isUpgradeContext ? 'atualizada para Completo' : 'trocada'} com sucesso! A página será recarregada.`, 'success', 4000); 
                    setTimeout(() => { 
                        window.location.reload(); 
                    }, 2000); 
                }); 
            }

            showUpgradeModal(targetFeature = null) {
    const currentPlan = this.PLAN_CONFIG;
    
    if (currentPlan === 'completo') {
        this.notificationSystem.show('Informação', 'Você já possui o plano mais completo disponível!', 'info');
        return;
    }
    
    const modalContentEl = document.getElementById('modalContent');
    
    // Texto específico da funcionalidade bloqueada
    let featureBlockedText = '';
    if (targetFeature) {
        const featureNames = {
            'cards': 'Cartões de Crédito',
            'preview_mode': 'Modo Previsto',
            'transfers': 'Transferências entre Contas',
            'dashboard_advanced': 'Gráficos Avançados',
            'simulator': 'Simulador de Aposentadoria',
            'auto_installments': 'Parcelamento Automático',
            'categories': 'Limite de Categorias',
            'accounts': 'Limite de Contas',
            'import_export': 'Importação e Exportação de Dados',
            'transaction_completed': 'Controle de Transações Realizadas'
        };
        
        featureBlockedText = `
            <div style="background-color: rgba(239, 68, 68, 0.1); padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid var(--danger-color); border: 1px solid rgba(239, 68, 68, 0.2);">
                <h4 style="margin-bottom: 10px; color: var(--danger-color);">🚫 Funcionalidade Bloqueada</h4>
                <p style="color: var(--text-color); margin: 0;"><strong>${featureNames[targetFeature] || 'Esta funcionalidade'}</strong> não está disponível no seu plano atual.</p>
            </div>
        `;
    }
    
    modalContentEl.innerHTML = `
        <div class="modal-header">
            <h3 class="modal-title">💎 Escolha seu Plano</h3>
            <button class="modal-close" id="modalCloseUpgrade">&times;</button>
        </div>
        <div class="modal-body">
            ${featureBlockedText}
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px; margin: 20px 0;">
                
                <!-- PLANO BÁSICO -->
                <div class="upgrade-plan-card upgrade-plan-basic" style="${currentPlan === 'basico' ? 'border-color: #22d3ee;' : ''}">
                    <div style="position: absolute; top: 12px; left: 50%; transform: translateX(-50%); background: linear-gradient(135deg, #f59e0b, #d97706); color: white; padding: 6px 16px; border-radius: 20px; font-size: 0.75rem; font-weight: bold; display: flex; align-items: center; gap: 4px;">
                        ⚠️ Para começar
                    </div>
                    
                    <div style="margin-top: 32px;">
                        <h3 class="upgrade-plan-text" style="margin-bottom: 8px; font-size: 1.5rem; font-weight: 700;">BÁSICO</h3>
                        <div class="upgrade-plan-text" style="font-size: 2.5rem; font-weight: 800; margin-bottom: 4px;">R$ 5,90</div>
                        <div class="upgrade-plan-text-muted" style="font-size: 0.9rem; margin-bottom: 24px;">Pagamento Único</div>
                    </div>
                    
                    <div style="text-align: left; margin-bottom: 24px; font-size: 0.85rem;">
                        <div class="upgrade-plan-text-muted upgrade-plan-divider" style="display: flex; align-items: center; gap: 8px; font-weight: 600; margin-bottom: 12px; padding-bottom: 6px;">
                            📊 Controle Financeiro
                        </div>
                        <div class="upgrade-plan-text" style="margin-bottom: 6px; display: flex; align-items: center; gap: 8px;"><span style="color: #ef4444;">❌</span> Sem Cartão de crédito</div>
                        <div class="upgrade-plan-text" style="margin-bottom: 6px; display: flex; align-items: center; gap: 8px;"><span style="color: #22c55e;">✅</span> 1 Conta de Banco</div>
                        <div class="upgrade-plan-text" style="margin-bottom: 16px; display: flex; align-items: center; gap: 8px;"><span style="color: #22c55e;">✅</span> 2 Categorias Personalizadas</div>
                        
                        <div class="upgrade-plan-text-muted upgrade-plan-divider" style="display: flex; align-items: center; gap: 8px; font-weight: 600; margin-bottom: 12px; padding-bottom: 6px;">
                            🔧 Funcionalidades
                        </div>
                        <div class="upgrade-plan-text" style="margin-bottom: 6px; display: flex; align-items: center; gap: 8px;"><span style="color: #22c55e;">✅</span> Entradas e Saídas</div>
                        <div class="upgrade-plan-text" style="margin-bottom: 6px; display: flex; align-items: center; gap: 8px;"><span style="color: #22c55e;">✅</span> Modo Realizado</div>
                        <div class="upgrade-plan-text" style="margin-bottom: 6px; display: flex; align-items: center; gap: 8px;"><span style="color: #ef4444;">❌</span> Modo Previsto</div>
                        <div class="upgrade-plan-text" style="margin-bottom: 6px; display: flex; align-items: center; gap: 8px;"><span style="color: #ef4444;">❌</span> Transferência entre contas</div>
                        <div class="upgrade-plan-text" style="margin-bottom: 16px; display: flex; align-items: center; gap: 8px;"><span style="color: #ef4444;">❌</span> Parcelamento automático</div>
                        
                        <div class="upgrade-plan-text-muted upgrade-plan-divider" style="display: flex; align-items: center; gap: 8px; font-weight: 600; margin-bottom: 12px; padding-bottom: 6px;">
                            🚀 Recursos Avançados
                        </div>
                        <div class="upgrade-plan-text" style="margin-bottom: 6px; display: flex; align-items: center; gap: 8px;"><span style="color: #ef4444;">❌</span> Gráficos avançados</div>
                        <div class="upgrade-plan-text" style="margin-bottom: 6px; display: flex; align-items: center; gap: 8px;"><span style="color: #ef4444;">❌</span> Simulador de aposentadoria</div>
                    </div>
                    
                    ${currentPlan === 'basico' ? '<button class="btn" style="width: 100%; background: linear-gradient(135deg, #22c55e, #16a34a); color: white; border: none; padding: 12px; border-radius: 8px; font-weight: 700; opacity: 0.6;" disabled>PLANO ATUAL</button>' : '<button class="btn" style="width: 100%; background: linear-gradient(135deg, #22c55e, #16a34a); color: white; border: none; padding: 12px; border-radius: 8px; font-weight: 700;" disabled>QUERO O BÁSICO</button>'}
                </div>
                
                <!-- PLANO ESSENCIAL -->
                <div class="upgrade-plan-card upgrade-plan-essential" style="${currentPlan === 'essencial' ? 'border-color: #22d3ee;' : ''}">
                    <div style="position: absolute; top: 12px; left: 50%; transform: translateX(-50%); background: linear-gradient(135deg, #22c55e, #16a34a); color: white; padding: 6px 16px; border-radius: 20px; font-size: 0.75rem; font-weight: bold; display: flex; align-items: center; gap: 4px;">
                        😊 Para Não Passar Sufoco
                    </div>
                    
                    <div style="margin-top: 32px;">
                        <h3 class="upgrade-plan-text" style="margin-bottom: 8px; font-size: 1.5rem; font-weight: 700;">ESSENCIAL</h3>
                        <div class="upgrade-plan-text" style="font-size: 2.5rem; font-weight: 800; margin-bottom: 4px;">R$ 15,90</div>
                        <div class="upgrade-plan-text-muted" style="font-size: 0.9rem; margin-bottom: 24px;">Pagamento Único</div>
                    </div>
                    
                    <div style="text-align: left; margin-bottom: 24px; font-size: 0.85rem;">
                        <div class="upgrade-plan-text-muted upgrade-plan-divider" style="display: flex; align-items: center; gap: 8px; font-weight: 600; margin-bottom: 12px; padding-bottom: 6px;">
                            📊 Controle Financeiro
                        </div>
                        <div class="upgrade-plan-text" style="margin-bottom: 6px; display: flex; align-items: center; gap: 8px;"><span style="color: #22c55e;">✅</span> 3 Cartões de Crédito</div>
                        <div class="upgrade-plan-text" style="margin-bottom: 6px; display: flex; align-items: center; gap: 8px;"><span style="color: #22c55e;">✅</span> 3 Contas de Banco</div>
                        <div class="upgrade-plan-text" style="margin-bottom: 16px; display: flex; align-items: center; gap: 8px;"><span style="color: #22c55e;">✅</span> 10 Categorias Personalizadas</div>
                        
                        <div class="upgrade-plan-text-muted upgrade-plan-divider" style="display: flex; align-items: center; gap: 8px; font-weight: 600; margin-bottom: 12px; padding-bottom: 6px;">
                            🔧 Funcionalidades
                        </div>
                        <div class="upgrade-plan-text" style="margin-bottom: 6px; display: flex; align-items: center; gap: 8px;"><span style="color: #22c55e;">✅</span> Entradas e Saídas</div>
                        <div class="upgrade-plan-text" style="margin-bottom: 6px; display: flex; align-items: center; gap: 8px;"><span style="color: #22c55e;">✅</span> Modo Realizado</div>
                        <div class="upgrade-plan-text" style="margin-bottom: 6px; display: flex; align-items: center; gap: 8px;"><span style="color: #22c55e;">✅</span> Modo Previsto</div>
                        <div class="upgrade-plan-text" style="margin-bottom: 6px; display: flex; align-items: center; gap: 8px;"><span style="color: #ef4444;">❌</span> Transferência entre contas</div>
                        <div class="upgrade-plan-text" style="margin-bottom: 16px; display: flex; align-items: center; gap: 8px;"><span style="color: #22c55e;">✅</span> Parcelamento automático</div>
                        
                        <div class="upgrade-plan-text-muted upgrade-plan-divider" style="display: flex; align-items: center; gap: 8px; font-weight: 600; margin-bottom: 12px; padding-bottom: 6px;">
                            🚀 Recursos Avançados
                        </div>
                        <div class="upgrade-plan-text" style="margin-bottom: 6px; display: flex; align-items: center; gap: 8px;"><span style="color: #22c55e;">✅</span> Gráficos avançados</div>
                        <div class="upgrade-plan-text" style="margin-bottom: 6px; display: flex; align-items: center; gap: 8px;"><span style="color: #ef4444;">❌</span> Simulador de aposentadoria</div>
                    </div>
                    
                    ${currentPlan === 'essencial' ? '<button class="btn" style="width: 100%; background: linear-gradient(135deg, #22c55e, #16a34a); color: white; border: none; padding: 12px; border-radius: 8px; font-weight: 700; opacity: 0.6;" disabled>PLANO ATUAL</button>' : '<button class="btn" id="upgradeEssencial" style="width: 100%; background: linear-gradient(135deg, #22c55e, #16a34a); color: white; border: none; padding: 12px; border-radius: 8px; font-weight: 700;">QUERO O ESSENCIAL</button>'}
                </div>
                
                <!-- PLANO COMPLETO -->
                <div class="upgrade-plan-card upgrade-plan-complete" style="${currentPlan === 'completo' ? 'border-color: #22d3ee;' : ''}">
                    <div style="position: absolute; top: 12px; right: 12px; background: linear-gradient(135deg, #22c55e, #16a34a); color: white; padding: 4px 12px; border-radius: 12px; font-size: 0.7rem; font-weight: bold;">
                        🔥 A Mais escolhida
                    </div>
                    <div style="position: absolute; top: 12px; left: 50%; transform: translateX(-50%); background: linear-gradient(135deg, #8b5cf6, #7c3aed); color: white; padding: 6px 16px; border-radius: 20px; font-size: 0.75rem; font-weight: bold; display: flex; align-items: center; gap: 4px;">
                        ⚡ Liberdade Total
                    </div>
                    
                    <div style="margin-top: 32px;">
                        <h3 class="upgrade-plan-text-complete" style="margin-bottom: 8px; font-size: 1.5rem; font-weight: 700;">COMPLETO</h3>
                        <div class="upgrade-plan-text-complete" style="font-size: 2.5rem; font-weight: 800; margin-bottom: 4px;">R$ 25,90</div>
                        <div class="upgrade-plan-text-complete-muted" style="font-size: 0.9rem; margin-bottom: 24px;">Pagamento Único</div>
                    </div>
                    
                    <div style="text-align: left; margin-bottom: 24px; font-size: 0.85rem;">
                        <div class="upgrade-plan-text-complete-muted upgrade-plan-divider-complete" style="display: flex; align-items: center; gap: 8px; font-weight: 600; margin-bottom: 12px; padding-bottom: 6px;">
                            📊 Controle Financeiro
                        </div>
                        <div class="upgrade-plan-text-complete" style="margin-bottom: 6px; display: flex; align-items: center; gap: 8px;"><span style="color: #22c55e;">✅</span> Cartão de Crédito <strong>ilimitado</strong></div>
                        <div class="upgrade-plan-text-complete" style="margin-bottom: 6px; display: flex; align-items: center; gap: 8px;"><span style="color: #22c55e;">✅</span> Conta de Banco <strong>ilimitado</strong></div>
                        <div class="upgrade-plan-text-complete" style="margin-bottom: 16px; display: flex; align-items: center; gap: 8px;"><span style="color: #22c55e;">✅</span> Categorias <strong>ilimitadas</strong></div>
                        
                        <div class="upgrade-plan-text-complete-muted upgrade-plan-divider-complete" style="display: flex; align-items: center; gap: 8px; font-weight: 600; margin-bottom: 12px; padding-bottom: 6px;">
                            🔧 Funcionalidades
                        </div>
                        <div class="upgrade-plan-text-complete" style="margin-bottom: 6px; display: flex; align-items: center; gap: 8px;"><span style="color: #22c55e;">✅</span> Entradas e Saídas</div>
                        <div class="upgrade-plan-text-complete" style="margin-bottom: 6px; display: flex; align-items: center; gap: 8px;"><span style="color: #22c55e;">✅</span> Modo Realizado</div>
                        <div class="upgrade-plan-text-complete" style="margin-bottom: 6px; display: flex; align-items: center; gap: 8px;"><span style="color: #22c55e;">✅</span> Modo Previsto</div>
                        <div class="upgrade-plan-text-complete" style="margin-bottom: 6px; display: flex; align-items: center; gap: 8px;"><span style="color: #22c55e;">✅</span> Transferência entre contas</div>
                        <div class="upgrade-plan-text-complete" style="margin-bottom: 16px; display: flex; align-items: center; gap: 8px;"><span style="color: #22c55e;">✅</span> Parcelamento automático</div>
                        
                        <div class="upgrade-plan-text-complete-muted upgrade-plan-divider-complete" style="display: flex; align-items: center; gap: 8px; font-weight: 600; margin-bottom: 12px; padding-bottom: 6px;">
                            🚀 Recursos Avançados
                        </div>
                        <div class="upgrade-plan-text-complete" style="margin-bottom: 6px; display: flex; align-items: center; gap: 8px;"><span style="color: #22c55e;">✅</span> Gráficos avançados</div>
                        <div class="upgrade-plan-text-complete" style="margin-bottom: 6px; display: flex; align-items: center; gap: 8px;"><span style="color: #22c55e;">✅</span> Simulador de aposentadoria</div>
                    </div>
                    
                    ${currentPlan === 'completo' ? '<button class="btn" style="width: 100%; background: linear-gradient(135deg, #22c55e, #16a34a); color: white; border: none; padding: 12px; border-radius: 8px; font-weight: 700; opacity: 0.6;" disabled>PLANO ATUAL</button>' : '<button class="btn" id="upgradeCompleto" style="width: 100%; background: linear-gradient(135deg, #22c55e, #16a34a); color: white; border: none; padding: 12px; border-radius: 8px; font-weight: 700;">QUERO O MELHOR!</button>'}
                </div>
            </div>
            
            <div style="text-align: center; font-size: 0.9rem; color: var(--text-light); margin-top: 20px;">
                <p>💳 Pagamento único • 🔒 Acesso vitalício • ⚡ Ativação imediata</p>
            </div>
        </div>
        <div class="form-footer">
            <button class="btn btn-outlined" id="cancelUpgradeBtn">Continuar com plano atual</button>
        </div>
    `;
    
    document.getElementById('modalOverlay').classList.add('active');
    
    // Event listeners
    document.getElementById('modalCloseUpgrade').addEventListener('click', () => this.closeModal());
    document.getElementById('cancelUpgradeBtn').addEventListener('click', () => this.closeModal());
    
    // Event listeners para botões de upgrade
    const upgradeEssencial = document.getElementById('upgradeEssencial');
    if (upgradeEssencial) {
        upgradeEssencial.addEventListener('click', () => {
            window.open(this.CHECKOUT_LINKS.essencial, '_blank');
            this.closeModal();
            this.notificationSystem.show('Redirecionando...', 'Você será redirecionado para o checkout do plano Essencial', 'info', 3000);
        });
    }
    
    const upgradeCompleto = document.getElementById('upgradeCompleto');
    if (upgradeCompleto) {
        upgradeCompleto.addEventListener('click', () => {
            window.open(this.CHECKOUT_LINKS.completo, '_blank');
            this.closeModal();
            this.notificationSystem.show('Redirecionando...', 'Você será redirecionado para o checkout do plano Completo', 'info', 3000);
        });
    }
}

            async exportData() {
    if (!this.isFeatureAvailable('import_export')) {
        this.notificationSystem.show('Recurso Indisponível', 'Exportação de dados requer o plano Completo.', 'warning');
        this.showUpgradeModal('import_export');
        return;
    }
    
    try {
        const exportObject = {
            version: '1.9.0',
            exportDate: new Date().toISOString(),
            user: this.user,
            license: { type: this.licenseInfo?.type, validity: this.licenseInfo?.validity },
            settings: {
                darkMode: this.darkMode,
                timezoneOffset: this.timezoneOffset,
                usePreviousMonthBalance: this.usePreviousMonthBalance
            },
            data: this.data,
            paidInvoices: this.paidCardInvoices
        };
        
        const jsonData = JSON.stringify(exportObject, null, 2);
        const blob = new Blob([jsonData], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = `financas_go_backup_${new Date().toISOString().slice(0, 10).replace(/-/g, '')}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        this.notificationSystem.show('Sucesso', 'Dados exportados com sucesso!', 'success');
    } catch (error) {
        console.error('Erro ao exportar dados:', error);
        this.notificationSystem.show('Erro na Exportação', 'Não foi possível exportar seus dados. Tente novamente mais tarde.', 'error');
    }
}

            async importData(file) {
    if (!this.isFeatureAvailable('import_export')) {
        this.notificationSystem.show('Recurso Indisponível', 'Importação de dados requer o plano Completo.', 'warning');
        this.showUpgradeModal('import_export');
        return;
    }
    
    const reader = new FileReader();
    
    reader.onload = async (e) => {
        try {
            const importedObject = JSON.parse(e.target.result);
            
            if (!importedObject.data || 
                importedObject.data.transactions === undefined || 
                importedObject.data.categories === undefined || 
                importedObject.data.accounts === undefined || 
                importedObject.data.cards === undefined) {
                throw new Error('Formato de arquivo inválido ou dados essenciais ausentes.');
            }
            
            if (confirm('ATENÇÃO: Importar este arquivo substituirá TODOS os seus dados atuais (transações, categorias, contas, cartões e algumas configurações). Deseja continuar?')) {
                this.data = importedObject.data;
                
                await this.saveToStorage('finance_data', this.data);
                
                if (importedObject.settings) {
                    this.darkMode = importedObject.settings.darkMode ?? this.darkMode;
                    this.timezoneOffset = importedObject.settings.timezoneOffset ?? this.timezoneOffset;
                    this.usePreviousMonthBalance = importedObject.settings.usePreviousMonthBalance ?? this.usePreviousMonthBalance;
                    
                    await this.saveToStorage('finance_darkmode', this.darkMode);
                    await this.saveToStorage('finance_timezone_offset', this.timezoneOffset);
                    await this.saveToStorage('finance_use_prev_month', this.usePreviousMonthBalance);
                    
                    document.documentElement.setAttribute('data-theme', this.darkMode ? 'dark' : 'light');
                }
                
                this.paidCardInvoices = importedObject.paidInvoices || [];
                await this.saveToStorage('finance_paid_invoices', this.paidCardInvoices);
                
                this.notificationSystem.show('Sucesso', 'Dados importados com sucesso! A página será recarregada.', 'success', 4000);
                setTimeout(() => {
                    window.location.reload();
                }, 2000);
            }
        } catch (error) {
            this.notificationSystem.show(
                'Erro na Importação', 
                `Falha ao importar dados: ${error.message}`, 
                'error', 
                10000
            );
            console.error('Import error:', error);
        }
    };
    
    reader.onerror = (error) => {
        this.notificationSystem.show('Erro de Leitura', 'Não foi possível ler o arquivo selecionado.', 'error');
        console.error('File reading error:', error);
    };
    
    reader.readAsText(file);
}

            async clearData() {
    if (!this.isFeatureAvailable('import_export')) {
        this.notificationSystem.show('Recurso Indisponível', 'Limpeza de dados requer o plano Completo.', 'warning');
        this.showUpgradeModal('import_export');
        return;
    }
    
    try {
        const defaultCategories = JSON.parse(JSON.stringify(this.defaultData.categories));
        const defaultAccounts = JSON.parse(JSON.stringify(this.defaultData.accounts));
        const defaultCards = JSON.parse(JSON.stringify(this.defaultData.cards));
        
        this.data = {
            transactions: [],
            categories: defaultCategories,
            accounts: defaultAccounts,
            cards: defaultCards
        };
        
        this.paidCardInvoices = [];
        
        await this.saveToStorage('finance_data', this.data);
        await this.saveToStorage('finance_paid_invoices', this.paidCardInvoices);
        
        this.notificationSystem.show('Sucesso', 'Todos os dados foram limpos e redefinidos para o padrão! A página será recarregada.', 'success', 4000);
        setTimeout(() => {
            window.location.reload();
        }, 1500);
    } catch (error) {
        console.error('Erro ao limpar dados:', error);
        this.notificationSystem.show('Erro', 'Ocorreu um erro ao limpar seus dados. Tente novamente.', 'error');
    }
}

            renderSimulator(container) { 
                container.innerHTML = `
                <div class="card simulator-card">
                    <div class="card-header"><h3 class="card-title">Simulador Financeiro</h3></div>
                    <div class="card-body">
                        <form id="simulatorForm">
                            <div class="form-row-inline">
                                <div class="form-row"><label class="form-label" for="initialInvestment">Investimento Inicial (R$)</label><input type="text" class="form-input" id="initialInvestment" placeholder="0,00" value="10.000,00"></div>
                                <div class="form-row"><label class="form-label" for="monthlyInvestment">Investimento Mensal (R$)</label><input type="text" class="form-input" id="monthlyInvestment" placeholder="0,00" value="500,00"></div>
                            </div>
                            <div class="form-row-inline">
                                <div class="form-row"><label class="form-label" for="interestRate">Taxa de Juros Anual (%)</label><input type="number" class="form-input" id="interestRate" min="0" step="0.1" value="10"></div>
                                <div class="form-row"><label class="form-label" for="yearsToInvest">Anos de Investimento</label><input type="number" class="form-input" id="yearsToInvest" min="1" max="50" value="30"></div>
                            </div>
                            <div class="form-row"><button type="button" class="btn btn-primary" id="calculateBtnSimulator"><i class="fas fa-calculator"></i><span>Calcular</span></button></div>
                        </form>
                        <div class="simulator-result" id="simulatorResult" style="display: none;">
                            <h4 class="result-title">Resultado da Simulação</h4>
                            <div class="result-grid">
                                <div class="result-item"><div class="result-value" id="totalInvested">R$ 0,00</div><div class="result-label">Total Investido</div></div>
                                <div class="result-item"><div class="result-value" id="totalInterest">R$ 0,00</div><div class="result-label">Juros Acumulados</div></div>
                                <div class="result-item"><div class="result-value" id="finalAmount">R$ 0,00</div><div class="result-label">Montante Final</div></div>
                                <div class="result-item"><div class="result-value" id="monthlyIncome">R$ 0,00</div><div class="result-label">Renda Mensal Estimada (Retirada 4% a.a.)</div></div>
                            </div>
                            <div style="margin-top: 20px;">
                                <h4 style="margin-bottom: 15px;">Evolução do Investimento</h4>
                                <div class="chart-container"><canvas id="investmentChart"></canvas></div>
                            </div>
                        </div>
                    </div>
                </div>`; 
                
                // Configurar máscaras nos campos de valor
                this.setupCurrencyMask('initialInvestment');
                this.setupCurrencyMask('monthlyInvestment');
                
                document.getElementById('calculateBtnSimulator').addEventListener('click', () => {
                    if (!this.isFeatureAvailable('simulator')) {
                        this.showUpgradeModal('simulator');
                        return;
                    }
                    this.calculateRetirement();
                }); 
            }

            calculateRetirement() { 
                const initialInvestment = this.parseValueInput(document.getElementById('initialInvestment').value) || 0; 
                const monthlyInvestment = this.parseValueInput(document.getElementById('monthlyInvestment').value) || 0; 
                const interestRate = parseFloat(document.getElementById('interestRate').value) || 0; 
                const yearsToInvest = parseInt(document.getElementById('yearsToInvest').value) || 0; 

                if (initialInvestment < 0 || monthlyInvestment < 0 || interestRate < 0 || yearsToInvest <= 0) { 
                    this.notificationSystem.show('Erro', 'Preencha todos os campos com valores válidos!', 'error'); 
                    return; 
                } 
                const monthlyRate = interestRate / 100 / 12; 
                const totalMonths = yearsToInvest * 12; 
                
                let currentTotalAmount = initialInvestment;
                let currentTotalInvested = initialInvestment; 
                
                const chartLabels = ['Ano 0'];
                const investedData = [currentTotalInvested]; 
                const totalData = [currentTotalAmount]; 
                
                for (let m = 1; m <= totalMonths; m++) { 
                    currentTotalAmount *= (1 + monthlyRate); 
                    currentTotalAmount += monthlyInvestment; 
                    currentTotalInvested += monthlyInvestment; 
                    if (m % 12 === 0) { 
                        const year = m / 12; 
                        chartLabels.push(`Ano ${year}`); 
                        investedData.push(parseFloat(currentTotalInvested.toFixed(2))); 
                        totalData.push(parseFloat(currentTotalAmount.toFixed(2))); 
                    } 
                } 
                if (totalMonths % 12 !== 0) { 
                    chartLabels.push(`Ano ${yearsToInvest}`); 
                    investedData.push(parseFloat(currentTotalInvested.toFixed(2))); 
                    totalData.push(parseFloat(currentTotalAmount.toFixed(2))); 
                } 
                
                const monthlyIncomeFromFinalAmount = currentTotalAmount * (0.04 / 12); 
                const totalInterest = currentTotalAmount - currentTotalInvested; 
                
                document.getElementById('totalInvested').textContent = `R$ ${this.formatCurrency(currentTotalInvested)}`; 
                document.getElementById('totalInterest').textContent = `R$ ${this.formatCurrency(totalInterest)}`; 
                document.getElementById('finalAmount').textContent = `R$ ${this.formatCurrency(currentTotalAmount)}`; 
                document.getElementById('monthlyIncome').textContent = `R$ ${this.formatCurrency(monthlyIncomeFromFinalAmount)}`; 
                
                document.getElementById('simulatorResult').style.display = 'block'; 
                this.createInvestmentChart(chartLabels, investedData, totalData); 
                document.getElementById('simulatorResult').scrollIntoView({ behavior: 'smooth', block: 'nearest' }); 
            }

            createInvestmentChart(labels, investedData, totalData) { 
                const canvasElement = document.getElementById('investmentChart'); 
                if (!canvasElement) return; 
                const ctx = canvasElement.getContext('2d'); 
                if (!ctx) return; 
                
                if (window.investmentChartInstance) window.investmentChartInstance.destroy(); 
                
                window.investmentChartInstance = new Chart(ctx, { 
                    type: 'line', 
                    data: { 
                        labels: labels, 
                        datasets: [ 
                            { label: 'Total Investido', data: investedData, backgroundColor: 'rgba(99, 102, 241, 0.2)', borderColor: 'rgba(99, 102, 241, 1)', borderWidth: 2, fill: true, tension: 0.1 }, 
                            { label: 'Montante Total (com Juros)', data: totalData, backgroundColor: 'rgba(16, 185, 129, 0.2)', borderColor: 'rgba(16, 185, 129, 1)', borderWidth: 2, fill: true, tension: 0.1 } 
                        ] 
                    }, 
                    options: { 
                        responsive: true, 
                        maintainAspectRatio: false, 
                        animation: { duration: 800, easing: 'easeInOutQuart' }, 
                        scales: { 
                            y: { 
                                beginAtZero: true, 
                                ticks: { 
                                    callback: value => 'R$ ' + value.toLocaleString('pt-BR'), 
                                    color: this.darkMode ? '#FFFFFF' : 'var(--text-light)' 
                                } 
                            }, 
                            x: { 
                                ticks: { 
                                    maxRotation: 0, 
                                    minRotation: 0, 
                                    autoSkip: true, 
                                    maxTicksLimit: 10, 
                                    color: this.darkMode ? '#FFFFFF' : 'var(--text-light)' 
                                } 
                            } 
                        }, 
                        plugins: { 
                            tooltip: { 
                                callbacks: { 
                                    label: context => `${context.dataset.label}: R$ ${context.raw.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}` 
                                } 
                            }, 
                            legend: { 
                                position: 'top', 
                                labels: { 
                                    color: this.darkMode ? '#FFFFFF' : 'var(--text-color)' 
                                } 
                            } 
                        } 
                    } 
                }); 
            }

            navigateMonth(offset) { 
                // Não permitir navegação de mês quando filtro personalizado está ativo
                if (this.customDateFilterEnabled) {
                    this.notificationSystem.show('Aviso', 'Desative o filtro de data personalizada para navegar por meses.', 'warning');
                    return;
                }

                let newMonth = this.currentMonth + offset; 
                let newYear = this.currentYear; 
                if (newMonth < 0) { 
                    newMonth = 11; 
                    newYear--; 
                } else if (newMonth > 11) { 
                    newMonth = 0; 
                    newYear++; 
                } 
                const currentYearLimit = new Date().getFullYear(); 
                if (newYear < currentYearLimit - 20 || newYear > currentYearLimit + 20) { 
                    this.notificationSystem.show('Aviso', 'Navegação limitada a 20 anos no passado/futuro.', 'warning'); 
                    return; 
                } 
                this.currentMonth = newMonth; 
                this.currentYear = newYear; 
                this.refreshView(); 
            }

            refreshView() { 
                if (this.currentView) { 
                    this.navigate(this.currentView); 
                } 
            }

            showExportModal() {
                const modalContentEl = document.getElementById('modalContent');
                modalContentEl.innerHTML = `
                    <div class="modal-header">
                        <h3 class="modal-title">Exportar Transações</h3>
                        <button class="modal-close" id="modalCloseExport">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="form-row">
                            <label class="form-label">Formato de Exportação</label>
                            <select class="form-select" id="exportFormat">
                                <option value="csv">CSV (Excel)</option>
                                <option value="json">JSON</option>
                                <option value="xlsx">Excel (.xlsx)</option>
                                <option value="pdf">PDF (Relatório Formatado)</option>
                            </select>
                        </div>
                        <div class="form-row">
                            <label class="form-label">Escopo da Exportação</label>
                            <div class="form-check">
                                <input type="radio" id="exportFiltered" name="exportScope" value="filtered" checked>
                                <label for="exportFiltered">Transações Filtradas Atualmente</label>
                            </div>
                            <div class="form-check">
                                <input type="radio" id="exportAll" name="exportScope" value="all">
                                <label for="exportAll">Todas as Transações</label>
                            </div>
                        </div>
                        <div class="form-row">
                            <div style="background-color: rgba(16, 185, 129, 0.1); border: 1px solid var(--secondary-color); border-radius: var(--border-radius); padding: 12px;">
                                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                                    <i class="fas fa-info-circle" style="color: var(--secondary-color);"></i>
                                    <span style="font-weight: 500;">Informações da Exportação</span>
                                </div>
                                <div id="exportInfo" style="font-size: 0.9rem; color: var(--text-light);">
                                    Calculando...
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="form-footer">
                        <button class="btn btn-outlined" id="cancelExportBtn">Cancelar</button>
                        <button class="btn btn-secondary" id="confirmExportBtn">
                            <i class="fas fa-download"></i> Exportar
                        </button>
                    </div>
                `;

                document.getElementById('modalOverlay').classList.add('active');
                document.getElementById('modalCloseExport').addEventListener('click', () => this.closeModal());
                document.getElementById('cancelExportBtn').addEventListener('click', () => this.closeModal());
                
                const updateExportInfo = () => {
                    const scope = document.querySelector('input[name="exportScope"]:checked').value;
                    const infoEl = document.getElementById('exportInfo');
                    
                    if (scope === 'filtered') {
                        const currentTransactions = this.getCurrentFilteredTransactions();
                        const periodText = this.customDateFilterEnabled ? 
                            `período de ${this.formatDate(this.customDateStart)} a ${this.formatDate(this.customDateEnd)}` :
                            `${this.getMonthName(this.currentMonth)} de ${this.currentYear}`;
                        
                        infoEl.innerHTML = `
                            <strong>Período:</strong> ${periodText}<br>
                            <strong>Total de transações:</strong> ${currentTransactions.length}<br>
                            <strong>Filtros ativos:</strong> ${this.hasActiveTransactionFilters() ? 'Sim' : 'Não'}
                        `;
                    } else {
                        infoEl.innerHTML = `
                            <strong>Período:</strong> Todas as transações<br>
                            <strong>Total de transações:</strong> ${this.data.transactions.length}<br>
                            <strong>Filtros:</strong> Nenhum aplicado
                        `;
                    }
                };
                
                document.querySelectorAll('input[name="exportScope"]').forEach(radio => {
                    radio.addEventListener('change', updateExportInfo);
                });
                
                updateExportInfo();
                
                document.getElementById('confirmExportBtn').addEventListener('click', () => {
                    const format = document.getElementById('exportFormat').value;
                    const scope = document.querySelector('input[name="exportScope"]:checked').value;
                    this.exportTransactions(format, scope);
                    this.closeModal();
                });
            }

            getCurrentFilteredTransactions() {
                const filterAccountId = this.hasActiveTransactionFilters() ? this.getEffectiveAccountFilter() : this.selectedFilterAccount;
                
                let transactions;
                if (this.customDateFilterEnabled) {
                    transactions = this.getCustomPeriodTransactions(this.customDateStart, this.customDateEnd, filterAccountId);
                } else {
                    const monthData = this.getMonthData(this.currentMonth, this.currentYear, filterAccountId);
                    transactions = monthData.transactionsInMonth;
                }
                
                if (this.hasActiveTransactionFilters()) {
                    transactions = transactions.filter(transaction => {
                        if (this.transactionFilters.type !== 'all' && transaction.type !== this.transactionFilters.type) {
                            return false;
                        }
                        
                        if (this.transactionFilters.category !== 'all' && transaction.category !== this.transactionFilters.category) {
                            return false;
                        }
                        
                        return true;
                    });
                }
                
                return transactions;
            }

            exportTransactions(format, scope) {
                let transactions;
                let filename;
                
                if (scope === 'filtered') {
                    transactions = this.getCurrentFilteredTransactions();
                    const periodText = this.customDateFilterEnabled ? 
                        `${this.formatDateForFilename(this.customDateStart)}_${this.formatDateForFilename(this.customDateEnd)}` :
                        `${this.getMonthName(this.currentMonth)}_${this.currentYear}`;
                    filename = `transacoes_${periodText}`;
                } else {
                    transactions = this.data.transactions;
                    filename = `transacoes_todas`;
                }
                
                const exportData = transactions.map(t => {
                    const account = this.data.accounts.find(a => a.id === t.account);
                    const card = this.data.cards.find(c => c.id === t.card);
                    
                    let category = '';
                    if (t.type === 'income') {
                        const cat = this.data.categories.income.find(c => c.id === t.category);
                        category = cat ? cat.name : '';
                    } else if (t.type === 'expense') {
                        const cat = this.data.categories.expense.find(c => c.id === t.category);
                        category = cat ? cat.name : '';
                    }
                    
                    const baseData = {
                        data: this.formatDate(this.parseDate(t.date)),
                        descricao: t.description,
                        valor: t.amount,
                        tipo: this.getTransactionTypeLabel(t.type),
                        categoria: category,
                        conta: account ? account.name : '',
                        concluida: t.completed ? 'Sim' : 'Não'
                    };
                    
                    if (t.type === 'card') {
                        baseData.cartao = card ? `${card.name} (*${card.lastDigits})` : '';
                        baseData.fatura = `${this.getMonthName(t.invoiceMonth)}/${t.invoiceYear}`;
                        if (t.installments > 1) {
                            baseData.parcela = `${t.currentInstallment}/${t.installments}`;
                        }
                    } else if (t.type === 'transfer') {
                        const sourceAccount = this.data.accounts.find(a => a.id === t.sourceAccount);
                        const destAccount = this.data.accounts.find(a => a.id === t.destAccount);
                        baseData.conta_origem = sourceAccount ? sourceAccount.name : '';
                        baseData.conta_destino = destAccount ? destAccount.name : '';
                    }
                    
                    return baseData;
                });

                if (format === 'csv') {
                    this.exportToCSV(exportData, filename);
                } else if (format === 'json') {
                    this.exportToJSON(exportData, filename);
                } else if (format === 'xlsx') {
                    this.exportToExcel(exportData, filename);
                } else if (format === 'pdf') {
                    this.exportToPDF(exportData, filename, scope);
                }
                
                this.notificationSystem.show('Sucesso', `${transactions.length} transações exportadas com sucesso!`, 'success');
            }

            getTransactionTypeLabel(type) {
                switch(type) {
                    case 'income': return 'Receita';
                    case 'expense': return 'Despesa';
                    case 'transfer': return 'Transferência';
                    case 'card': return 'Cartão';
                    default: return type;
                }
            }

            formatDateForFilename(date) {
                const d = new Date(date);
                return `${d.getDate().toString().padStart(2, '0')}-${(d.getMonth() + 1).toString().padStart(2, '0')}-${d.getFullYear()}`;
            }

            exportToCSV(data, filename) {
                if (data.length === 0) {
                    this.notificationSystem.show('Aviso', 'Não há dados para exportar!', 'warning');
                    return;
                }
                
                const headers = Object.keys(data[0]);
                const csvContent = [
                    headers.join(';'),
                    ...data.map(row => 
                        headers.map(header => {
                            const value = row[header] || '';
                            return `"${value.toString().replace(/"/g, '""')}"`;
                        }).join(';')
                    )
                ].join('\n');
                
                const blob = new Blob(['\ufeff' + csvContent], { type: 'text/csv;charset=utf-8;' });
                this.downloadFile(blob, `${filename}.csv`);
            }

            exportToJSON(data, filename) {
                const jsonContent = JSON.stringify(data, null, 2);
                const blob = new Blob([jsonContent], { type: 'application/json' });
                this.downloadFile(blob, `${filename}.json`);
            }

            exportToExcel(data, filename) {
                if (data.length === 0) {
                    this.notificationSystem.show('Aviso', 'Não há dados para exportar!', 'warning');
                    return;
                }
                
                const headers = Object.keys(data[0]);
                let xlsContent = '<table><tr>';
                headers.forEach(header => {
                    xlsContent += `<th>${header}</th>`;
                });
                xlsContent += '</tr>';
                
                data.forEach(row => {
                    xlsContent += '<tr>';
                    headers.forEach(header => {
                        xlsContent += `<td>${row[header] || ''}</td>`;
                    });
                    xlsContent += '</tr>';
                });
                xlsContent += '</table>';
                
                const blob = new Blob([xlsContent], { type: 'application/vnd.ms-excel' });
                this.downloadFile(blob, `${filename}.xls`);
            }

            exportToPDF(data, filename, scope) {
                try {
                    if (data.length === 0) {
                        this.notificationSystem.show('Aviso', 'Não há dados para exportar!', 'warning');
                        return;
                    }
                
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({
                    orientation: 'landscape',
                    unit: 'mm',
                    format: 'a4'
                });
                
                doc.setFont('helvetica');
                doc.setFontSize(16);
                doc.setTextColor(99, 102, 241);
                doc.text('FinancePlay - Relatório de Transações', 20, 20);
                
                let yPosition = 35;
                doc.setFontSize(10);
                doc.setTextColor(0, 0, 0);
                
                const now = new Date();
                const dateText = `Gerado em: ${this.formatDate(now)} às ${now.toLocaleTimeString('pt-BR')}`;
                doc.text(String(dateText || ''), 20, yPosition);
                yPosition += 5;
                
                if (scope === 'filtered') {
                    const periodText = this.customDateFilterEnabled ? 
                        `Período: ${this.formatDate(this.customDateStart)} a ${this.formatDate(this.customDateEnd)}` :
                        `Período: ${this.getMonthName(this.currentMonth)} de ${this.currentYear}`;
                    doc.text(String(periodText || ''), 20, yPosition);
                } else {
                    doc.text('Período: Todas as transações', 20, yPosition);
                }
                yPosition += 5;
                
                doc.text(String(`Total de transações: ${data.length}` || ''), 20, yPosition);
                yPosition += 15;
                
                const headers = ['Data', 'Descrição', 'Valor', 'Tipo', 'Categoria', 'Conta'];
                const columnWidths = [25, 60, 25, 25, 40, 30];
                const startX = 20;
                
                doc.setFontSize(8);
                doc.setFont('helvetica', 'bold');
                doc.setFillColor(99, 102, 241);
                doc.setTextColor(255, 255, 255);
                doc.rect(startX, yPosition - 3, columnWidths.reduce((a, b) => a + b, 0), 6, 'F');
                
                let xPosition = startX;
                headers.forEach((header, index) => {
                    const safeHeader = String(header || '');
                    doc.text(safeHeader, xPosition + 2, yPosition);
                    xPosition += columnWidths[index];
                });
                
                yPosition += 8;
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(0, 0, 0);
                
                const pageHeight = 210;
                const bottomMargin = 20;
                
                data.forEach((transaction, index) => {
                    if (yPosition > pageHeight - bottomMargin) {
                        doc.addPage();
                        yPosition = 20;
                        
                        doc.setFont('helvetica', 'bold');
                        doc.setFillColor(99, 102, 241);
                        doc.setTextColor(255, 255, 255);
                        doc.rect(startX, yPosition - 3, columnWidths.reduce((a, b) => a + b, 0), 6, 'F');
                        
                        xPosition = startX;
                        headers.forEach((header, index) => {
                            const safeHeader = String(header || '');
                            doc.text(safeHeader, xPosition + 2, yPosition);
                            xPosition += columnWidths[index];
                        });
                        yPosition += 8;
                        doc.setFont('helvetica', 'normal');
                        doc.setTextColor(0, 0, 0);
                    }
                    
                    if (index % 2 === 0) {
                        doc.setFillColor(245, 245, 245);
                        doc.rect(startX, yPosition - 3, columnWidths.reduce((a, b) => a + b, 0), 6, 'F');
                    }
                    
                    const formatCurrencyValue = (value) => {
                        if (typeof this.formatCurrency === 'function') {
                            return this.formatCurrency(value);
                        }
                        return parseFloat(value || 0).toLocaleString('pt-BR', { 
                            minimumFractionDigits: 2, 
                            maximumFractionDigits: 2 
                        });
                    };
                    
                    const rowData = [
                        String(transaction.data || ''),
                        this.truncateText(String(transaction.descricao || ''), 35),
                        `R$ ${formatCurrencyValue(transaction.valor || 0)}`,
                        String(transaction.tipo || ''),
                        this.truncateText(String(transaction.categoria || ''), 25),
                        this.truncateText(String(transaction.conta || ''), 20)
                    ];
                    
                    xPosition = startX;
                    rowData.forEach((cellData, colIndex) => {
                        const safeText = String(cellData || '');
                        doc.text(safeText, xPosition + 2, yPosition);
                        xPosition += columnWidths[colIndex];
                    });
                    
                    yPosition += 6;
                });
                
                const totalIncome = data.filter(t => t.tipo === 'Receita').reduce((sum, t) => sum + parseFloat(t.valor || 0), 0);
                const totalExpense = data.filter(t => t.tipo === 'Despesa' || t.tipo === 'Cartão').reduce((sum, t) => sum + parseFloat(t.valor || 0), 0);
                const balance = totalIncome - totalExpense;
                
                yPosition += 10;
                if (yPosition > pageHeight - 40) {
                    doc.addPage();
                    yPosition = 20;
                }
                
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(9);
                doc.text('RESUMO FINANCEIRO:', startX, yPosition);
                yPosition += 8;
                
                const formatCurrencyValue = (value) => {
                    if (typeof this.formatCurrency === 'function') {
                        return this.formatCurrency(value);
                    }
                    return parseFloat(value || 0).toLocaleString('pt-BR', { 
                        minimumFractionDigits: 2, 
                        maximumFractionDigits: 2 
                    });
                };
                
                doc.setTextColor(16, 185, 129);
                doc.text(`Total de Receitas: R$ ${formatCurrencyValue(totalIncome)}`, startX, yPosition);
                yPosition += 6;
                
                doc.setTextColor(239, 68, 68);
                doc.text(`Total de Despesas: R$ ${formatCurrencyValue(totalExpense)}`, startX, yPosition);
                yPosition += 6;
                
                if (balance >= 0) {
                    doc.setTextColor(16, 185, 129);
                } else {
                    doc.setTextColor(239, 68, 68);
                }
                doc.text(`Saldo: R$ ${formatCurrencyValue(balance)}`, startX, yPosition);
                
                const pageCount = doc.internal.getNumberOfPages();
                for (let i = 1; i <= pageCount; i++) {
                    doc.setPage(i);
                    doc.setFontSize(8);
                    doc.setTextColor(128, 128, 128);
                    doc.text(String(`Página ${i} de ${pageCount}` || ''), 250, 200);
                }
                
                doc.save(`${filename}.pdf`);
                } catch (error) {
                    console.error('Erro ao gerar PDF:', error);
                    this.notificationSystem.show('Erro', 'Erro ao gerar PDF: ' + error.message, 'error');
                }
            }

            truncateText(text, maxLength) {
                if (!text) return '';
                return text.length > maxLength ? text.substring(0, maxLength - 3) + '...' : text;
            }

            downloadFile(blob, filename) {
                const link = document.createElement('a');
                if (link.download !== undefined) {
                    const url = URL.createObjectURL(blob);
                    link.setAttribute('href', url);
                    link.setAttribute('download', filename);
                    link.style.visibility = 'hidden';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                }
            }

            closeModal() { 
                const modalOverlay = document.getElementById('modalOverlay'); 
                if (modalOverlay) { 
                    modalOverlay.classList.remove('active'); 
                    const modalContent = document.getElementById('modalContent'); 
                    if (modalContent) { 
                        modalContent.innerHTML = ''; 
                    } 
                } 
            }
        } 

        class NotificationSystem {
    constructor() { 
        this.container = document.getElementById('notificationContainer'); 
        this.maxVisibleNotifications = 1; // Reduzido para apenas 1 notificação visível por vez
        this.activeNotifications = [];

        if (!this.container) { 
            this.container = document.createElement('div'); 
            this.container.id = 'notificationContainer'; 
            this.container.style.position = 'fixed'; 
            this.container.style.top = '20px'; 
            this.container.style.right = '20px'; 
            this.container.style.zIndex = '2000'; 
            this.container.style.width = 'auto'; 
            this.container.style.maxWidth = '350px'; 
            document.body.appendChild(this.container); 
        } 
    }
    show(title, message, type = 'info', duration = 5000) { 
        // Fechar notificações existentes antes de mostrar uma nova
        this.activeNotifications.forEach(notification => {
            this.close(notification, true);
        });
        this.activeNotifications = [];

        const notificationId = `notification-${Date.now()}-${Math.random().toString(36).substring(2,7)}`;
        const notification = document.createElement('div'); 
        notification.className = `notification notification-${type}`; 
        notification.id = notificationId; 
        notification.innerHTML = `
            <div class="notification-icon"><i class="fas ${this.getIconClass(type)}"></i></div>
            <div class="notification-content">
                <div class="notification-title">${title}</div>
                <div class="notification-message">${message}</div>
            </div>
            <button class="notification-close" aria-label="Fechar notificação"><i class="fas fa-times"></i></button>`; 
        
        this.container.prepend(notification); 
        this.activeNotifications.push(notification); 
        
        void notification.offsetWidth; 
        requestAnimationFrame(() => { 
            notification.classList.add('active'); 
        }); 
        
        const closeBtn = notification.querySelector('.notification-close'); 
        closeBtn.addEventListener('click', () => this.close(notification)); 
        
        if (duration > 0) { 
            setTimeout(() => this.close(notification), duration); 
        } 
        return notification; 
    }

    close(notification, immediate = false) { 
        if (!notification || !notification.parentNode) return; 
        
        this.activeNotifications = this.activeNotifications.filter(n => n.id !== notification.id);

        if (immediate) {
             if (notification.parentNode === this.container) {
                this.container.removeChild(notification);
            }
            return;
        }

        notification.classList.remove('active'); 
        
        const removeNode = () => {
            if (notification.parentNode === this.container) {
                this.container.removeChild(notification);
            }
            notification.removeEventListener('transitionend', removeNode); 
        };
        
        notification.addEventListener('transitionend', removeNode); 
        
        setTimeout(() => { 
            if (notification && notification.parentNode === this.container && !notification.classList.contains('active')) {
                 removeNode(); 
            }
        }, 500); 
    }

    getIconClass(type) { 
        switch (type) { 
            case 'success': return 'fa-check-circle'; 
            case 'error': return 'fa-times-circle'; 
            case 'warning': return 'fa-exclamation-triangle'; 
            case 'info': 
            default: return 'fa-info-circle'; 
        } 
    }
}
class IndexedDBManager {
    constructor(dbName = 'FinancasGO_Universal', version = 1) {
        this.dbName = 'FinancasGO_Universal';
        this.version = version;
        this.db = null;
        this.isReady = false;
        this.isAvailable = typeof window !== 'undefined' && window.indexedDB !== undefined;
        this._initPromise = this.isAvailable ? this._initDB() : Promise.resolve(null);
    }

    async _initDB() {
        if (!this.isAvailable) {
            console.warn("IndexedDB não está disponível neste navegador");
            return Promise.resolve(null);
        }
        
        return new Promise((resolve, reject) => {
            try {
                const request = indexedDB.open(this.dbName, this.version);

                request.onupgradeneeded = (event) => {
                    try {
                        const db = event.target.result;
                        
                        if (!db.objectStoreNames.contains('appData')) {
                            db.createObjectStore('appData');
                        }
                    } catch (error) {
                        console.error('Erro durante upgrade do IndexedDB:', error);
                        // Não rejeitamos aqui porque o onupgradeneeded pode falhar mas o banco
                        // ainda pode abrir com sucesso
                    }
                };

                request.onsuccess = (event) => {
                    this.db = event.target.result;
                    this.isReady = true;
                    console.log('IndexedDB inicializado com sucesso');
                    
                    // Configurar manipulador de eventos para lidar com bloqueios e erros
                    this.db.onversionchange = () => {
                        this.db.close();
                        console.warn('IndexedDB atualizado em outra aba. Por favor, recarregue a página.');
                    };
                    
                    // Configurar manipulador de eventos para detectar erros no banco de dados
                    this.db.onerror = (event) => {
                        console.error('Erro no IndexedDB:', event.target.error);
                    };
                    
                    resolve(this.db);
                };

                request.onerror = (event) => {
                    console.error('Erro ao abrir IndexedDB:', event.target.error);
                    this.isAvailable = false;
                    reject(event.target.error);
                };
                
                // Tratar timeout na abertura do banco de dados (alguns navegadores podem travar)
                setTimeout(() => {
                    if (!this.isReady) {
                        console.error('Timeout ao abrir IndexedDB');
                        this.isAvailable = false;
                        reject(new Error('Timeout ao abrir IndexedDB'));
                    }
                }, 5000);
            } catch (error) {
                console.error('Erro ao inicializar IndexedDB:', error);
                this.isAvailable = false;
                reject(error);
            }
        });
    }

    async ready() {
        if (!this.isAvailable) {
            return Promise.resolve(null);
        }
        
        try {
            return await this._initPromise;
        } catch (error) {
            console.error('Falha ao inicializar IndexedDB:', error);
            this.isAvailable = false;
            return null;
        }
    }

    async saveData(key, value) {
        if (!this.isAvailable) {
            return Promise.reject(new Error('IndexedDB não está disponível'));
        }
        
        try {
            await this.ready();
            
            if (!this.db) {
                return Promise.reject(new Error('IndexedDB não está inicializado'));
            }
            
            return new Promise((resolve, reject) => {
                try {
                    const transaction = this.db.transaction(['appData'], 'readwrite');
                    const store = transaction.objectStore('appData');
                    
                    const request = store.put(value, key);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => {
                        console.error(`Erro ao salvar dados para a chave "${key}":`, event.target.error);
                        reject(event.target.error);
                    };
                    
                    // Adicionar tratamento de erros de transação
                    transaction.oncomplete = () => {
                        // Transação concluída com sucesso
                    };
                    
                    transaction.onerror = (event) => {
                        console.error(`Erro na transação ao salvar "${key}":`, event.target.error);
                        reject(event.target.error);
                    };
                    
                    transaction.onabort = (event) => {
                        console.error(`Transação abortada ao salvar "${key}":`, event.target.error);
                        reject(event.target.error);
                    };
                } catch (error) {
                    console.error(`Erro ao criar transação para salvar "${key}":`, error);
                    reject(error);
                }
            });
        } catch (error) {
            console.error(`Falha ao salvar dados para "${key}":`, error);
            return Promise.reject(error);
        }
    }

    async loadData(key) {
        if (!this.isAvailable) {
            return Promise.reject(new Error('IndexedDB não está disponível'));
        }
        
        try {
            await this.ready();
            
            if (!this.db) {
                return Promise.reject(new Error('IndexedDB não está inicializado'));
            }
            
            return new Promise((resolve, reject) => {
                try {
                    const transaction = this.db.transaction(['appData'], 'readonly');
                    const store = transaction.objectStore('appData');
                    
                    const request = store.get(key);
                    
                    request.onsuccess = (event) => resolve(event.target.result);
                    request.onerror = (event) => {
                        console.error(`Erro ao carregar dados para a chave "${key}":`, event.target.error);
                        reject(event.target.error);
                    };
                } catch (error) {
                    console.error(`Erro ao criar transação para carregar "${key}":`, error);
                    reject(error);
                }
            });
        } catch (error) {
            console.error(`Falha ao carregar dados para "${key}":`, error);
            return Promise.reject(error);
        }
    }

    async deleteData(key) {
        if (!this.isAvailable) {
            return Promise.reject(new Error('IndexedDB não está disponível'));
        }
        
        try {
            await this.ready();
            
            if (!this.db) {
                return Promise.reject(new Error('IndexedDB não está inicializado'));
            }
            
            return new Promise((resolve, reject) => {
                try {
                    const transaction = this.db.transaction(['appData'], 'readwrite');
                    const store = transaction.objectStore('appData');
                    
                    const request = store.delete(key);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => {
                        console.error(`Erro ao excluir dados para a chave "${key}":`, event.target.error);
                        reject(event.target.error);
                    };
                } catch (error) {
                    console.error(`Erro ao criar transação para excluir "${key}":`, error);
                    reject(error);
                }
            });
        } catch (error) {
            console.error(`Falha ao excluir dados para "${key}":`, error);
            return Promise.reject(error);
        }
    }

    async getAllKeys() {
        if (!this.isAvailable) {
            return Promise.reject(new Error('IndexedDB não está disponível'));
        }
        
        try {
            await this.ready();
            
            if (!this.db) {
                return Promise.reject(new Error('IndexedDB não está inicializado'));
            }
            
            return new Promise((resolve, reject) => {
                try {
                    const transaction = this.db.transaction(['appData'], 'readonly');
                    const store = transaction.objectStore('appData');
                    
                    const request = store.getAllKeys();
                    
                    request.onsuccess = (event) => resolve(event.target.result);
                    request.onerror = (event) => {
                        console.error('Erro ao obter todas as chaves:', event.target.error);
                        reject(event.target.error);
                    };
                } catch (error) {
                    console.error('Erro ao criar transação para obter chaves:', error);
                    reject(error);
                }
            });
        } catch (error) {
            console.error('Falha ao obter todas as chaves:', error);
            return Promise.reject(error);
        }
    }

    async clearAll() {
        if (!this.isAvailable) {
            return Promise.reject(new Error('IndexedDB não está disponível'));
        }
        
        try {
            await this.ready();
            
            if (!this.db) {
                return Promise.reject(new Error('IndexedDB não está inicializado'));
            }
            
            return new Promise((resolve, reject) => {
                try {
                    const transaction = this.db.transaction(['appData'], 'readwrite');
                    const store = transaction.objectStore('appData');
                    
                    const request = store.clear();
                    
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => {
                        console.error('Erro ao limpar banco de dados:', event.target.error);
                        reject(event.target.error);
                    };
                } catch (error) {
                    console.error('Erro ao criar transação para limpar dados:', error);
                    reject(error);
                }
            });
        } catch (error) {
            console.error('Falha ao limpar todos os dados:', error);
            return Promise.reject(error);
        }
    }

    async migrateFromLocalStorage() {
        if (!this.isAvailable) {
            console.warn('IndexedDB não está disponível, migração ignorada');
            return {};
        }
        
        try {
            await this.ready();
            
            if (!this.db) {
                console.warn('IndexedDB não está inicializado, migração ignorada');
                return {};
            }
            
            const keysToMigrate = [
                'finance_data', 
                'finance_user', 
                'finance_license', 
                'finance_darkmode',
                'finance_timezone_offset',
                'finance_use_prev_month',
                'finance_paid_invoices',
                'finance_hide_upgrade_timestamp'
            ];
            
            const migratedData = {};
            
            for (const key of keysToMigrate) {
                try {
                    const data = localStorage.getItem(key);
                    if (data !== null) {
                        const parsedData = JSON.parse(data);
                        await this.saveData(key, parsedData);
                        migratedData[key] = parsedData;
                        console.log(`Migrado com sucesso: ${key}`);
                    }
                } catch (error) {
                    console.error(`Erro ao migrar chave "${key}"`, error);
                }
            }
            
            return migratedData;
        } catch (error) {
            console.error('Falha na migração de dados do localStorage:', error);
            return {};
        }
    }
}
        document.addEventListener('DOMContentLoaded', async () => {
    if (typeof Chart !== 'undefined') {
        try {
            if (!window.indexedDB) {
                console.warn("IndexedDB não é suportado neste navegador. Usando localStorage como fallback.");
                displayBrowserWarning();
            }
            
            
// ========= Verdão 2.0: Drilldown + Export =========
function _fg_escapeCsv(value){
  const s = String(value ?? '');
  if (/[",\n]/.test(s)) return '"' + s.replace(/"/g,'""') + '"';
  return s;
}

FinanceApp.prototype._fg_getMonthDataForCurrentView = function(){
  const filterAccountId = this.transactionFilters?.account || 'all';
  if (this.customDateFilterEnabled) {
    return this.getMonthData(this.currentMonth, this.currentYear, filterAccountId, this.customDateStart, this.customDateEnd);
  }
  return this.getMonthData(this.currentMonth, this.currentYear, filterAccountId);
};

FinanceApp.prototype.openCategoryDrilldown = function(categoryId, type){
  const monthData = this._fg_getMonthDataForCurrentView();
  const tx = (monthData.transactions || []).filter(t => t.type === type && (t.category || '') === categoryId);
  const catList = (this.data?.categories?.[type] || []);
  const cat = catList.find(c => c.id === categoryId);
  const catName = cat ? `${cat.emoji ? cat.emoji + ' ' : ''}${cat.name}` : 'Categoria';
  const typeLabel = type === 'income' ? 'Receitas' : type === 'investment' ? 'Investimentos' : type === 'transfer' ? 'Transferências' : 'Despesas';
  this.openTransactionsDrilldown(`${catName} • ${typeLabel}`, tx, { categoryId, type });
};

FinanceApp.prototype.openTransactionsDrilldown = function(title, transactions, meta = {}){
  const overlay = document.getElementById('drilldownModalOverlay');
  const closeBtn = document.getElementById('drilldownCloseBtn');
  const tbody = document.getElementById('drilldownTbody');
  const empty = document.getElementById('drilldownEmpty');
  const search = document.getElementById('drilldownSearch');
  const titleEl = document.getElementById('drilldownTitle');
  const metaEl = document.getElementById('drilldownMeta');
  const pill = document.getElementById('drilldownTotalPill');

  if(!overlay || !tbody || !search) return;

  titleEl.textContent = title;

  const periodText = this.customDateFilterEnabled && this.customDateStart && this.customDateEnd
    ? `Período: ${new Date(this.customDateStart).toLocaleDateString('pt-BR')} → ${new Date(this.customDateEnd).toLocaleDateString('pt-BR')}`
    : `Mês: ${String(this.currentMonth + 1).padStart(2,'0')}/${this.currentYear}`;

  const accountsById = new Map((this.data?.accounts || []).map(a => [a.id, a]));
  const categoriesAll = [
    ...(this.data?.categories?.expense || []),
    ...(this.data?.categories?.income || []),
    ...(this.data?.categories?.investment || []),
    ...(this.data?.categories?.transfer || [])
  ];
  const categoriesById = new Map(categoriesAll.map(c => [c.id, c]));

  const normalized = (transactions || []).map(t => {
    const d = new Date(t.date);
    const acc = accountsById.get(t.account);
    const cat = categoriesById.get(t.category);
    return {
      id: t.id,
      dateObj: d,
      date: isNaN(d) ? '' : d.toLocaleDateString('pt-BR'),
      description: t.description || '',
      account: acc ? acc.name : (t.account || ''),
      amount: Number(t.amount || 0),
      category: cat ? cat.name : ''
    };
  }).sort((a,b)=> (a.dateObj?.getTime?.()||0) - (b.dateObj?.getTime?.()||0));

  const render = (q='')=>{
    const qq = q.trim().toLowerCase();
    const list = qq ? normalized.filter(r => (r.description||'').toLowerCase().includes(qq)) : normalized;

    tbody.innerHTML = '';
    if(list.length === 0){
      empty.style.display = 'block';
    } else {
      empty.style.display = 'none';
      const frag = document.createDocumentFragment();
      list.forEach(r=>{
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${r.date}</td>
          <td>${r.description}</td>
          <td>${r.account}</td>
          <td class="amount">${r.amount.toLocaleString('pt-BR',{style:'currency',currency:'BRL',minimumFractionDigits:2,maximumFractionDigits:2})}</td>
        `;
        frag.appendChild(tr);
      });
      tbody.appendChild(frag);
    }

    const total = list.reduce((s,r)=>s+r.amount,0);
    pill.textContent = `Total: ${total.toLocaleString('pt-BR',{style:'currency',currency:'BRL',minimumFractionDigits:2,maximumFractionDigits:2})}`;
    metaEl.textContent = `${periodText} • Itens: ${list.length}`;
  };

  search.oninput = ()=>render(search.value);

  const close = ()=>{
    overlay.classList.remove('active');
    document.removeEventListener('keydown', onEsc);
  };
  const onEsc = (e)=>{ if(e.key === 'Escape') close(); };
  closeBtn.onclick = close;
  overlay.onclick = (e)=>{ if(e.target === overlay) close(); };

  document.getElementById('drilldownExportCsv').onclick = ()=>{
    const rows = [['Data','Descrição','Conta','Valor']];
    const qq = (search.value||'').trim().toLowerCase();
    const list = qq ? normalized.filter(r => (r.description||'').toLowerCase().includes(qq)) : normalized;
    list.forEach(r=> rows.push([r.date, r.description, r.account, r.amount.toFixed(2)]));
    const csv = rows.map(row => row.map(_fg_escapeCsv).join(',')).join('\n');
    const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `financas_go_detalhes_${(meta.type||'')}_${Date.now()}.csv`;
    document.body.appendChild(a);
    a.click();
    a.remove();
  };

  document.getElementById('drilldownExportPdf').onclick = ()=>{
    try{
      const { jsPDF } = window.jspdf || {};
      if(!jsPDF){ this.notificationSystem?.show('Aviso','jsPDF não carregou para exportar PDF.','warning'); return; }
      const doc = new jsPDF({orientation:'p', unit:'pt', format:'a4'});
      const margin = 40;
      let y = margin;
      doc.setFontSize(14);
      doc.text(title, margin, y);
      y += 18;
      doc.setFontSize(10);
      doc.text(metaEl.textContent || '', margin, y);
      y += 14;

      const qq = (search.value||'').trim().toLowerCase();
      const list = qq ? normalized.filter(r => (r.description||'').toLowerCase().includes(qq)) : normalized;

      doc.setFontSize(9);
      const colX = [margin, margin+70, margin+300, 555];
      doc.text('Data', colX[0], y);
      doc.text('Descrição', colX[1], y);
      doc.text('Conta', colX[2], y);
      doc.text('Valor', colX[3], y, {align:'right'});
      y += 10;
      doc.setLineWidth(0.5);
      doc.line(margin, y, 555, y);
      y += 12;

      const money = (v)=> v.toLocaleString('pt-BR',{style:'currency',currency:'BRL',minimumFractionDigits:2,maximumFractionDigits:2});
      list.forEach(r=>{
        if(y > 780){ doc.addPage(); y = margin; }
        doc.text(r.date, colX[0], y);
        doc.text(String(r.description).slice(0,42), colX[1], y);
        doc.text(String(r.account).slice(0,24), colX[2], y);
        doc.text(money(r.amount), colX[3], y, {align:'right'});
        y += 14;
      });
      y += 8;
      const total = list.reduce((s,r)=>s+r.amount,0);
      doc.setFontSize(11);
      doc.text(`Total: ${money(total)}`, colX[3], y, {align:'right'});
      doc.save(`financas_go_detalhes_${Date.now()}.pdf`);
    }catch(err){
      console.error(err);
      this.notificationSystem?.show('Erro','Falha ao gerar PDF.','error');
    }
  };

  overlay.classList.add('active');
  search.value = '';
  render('');
  setTimeout(()=>search.focus(), 50);
  document.addEventListener('keydown', onEsc);
};

FinanceApp.prototype._fg_attachChartClickHandlers = function(){
  // Despesas por categoria (donut)
  if (window.categoryChartInstance && !window.categoryChartInstance._fg_click_patched) {
    window.categoryChartInstance._fg_click_patched = true;
    window.categoryChartInstance.options.onClick = (event, elements) => {
      if (!elements || elements.length === 0) return;
      const idx = elements[0].index;
      const label = window.categoryChartInstance.data.labels[idx];
      const cat = (this.data?.categories?.expense || []).find(c => c.name === label);
      if (cat) this.openCategoryDrilldown(cat.id, 'expense');
    };
    window.categoryChartInstance.update();
  }
  // Receitas por categoria (donut)
  if (window.incomeCategoryChartInstance && !window.incomeCategoryChartInstance._fg_click_patched) {
    window.incomeCategoryChartInstance._fg_click_patched = true;
    window.incomeCategoryChartInstance.options.onClick = (event, elements) => {
      if (!elements || elements.length === 0) return;
      const idx = elements[0].index;
      const label = window.incomeCategoryChartInstance.data.labels[idx];
      const cat = (this.data?.categories?.income || []).find(c => c.name === label);
      if (cat) this.openCategoryDrilldown(cat.id, 'income');
    };
    window.incomeCategoryChartInstance.update();
  }
};

const _fg_originalRefreshView = FinanceApp.prototype.refreshView;
FinanceApp.prototype.refreshView = function(){
  _fg_originalRefreshView.apply(this, arguments);
  setTimeout(()=>{ try{ this._fg_attachChartClickHandlers(); }catch(e){} }, 60);
};


window.app = new FinanceApp();
            await window.app.init(); 
        } catch (error) {
            console.error("Erro ao inicializar a aplicação:", error);
            displayErrorMessage();
        }
    } else {
        console.error("Chart.js não foi carregado.");
        displayChartJsError();
    }
});

function displayBrowserWarning() {
    const appDiv = document.getElementById('app');
    if (appDiv) {
        appDiv.insertAdjacentHTML('afterbegin', `
            <div class="notification notification-warning active" style="position: relative; margin-bottom: 15px;">
                <div class="notification-icon"><i class="fas fa-exclamation-triangle"></i></div>
                <div class="notification-content">
                    <div class="notification-title">Navegador com suporte limitado</div>
                    <div class="notification-message">Seu navegador não suporta recursos modernos de armazenamento. A aplicação ainda funcionará, mas com limitações de armazenamento.</div>
                </div>
                <button class="notification-close" onclick="this.parentElement.remove()"><i class="fas fa-times"></i></button>
            </div>
        `);
    }
}

function displayErrorMessage() {
    const appDiv = document.getElementById('app');
    if (appDiv) {
        appDiv.innerHTML = `
            <div class="card no-data">
                <i class="fas fa-exclamation-triangle" style="color: var(--danger-color);"></i>
                <p>Ocorreu um erro ao inicializar a aplicação. Tente recarregar a página.</p>
                <button class="btn btn-primary" onclick="window.location.reload()" style="margin-top: 15px;">
                    <i class="fas fa-sync-alt"></i> Recarregar
                </button>
            </div>
        `;
    }
}

function displayChartJsError() {
    const appDiv = document.getElementById('app');
    if (appDiv) {
        appDiv.innerHTML = `
            <div class="card no-data">
                <i class="fas fa-exclamation-triangle"></i>
                <p>Erro ao carregar componentes gráficos. Tente recarregar a página.</p>
                <button class="btn btn-primary" onclick="window.location.reload()" style="margin-top: 15px;">
                    <i class="fas fa-sync-alt"></i> Recarregar
                </button>
            </div>
        `;
    }
}

function createFilterModal() {
    const modalHTML = `
        <div class="modal-overlay" id="filterModal">
            <div class="modal">
                <div class="modal-header">
                    <h3 class="modal-title">Filtros de Transações</h3>
                    <button class="modal-close" id="closeFilterModal">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="form-row">
                        <label class="form-label">Período</label>
                        <select class="form-select" id="periodTypeFilterModal">
                            <option value="monthly">Por Mês</option>
                            <option value="custom">Data Personalizada</option>
                        </select>
                    </div>
                    <div class="form-row" id="customDateFieldsModal" style="display: none;">
                        <div class="form-row-inline">
                            <div>
                                <label class="form-label">Data Inicial</label>
                                <input type="date" class="form-input" id="startDateFilterModal">
                            </div>
                            <div>
                                <label class="form-label">Data Final</label>
                                <input type="date" class="form-input" id="endDateFilterModal">
                            </div>
                        </div>
                    </div>
                    <div class="form-row">
                        <label class="form-label">Tipo de Transação</label>
                        <select class="form-select" id="transactionTypeFilterModal">
                            <option value="all">Todas</option>
                            <option value="income">Receitas</option>
                            <option value="expense">Despesas</option>
                            <option value="transfer">Transferências</option>
                        </select>
                    </div>
                    <div class="form-row">
                        <label class="form-label">Categoria</label>
                        <select class="form-select" id="categoryFilterModal">
                            <option value="all">Todas</option>
                        </select>
                    </div>
                    <div class="form-row">
                        <label class="form-label">Conta</label>
                        <select class="form-select" id="accountFilterModal">
                            <option value="all">Todas</option>
                        </select>
                    </div>
                    <div class="form-row">
                        <label class="form-label">Ordenação por Data</label>
                        <select class="form-select" id="sortOrderFilterModal">
                            <option value="asc">Mais Antigo Primeiro</option>
                            <option value="desc">Mais Recente Primeiro</option>
                        </select>
                    </div>
                </div>
                <div class="form-footer">
                    <button class="btn btn-outlined" id="clearFiltersModal">
                        <i class="fas fa-times"></i> Limpar
                    </button>
                    <button class="btn btn-primary" id="applyFiltersModal">
                        <i class="fas fa-filter"></i> Aplicar Filtros
                    </button>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
}
    </script>

<!-- Drilldown Modal (clicar em categorias/gráficos) -->
<div class="modal-overlay" id="drilldownModalOverlay">
  <div class="modal drilldown-modal">
    <div class="modal-header">
      <div>
        <div class="modal-title" id="drilldownTitle">Detalhes</div>
        <div class="drilldown-header-meta" id="drilldownMeta"></div>
      </div>
      <button class="modal-close" id="drilldownCloseBtn">&times;</button>
    </div>
    <div class="modal-body">
      <div class="drilldown-toolbar">
        <input class="form-input drilldown-search" id="drilldownSearch" placeholder="Buscar por descrição..." />
        <div class="drilldown-pill" id="drilldownTotalPill">Total: R$ 0,00</div>
      </div>
      <div style="overflow:auto; max-height: 60vh;">
        <table class="drilldown-table">
          <thead>
            <tr>
              <th>Data</th>
              <th>Descrição</th>
              <th>Conta</th>
              <th class="amount">Valor</th>
            </tr>
          </thead>
          <tbody id="drilldownTbody"></tbody>
        </table>
      </div>
      <div id="drilldownEmpty" class="no-data" style="display:none; margin-top:12px;">
        <i class="fas fa-list"></i>
        <p>Nenhum lançamento encontrado.</p>
      </div>
      <div style="display:flex; gap:10px; justify-content:flex-end; margin-top: 14px;">
        <button class="btn btn-outlined" id="drilldownExportCsv"><i class="fas fa-file-csv"></i> Exportar CSV</button>
        <button class="btn btn-primary" id="drilldownExportPdf"><i class="fas fa-file-pdf"></i> Exportar PDF</button>
      </div>
    </div>
  </div>
</div>

</body>
</html>
